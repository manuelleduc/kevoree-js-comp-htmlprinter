require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {
  var self = this
  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)

  var type = typeof subject
  var length

  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) {
    // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +
      kMaxLength.toString(16) + ' bytes')
  }

  if (length < 0) length = 0
  else length >>>= 0 // coerce to uint32

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++) {
        self[i] = subject.readUInt8(i)
      }
    } else {
      for (i = 0; i < length; i++) {
        self[i] = ((subject[i] % 256) + 256) % 256
      }
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, totalLength) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function byteLength (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - target_start < end - start) {
    end = target.length - target_start + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":8,"events":6,"url":32}],8:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":9,"Base64":10,"inherits":11,"stream":30}],9:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":30,"util":34}],10:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],11:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],12:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],13:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":14}],14:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],18:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":16,"./encode":17}],19:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":20}],20:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":22,"./_stream_writable":24,"_process":14,"core-util-is":25,"inherits":11}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":23,"core-util-is":25,"inherits":11}],22:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":20,"_process":14,"buffer":2,"core-util-is":25,"events":6,"inherits":11,"isarray":12,"stream":30,"string_decoder/":31,"util":1}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":20,"core-util-is":25,"inherits":11}],24:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":20,"_process":14,"buffer":2,"core-util-is":25,"inherits":11,"stream":30}],25:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":2}],26:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":21}],27:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":20,"./lib/_stream_passthrough.js":21,"./lib/_stream_readable.js":22,"./lib/_stream_transform.js":23,"./lib/_stream_writable.js":24,"stream":30}],28:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":23}],29:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":24}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":11,"readable-stream/duplex.js":19,"readable-stream/passthrough.js":26,"readable-stream/readable.js":27,"readable-stream/transform.js":28,"readable-stream/writable.js":29}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":2}],32:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":15,"querystring":18}],33:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],34:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":33,"_process":14,"inherits":11}],35:[function(require,module,exports){
exports.KevoreeEntity       = require('./lib/KevoreeEntity');
exports.AbstractGroup       = require('./lib/AbstractGroup');
exports.AbstractChannel     = require('./lib/AbstractChannel');
exports.AbstractNode        = require('./lib/AbstractNode');
exports.AdaptationPrimitive = require('./lib/AdaptationPrimitive');
exports.AbstractComponent   = require('./lib/AbstractComponent');
exports.Port                = require('./lib/Port');
},{"./lib/AbstractChannel":36,"./lib/AbstractComponent":37,"./lib/AbstractGroup":38,"./lib/AbstractNode":39,"./lib/AdaptationPrimitive":40,"./lib/KevoreeEntity":42,"./lib/Port":44}],36:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractChannel entity
 *
 * @class
 */
var AbstractChannel = KevoreeEntity.extend({
    toString: 'AbstractChannel',

    /**
     * @constructs
     */
    construct: function () {
        this.inputs = {};
    },

    /**
     * @param {String} outputPath
     * @param {String} msg
     * @param {Function} callback
     */
    internalSend: function (outputPath, msg, callback) {
        var paths = [];
        for (var inputPath in this.inputs) {
            if (this.inputs.hasOwnProperty(inputPath)) {
                // do not send message to stopped component
                var model = this.getKevoreeCore().getCurrentModel();
                if (model) {
                    var port = model.findByPath(inputPath);
                    if (port) {
                        var comp = port.eContainer();
                        if (comp && comp.started) {
                            paths.push(inputPath);
                        }
                    }
                }
            }
        }

        if (this.started) {
            this.onSend(outputPath, paths, msg, callback);
        }
    },

    /**
     *
     * @param {String} fromPortPath
     * @param {Array} destPortPaths Array
     * @param {String} msg
     * @param {Function} callback
     *
     * @abstract
     */
    onSend: function (fromPortPath, destPortPaths, msg, callback) {},

    /**
     * Dispatch messages to all bound ports
     * @param msg
     * @param {Function} [callback]
     */
    localDispatch: function (msg, callback) {
        // javascript trick to convert msg to an array if it isn't already one
        msg = [].concat(msg);

        // if no callback given, then prevent exception to be thrown
        callback = callback || function () {};

        for (var path in this.inputs) {
            if (this.inputs.hasOwnProperty(path)) {
                var port = this.inputs[path];
                var comp = port.getComponent();
                if (comp !== null && port.getInputPortMethodName() !== null && typeof comp[port.getInputPortMethodName()] === 'function') {
                    if (comp.getModelEntity().started) {
                        // call component's input port function with 'msg' parameter
                        try {
                            var res = comp[port.getInputPortMethodName()].apply(comp, msg);
                            callback(null, res);

                        } catch (err) {
                            var error = new Error('Exception thrown when processing '+comp.getName()+'.'+port.getInputPortMethodName()+'(...) @'+this.getNodeName());
                            error.message += ':\n\t' + err.message;
                            callback(error);
                            this.log.error(this.toString(), error.message);
                        }
                    } else {
                        var errMsg = 'Component '+comp.getName()+'@'+this.getNodeName()+' is stopped. Drop message.';
                        callback(new Error(errMsg));
                        this.log.debug(this.toString(), errMsg);
                    }
                }
            }
        }
    },

    /**
     * Returns this channel output port paths
     * @returns {Array}
     */
    getOutputs: function () {
        var outputs = [];

        var chan = this.getModelEntity();
        if (chan) {
            chan.bindings.array.forEach(function (binding) {
                if (binding.port && binding.port.getRefInParent() === 'required') {
                    if (binding.port.eContainer().eContainer().name === this.getNodeName()) {
                        outputs.push(binding.port.path());
                    }
                }
            }.bind(this));
        }

        return outputs;
    },

    /**
     * Returns this channel input port paths
     * @returns {Array}
     */
    getInputs: function () {
        var inputs = [];

        var chan = this.getModelEntity();
        if (chan) {
            chan.bindings.array.forEach(function (binding) {
                if (binding.port && binding.port.getRefInParent() === 'provided') {
                    if (binding.port.eContainer().eContainer().name === this.getNodeName()) {
                        inputs.push(binding.port.path());
                    }
                }
            }.bind(this));
        }

        return inputs;
    },

    /**
     *
     * @param port
     */
    addInternalInputPort: function (port) {
        this.inputs[port.getPath()] = port;
    },

    /**
     *
     * @param port
     */
    removeInternalInputPort: function (port) {
        delete this.inputs[port.getPath()];
    }
});

module.exports = AbstractChannel;
},{"./KevoreeEntity":42}],37:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity'),
    Port          = require('./Port'),
    KevoreeUI     = require('./KevoreeUI');

/**
 * AbstractComponent entity
 *
 * @class
 */
var AbstractComponent = KevoreeEntity.extend({
    toString: 'AbstractComponent',

    /**
     * @constructs
     */
    construct: function () {
        this.inputs = {};
        this.ui = new KevoreeUI(this);
    },

    __start__: function (done) {
        this.ui.name = this.name;
        this._super(done);
    },

    __stop__: function (done) {
        if (this.ui.isReady()) {
            // there is an UI running for this comp
            // remove it
            this.ui.destroy();
        }
        this._super(done);
    },

    addInternalInputPort: function (port) {
        this.inputs[port.getPath()] = port;
        if (typeof(this[AbstractComponent.IN_PORT+port.getName()]) === 'undefined') {
            throw new Error("Unable to find provided port '"+AbstractComponent.IN_PORT+port.getName()+"' (Function defined in class?)");
        } else port.setInputPortMethodName(AbstractComponent.IN_PORT+port.getName());
    },

    addInternalOutputPort: function (port) {
        this[AbstractComponent.OUT_PORT+port.getName()] = function (msg, callback) {
            port.processSend(msg, callback);
        };
    },

    removeInternalInputPort: function (port) {
        delete this.inputs[port.getPath()];
    },

    removeInternalOutputPort: function (port) {
        this[AbstractComponent.OUT_PORT+port.getName()] = function () {}; // reset function binding to an empty one
    },

    /**
     *
     * @param content
     * @param callback function(err) if 'err' is defined then something went wrong. Using 'this' in this callback refers
     * to the current component instance
     */
    setUIContent: function (content, callback) {
        callback = callback.bind(this) || function () {};
        var self = this;

        if (this.ui.isReady()) {
            this.ui.setContent(content);
            return callback(null, this.ui.getRoot());

        } else {
            this.ui.initialize(this, this.kCore.getUICommand(), function (err) {
                if (err) return callback(err);

                self.ui.setContent(content);
                return callback(null, self.ui.getRoot());
            });
        }
    },

    getUIRoot: function () {
        return this.ui.getRoot();
    }
});

AbstractComponent.IN_PORT = 'in_';
AbstractComponent.OUT_PORT = 'out_';

module.exports = AbstractComponent;
},{"./KevoreeEntity":42,"./KevoreeUI":43,"./Port":44}],38:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractGroup entity
 *
 * @class
 */
var AbstractGroup = KevoreeEntity.extend({
  toString: 'AbstractGroup',

  /**
   *
   * @param model
   */
  updateModel: function (model) {
    this.kCore.deploy(model);
  }
});

module.exports = AbstractGroup;
},{"./KevoreeEntity":42}],39:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractNode entity
 *
 * @class
 */
var AbstractNode = KevoreeEntity.extend({
    toString: 'AbstractNode',

    /**
     * Compute a list of traces and return an ordered list of AdaptationPrimitive to execute in order to proceed
     * to the adaptation of the platform
     * @param {Object} diffSeq      Kotlin.List of diff traces generated by comparing current KevoreeCore model and given model
     * @param {Object} targetModel  Kevoree ContainerModel model object
     *                              that was used by KevoreeCore to generate the diffSeq traces against currentModel
     * @returns {Array}
     */
    processTraces: function (diffSeq, targetModel) {
        return [];
    },

    /**
     * Called when the host node has to start an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    startSubNode: function (node, done) {
        done();
    },

    /**
     * Called when the host node has to stop an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    stopSubNode: function (node, done) {
        done();
    },

    /**
     * Called when the host node has to remove an hosted subNode instance
     * @param node the hosted subNode
     * @param done
     */
    removeSubNode: function (node, done) {
        done();
    }
});

module.exports = AbstractNode;
},{"./KevoreeEntity":42}],40:[function(require,module,exports){
var Class   = require('pseudoclass');

/**
 * Abstract AdaptationPrimitive command
 *
 * @class
 */
var AdaptationPrimitive = Class({
    toString: 'AdaptationPrimitive',

    /**
     * Construct an AdaptationPrimitive object
     *
     * @param node AbstractNode platform
     * @param mapper ModelObjectMapper
     * @param model model to deploy (that triggers adaptations)
     * @param modelElement model element linked with this primitive
     *
     * @constructs
     */
    construct: function (node, mapper, model, modelElement) {
        this.node = node;
        this.mapper = mapper;
        this.adaptModel = model;
        this.modelElement = modelElement;
        this.log = this.node.getKevoreeCore().getLogger();
    },

    /**
     * Executes adaptation primitive logics
     * @param callback Function(err, [args]) if 'err' is defined => something went wrong
     */
    execute: function (callback) {
        if (typeof (callback) !== 'function') {
            throw new Error("Execute method need a callback function as last parameter");
        }
    },

    /**
     * Undo the process done by execute()
     */
    undo: function (callback) {
        if (typeof (callback) !== 'function') {
            throw new Error("Undo method need a callback function as last parameter");
        }
    }
});

module.exports = AdaptationPrimitive;
},{"pseudoclass":112}],41:[function(require,module,exports){
var Class           = require('pseudoclass'),
    kevoree         = require('kevoree-library').org.kevoree,
    EventEmitter    = require('events').EventEmitter;

var factory = new kevoree.factory.DefaultKevoreeFactory();

/**
 * Dictionary class use to handle KevoreeEntities dictionary attributes
 * <br/>
 * Each KevoreeEntity can create a dictionary attribute by adding a new <strong>dic_field</strong> to their class:
 * <br/>
 * <pre>
 * dic_myAttr: {
 *   optional: true,
 *   defaultValue: 'foo',
 *   fragmentDependant: false
 * }
 * </pre>
 * Dictionary attribute API follows those guidelines:
 * <ul>
 *   <li>"defaultValue" attribute is <b>optional</b>, type is <b>string|boolean</b></li>
 *   <li>"optional" attribute is <b>optional</b>, type is <b>boolean</b> (default: true)</li>
 *   <li>"fragmentDependant" attribute is <b>optional</b>, type is <b>boolean</b> (default: false)</li>
 *   <li>"datatype" attribute is <b>optional</b>, type is <b>string|org.kevoree.Datatype</b></li>
 * </ul>
 *
 * Once your entity is started, you will be able to retrieve your attribute value by calling one of those methods:
 * <ul>
 *     <li>this.dictionary.getValue('myAttr')</li>
 *     <li>this.dictionary.getString('myAttr')</li>
 *     <li>this.dictionary.getNumber('myAttr')</li>
 *     <li>this.dictionary.getBoolean('myAttr')</li>
 * </ul>
 *
 * @class
 */
var Dictionary = Class({
    toString: 'Dictionary',

    /**
     * @param entity
     *
     * @constructs
     */
    construct: function (entity) {
        this.entity = entity;
        this.emitter = new EventEmitter();
        this.map = {};
    },

    /**
     * Adds a listener on dictionary changes or on a particular attribute changes
     * dictionary.on('myAttr', function (newVal, oldVal) { ... });
     *
     * @param attrName name of the attribute you want to add a listener on
     * @param callback function (attrNewValue, attrOldValue)
     */
    on: function (attrName, callback) {
        this.emitter.addListener(attrName, callback.bind(this.entity));
    },

    /**
     * Removes a listener
     * @param event
     * @param callback
     */
    off: function (event, callback) {
        this.emitter.removeListener(event, callback);
    },

    /**
     * Retrieve a value mapped by the key "name"
     * @param {String} name the key
     * @returns {*}
     */
    getValue: function (name) {
        return this.map[name];
    },

    /**
     * Returns a boolean for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "false"
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default boolean to return if no value is found in the dictionary using the given name
     * @returns {Boolean}
     */
    getBoolean: function (name, defaultVal) {
        var val = this.map[name];
        if (val === 'true' || val === 'false') {
            return val === 'true';
        }

        if (typeof (defaultVal) === 'undefined') {
            defaultVal = false;
        }

        return defaultVal;
    },

    /**
     * Returns a string for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "null"
     * (nb: it will also return "null" if the given defaultVal is not a string)
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default string to return if no value is found in the dictionary using the given name
     * @returns {String}
     */
    getString: function (name, defaultVal) {
        var val = this.map[name];

        if (typeof (val) === 'string') {
            return val;
        }

        if (typeof (defaultVal) !== 'string') {
            defaultVal = null;
        }

        return defaultVal;
    },

    /**
     * Returns a number for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "null"
     * (nb: it will also return "null" if the given defaultVal is not a number)
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default number to return if no value is found in the dictionary using the given name
     * @returns {Number}
     */
    getNumber: function (name, defaultVal) {
        var val = this.map[name];

        if (!isNaN(Number(val))) {
            return val;
        }

        if (typeof (defaultVal) !== 'number') {
            defaultVal = null;
        }

        return defaultVal;
    },

    /**
     *
     * @param name
     * @param value
     */
    setValue: function (name, value) {
        var entity = this.entity.getModelEntity();
        if (!entity.dictionary) {
            entity.dictionary = factory.createDictionary();
        }
        value = entity.dictionary.findValuesByID(name);
        if (!value) {
            value = factory.createDictionaryValue();
            value.name = name;
            entity.dictionary.addValues(value);
        }
        value.value = value;
        this.setEntry(name, value);
    },

    /**
     * Called by the platform to update the state of the dictionary
     * Triggers a call to dic_<name>.update() and a call to on(<name>, function)
     * @param name attribute name
     * @param value new attribute value
     */
    setEntry: function (name, value) {
        var oldValue = this.map[name];
        this.map[name] = value;
        // emit update event with the name, oldValue and newValue
        if (this.entity.isStarted()) {
            if (this.entity['dic_'+name].update && (typeof this.entity['dic_'+name].update === 'function')) {
                this.entity['dic_'+name].update.bind(this.entity)(value, oldValue);
            }
            this.emitter.emit(name, value, oldValue);
        }
    },

    /**
     *
     * @param map
     */
    setMap: function (map) {
        var name;
        if (Object.keys(this.map).length > 0) {
            // current map is not empty
            for (var newName in map) {
                var alreadyAdded = false;

                for (name in this.map) {
                    if (newName == name) {
                        // oldMap and newMap both have this attribute : update needed ?
                        var oldValue = this.map[name];
                        if (oldValue != map[name]) {
                            // map[name] value is different from current value => update
                            this.map[name] = map[name];
                            this.emitter.emit(name, this.map[name], oldValue);
                        }
                        alreadyAdded = true;
                    }
                }

                if (!alreadyAdded) {
                    // newMap has a new attribute to add to currentMap : ADD event
                    this.map[newName] = map[newName];
                }
            }

        } else {
            // dictionary was empty : set it from scratch
            this.map = map;
        }
    },

    /**
     *
     * @returns {{}|*}
     */
    getMap: function () {
        return this.map;
    },

    /**
     * Returns this dictionary current cloned map
     * @returns {{}}
     */
    cloneMap: function () {
        var clonedMap = {};
        for (var name in this.map) {
            clonedMap[name] = this.map[name];
        }
        return clonedMap;
    }
});

module.exports = Dictionary;
},{"events":6,"kevoree-library":109,"pseudoclass":112}],42:[function(require,module,exports){
var Class       = require('pseudoclass'),
    Dictionary  = require('./Dictionary'),
    KevScript   = require('kevoree-kevscript');

/**
 * Abstract class: KevoreeEntity
 * <br/>
 * You are not supposed to instantiate this class manually. It makes no sense
 * <br/>
 * You should create your own Kevoree entity that extend one of the defined abstraction type:
 * <ul>
 *     <li>AbstractNode</li>
 *     <li>AbstractGroup</li>
 *     <li>AbstractChannel</li>
 *     <li>AbstractComponent</li>
 * </ul>
 * All this sub-classes extend KevoreeEntity in order to have the same basic prototype
 *
 * @class
 */
var KevoreeEntity = Class({
    toString: 'KevoreeEntity',

    /**
     * @constructs
     */
    construct: function () {
        this.kCore = null;
        this.dictionary = new Dictionary(this);
        this.name = null;
        this.path = null;
        this.nodeName = null;
        this.started = false;
        this.queue = [];
    },

    /**
     * Called when an entity has to start
     * @param done
     */
    start: function (done) {
        done();
    },

    /**
     * Called when an entity has to stop
     * @param done
     */
    stop: function (done) {
        done();
    },

    /**
     * Called when a attribute has been changed (this method is called after all attribute-specific update() method)
     * @param done
     */
    update: function (done) {
        done();
    },

    __start__: function (done) {
        this.log = this.kCore.getLogger();
        this.started = true;
        this.start(done);
    },

    __stop__: function (done) {
        this.started = false;
        this.stop(done);
    },

    __update__: function (done) {
        this.update(done);
    },

    setKevoreeCore: function (kCore) {
        this.kCore = kCore;
    },

    /**
     *
     * @returns {Object}
     */
    getKevoreeCore: function () {
        return this.kCore;
    },

    getDictionary: function () {
        return this.dictionary;
    },

    getName: function () {
        return this.name;
    },

    getNodeName: function () {
        return this.nodeName;
    },

    setName: function (name) {
        this.name = name;
    },

    setPath: function (path) {
        this.path = path;
    },

    getPath: function () {
        return this.path;
    },

    setNodeName: function (name) {
        this.nodeName = name;
    },

    /**
     * Tries to retrieve this Kevoree entity from deployModel first.
     * If deployModel is null (meaning that we are in a deployed-state and not in a deploying-state)
     * it tries to retrieve this Kevoree entity from currentModel.
     * @returns {*}
     */
    getModelEntity: function () {
        var model = this.kCore.getDeployModel();
        if (!model) {
            model = this.kCore.getCurrentModel();
        }
        return model.findByPath(this.path);
    },

    getNetworkInfos: function (nodeName) {
        var model = this.kCore.getDeployModel();
        if (!model) {
            this.kCore.getCurrentModel();
        }
        var node = model.findNodesByID(nodeName);
        if (node) {
            return node.networkInformation.iterator();
        } else {
            return null;
        }
    },

    isStarted: function () {
        return this.started;
    },

    /**
     * Executes script with current model context. If callback parameter is set,
     * it means something went wrong and the parameter is the error object.
     * NB: scripts submitted while in "deploying" state are queued and executed after.
     * @param script KevScript string
     * @param [callback] function (err)
     */
    submitScript: function (script, callback) {
        callback = callback || function () {};

        if (this.kCore.getDeployModel() === null) {
            // not in "deploying state"
            var kevs = new KevScript({
                resolvers: { npm: this.kCore.getBootstrapper().resolver } // refactor according to #26
            });
            kevs.parse(script, this.kCore.getCurrentModel(), function (err, model) {
                if (err) {
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                    return;
                }

                var deployHandler, errHandler, adaptHandler;
                deployHandler = function () {
                    this.kCore.off('error', errHandler);
                    this.kCore.off('adaptationError', adaptHandler);
                    callback();
                }.bind(this);
                errHandler = function (err) {
                    this.kCore.off('deployed', deployHandler);
                    this.kCore.off('adaptationError', adaptHandler);
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                }.bind(this);
                adaptHandler = function (err) {
                    this.kCore.off('error', errHandler);
                    this.kCore.off('deployed', deployHandler);
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                }.bind(this);

                this.kCore.once('deployed', deployHandler);
                this.kCore.once('error', errHandler);
                this.kCore.once('adaptationError', adaptHandler);

                this.kCore.deploy(model);
            }.bind(this));
        } else {
            // in "deploying state" => need to queue request to process it afterwards
            this.queue.push({script: script, callback: callback});
            this.log.debug(this.toString(), 'Script added to queue..');
            //callback(new Error('KevScript submission failed (unable to submit script when a model is currently deployed)'));
        }
    },

    /**
     * Called when a model has been successfully deployed
     */
    onModelDeployed: function () {
        if (this.queue.length > 0) {
            // create a KevScript engine
            var kevs = new KevScript();

            // retrieve first queued script
            var item = this.queue[0];
            // remove first queued script from the queue
            this.queue.splice(0, 1);
            // execute first queued script
            kevs.parse(item.script, this.kCore.getCurrentModel(), function (err, model) {
                if (err) {
                    // queued script submission failed
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    item.callback(e);

                } else {
                    // queued script submission succeed
                    var deployHandler, errHandler, adaptHandler;
                    deployHandler = function () {
                        this.kCore.off('error', errHandler);
                        this.kCore.off('adaptationError', adaptHandler);
                        item.callback();
                    }.bind(this);
                    errHandler = function (err) {
                        this.kCore.off('deployed', deployHandler);
                        this.kCore.off('adaptationError', adaptHandler);
                        var e = new Error('KevScript submission failed ('+err.message+')');
                        item.callback(e);
                    }.bind(this);
                    adaptHandler = function (err) {
                        this.kCore.off('error', errHandler);
                        this.kCore.off('deployed', deployHandler);
                        var e = new Error('KevScript submission failed ('+err.message+')');
                        item.callback(e);
                    }.bind(this);

                    this.kCore.once('deployed', deployHandler);
                    this.kCore.once('error', errHandler);
                    this.kCore.once('adaptationError', adaptHandler);

                    this.kCore.deploy(model);
                }
            }.bind(this));
        }
    }
});

KevoreeEntity.DIC = 'dic_';
module.exports = KevoreeEntity;
},{"./Dictionary":41,"kevoree-kevscript":54,"pseudoclass":112}],43:[function(require,module,exports){
var Class         = require('pseudoclass'),
    KevoreeLogger = require('kevoree-commons').KevoreeLogger,
    EventEmitter  = require('events').EventEmitter;

/**
 * KevoreeUI
 *
 * @class
 */
var KevoreeUI = Class({
    toString: 'KevoreeUI',

    /**
     * @param comp
     * @constructs
     */
    construct: function (comp) {
        this.comp = comp;
        this.root = null;
        this.log = new KevoreeLogger(this.toString());
        this.name = null;
        this.destroyCmd = null;
        this.emitter = new EventEmitter();
    },

    isReady: function () {
        return (this.root != null);
    },

    setRoot: function (root) {
        this.root = root;
    },

    getRoot: function () {
        return this.root;
    },

    initialize: function (comp, initCmd, callback) {
        var self = this;

        if (typeof(initCmd) !== 'function' || !initCmd) {
            return callback(new Error('KevoreeUI init command unset (or not a function) in KevoreeCore.'));
        }

        initCmd(this, function (err) {
            if (err) {
                self.log.error(err.message);
                self.root = null;
                return callback(err);
            }

            return callback();
        });
    },

    setContent: function (content) {
        this.root.innerHTML = content;
        this.emitter.emit('contentChanged', content);
    },

    destroy: function () {
        if (this.destroyCmd) this.destroyCmd();
        this.root = null;
    },

    setDestroyCmd: function (cmd) {
        this.destroyCmd = cmd;
    },

    getName: function () {
        return this.name;
    },

    setName: function (name) {
        this.name = name;
        this.emitter.emit('nameChanged', name);
    },

    on: function (event, callback) {
        this.emitter.addListener(event, callback);
    }
});

module.exports = KevoreeUI;
},{"events":6,"kevoree-commons":45,"pseudoclass":112}],44:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Port
 * You are not supposed to create Port object (unless you are an AdaptationPrimitive)
 *
 * @class
 */
var Port = Class({
    toString: 'Port',

    /**
     *
     * @param name
     * @param path
     *
     * @constructs
     */
    construct: function (name, path) {
        this.name                = name;
        this.path                = path;
        this.component           = null;
        this.channel             = null;
        this.inputPortMethodName = null;
    },

    processSend: function (msg, callback) {
        this.channel.internalSend(this.path, msg, callback);
    },

    setInputPortMethodName: function (name) {
        this.inputPortMethodName = name;
    },

    getInputPortMethodName: function () {
        return this.inputPortMethodName;
    },

    getName: function () {
        return this.name;
    },

    getPath: function () {
        return this.path;
    },

    setComponent: function (comp) {
        this.component = comp;
    },

    getComponent: function () {
        return this.component;
    },

    setChannel: function (chan) {
        this.channel = chan;
    }
});

module.exports = Port;
},{"pseudoclass":112}],45:[function(require,module,exports){
module.exports.Resolver      = require('./lib/Resolver');
module.exports.Bootstrapper  = require('./lib/Bootstrapper');
module.exports.KevoreeLogger = require('./lib/KevoreeLogger');
module.exports.FileSystem    = require('./lib/FileSystem');
},{"./lib/Bootstrapper":46,"./lib/FileSystem":47,"./lib/KevoreeLogger":48,"./lib/Resolver":49}],46:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Bootstrapper API
 * @type {Bootstrapper}
 */
var Bootstrapper = Class({
    toString: 'Bootstrapper',

    /**
     *
     * @param {KevoreeLogger} logger
     * @param {Resolver} resolver
     */
    construct: function (logger, resolver) {
        if (logger) {
            this.log = logger;
            if (resolver) {
                this.resolver = resolver;
            } else {
                throw new Error('No resolver given to '+this.toString()+' (you need to give a proper Resolver to your Bootstrapper)');
            }
        } else {
            throw new Error('No logger given to '+this.toString()+' (you need to give a proper KevoreeLogger to your Bootstrapper)');
        }
    },

    /**
     *
     * @param nodeName
     * @param model
     * @param callback
     */
    bootstrapNodeType: function (nodeName, model, callback) {
        callback = callback || function () {};

        var node = model.findNodesByID(nodeName);
        if (node) {
            var meta = node.typeDefinition.select('deployUnits[name=*]/filters[name=platform,value=javascript]');
            if (meta.size() > 0) {
                this.bootstrap(meta.get(0).eContainer(), false, callback);
            } else {
                callback(new Error("No DeployUnit found for '"+nodeName+"' that matches the 'javascript' platform"));
            }
        } else {
            return callback(new Error("Unable to find '"+nodeName+"' in the given model."));
        }
    },

    /**
     *
     * @param deployUnit
     * @param forceInstall [optional] boolean to indicate whether or not we should force re-installation
     * @param callback                function(Error, Clazz, ContainerRoot)
     */
    bootstrap: function (deployUnit, forceInstall, callback) {
        if (!callback) {
            // "forceInstall" parameter is not specified (optional)
            callback = forceInstall;
            forceInstall = false;
        }

        // --- Resolvers callback
        var bootstrapper = this;
        this.resolver.resolve(deployUnit, forceInstall, function (err, EntityClass, model) {
            if (err) {
                bootstrapper.log.error(bootstrapper.toString(), err.stack);
                return callback(new Error("'"+deployUnit.name+"' bootstrap failed!"));
            }

            // install success
            callback(null, EntityClass, model);
        });
    },

    /**
     *
     * @param deployUnit
     * @param callback
     */
    uninstall: function (deployUnit, callback) {
        var bootstrapper = this;
        this.resolver.uninstall(deployUnit, function (err) {
            if (err) {
                bootstrapper.log.error(bootstrapper.toString(), err.stack);
                callback(new Error("'"+deployUnit.name+"' uninstall failed!"));
                return;
            }

            // uninstall success
            callback(null);
        });
    }
});

module.exports = Bootstrapper;
},{"pseudoclass":112}],47:[function(require,module,exports){
var Class = require('pseudoclass');

var FileSystem = Class({
    toString: 'FileSystem',

    getFileSystem: function (size, callback) {
        if (document) {
            getBrowserFileSystem(this, size, callback);
        } else {
            console.error('Kevoree FileSystem API only handles Browser FS for now.');
        }
    }
});

var getBrowserFileSystem = function getBrowserFileSystem(fsapi, size, callback) {
    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    navigator.persistentStorage = navigator.persistentStorage || navigator.webkitPersistentStorage;

    if (window.requestFileSystem && navigator.persistentStorage) {

        var successHandler = function successHandler(grantedSize) {
            window.requestFileSystem(window.PERSISTENT, grantedSize, function (fs) {
                callback.call(fsapi, null, fs);
            });
        };

        var errorHandler = function errorHandler(e) {
            callback.call(fsapi, null);
        };

        navigator.persistentStorage.requestQuota(size, successHandler, errorHandler);
    }
};

module.exports = FileSystem;
},{"pseudoclass":112}],48:[function(require,module,exports){
var Class  = require('pseudoclass'),
    chalk  = require('chalk');

var LEVELS = ['all', 'debug', 'info', 'warn', 'error', 'quiet'];

var chalkInfo       = chalk.grey,
    chalkWarn       = chalk.grey.bgYellow,
    chalkWarnMsg    = chalk.yellow,
    chalkError      = chalk.white.bgRed,
    chalkErrorMsg   = chalk.red,
    chalkDebug      = chalk.cyan;

var KevoreeLogger = Class({
    toString: 'KevoreeLogger',

    construct: function (tag) {
        this.tag = tag;
        this.level = 2;
        this.filter = '';
    },

    info: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('info')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.log(getTime()+'  '+chalkInfo('INFO')+'   '+processTag(tag)+'  '+chalkInfo(msg));
            }
        }
    },

    debug: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('debug')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.log(getTime()+'  '+chalkDebug('DEBUG ')+' '+processTag(tag)+'  '+chalkDebug(msg));
            }
        }
    },

    warn: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('warn')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.warn(getTime()+'  '+chalkWarn('WARN')+'   '+processTag(tag)+'  '+chalkWarnMsg(msg));
            }
        }
    },

    error: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('error')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.error(getTime() + '  ' + chalkError('ERROR') + '  ' + processTag(tag) + '  ' + chalkErrorMsg(msg));
            }
        }
    },

    setLevel: function (level) {
        this.level = level;
        console.log(getTime()+'  '+chalkInfo('ALL ')+'   '+processTag(this.toString())+'  '+chalkInfo('Set logLevel= '+LEVELS[this.level]));
    },

    setFilter: function (filter) {
        this.filter = filter;
        console.log(getTime()+'  '+chalkInfo('ALL ')+'   '+processTag(this.toString())+'  '+chalkInfo('Set logFilter= "'+this.filter+'"'));
    }
});

var processTag = function processTag(tag) {
    if (tag.length >= 15) {
        tag = tag.substr(0, 14)+'.';
    } else {
        var spaces = '';
        for (var i=0; i < 15 - tag.length; i++) spaces += ' ';
        tag += spaces;
    }

    return chalk.magenta(tag);
};

var getTime = function getTime() {
    var time = new Date();
    var hours = (time.getHours().toString().length == 1) ? '0'+time.getHours() : time.getHours();
    var mins = (time.getMinutes().toString().length == 1) ? '0'+time.getMinutes() : time.getMinutes();
    var secs = (time.getSeconds().toString().length == 1) ? '0'+time.getSeconds() : time.getSeconds();
    return chalk.grey(hours+':'+mins+':'+secs);
};


KevoreeLogger.ALL   = LEVELS.indexOf('all');
KevoreeLogger.INFO  = LEVELS.indexOf('info');
KevoreeLogger.DEBUG = LEVELS.indexOf('debug');
KevoreeLogger.WARN  = LEVELS.indexOf('warn');
KevoreeLogger.ERROR = LEVELS.indexOf('error');
KevoreeLogger.QUIET = LEVELS.indexOf('quiet');

module.exports = KevoreeLogger;
},{"chalk":50,"pseudoclass":112}],49:[function(require,module,exports){
var Class = require('pseudoclass'),
    KevoreeLogger = require('./KevoreeLogger');

/**
 * Resolver API
 * @type {Resolver}
 */
var Resolver = Class({
    toString: 'Resolver',

    construct: function (modulesPath, logger) {
        this.modulesPath = modulesPath || '';
        this.log = logger || new KevoreeLogger(this.toString());
        this.repositories = [];
    },

    /**
     *
     * @param deployUnit Kevoree DeployUnit
     * @param force [optional] boolean that indicates whether or not we should force re-installation no matter what
     * @param callback function(err, Class, model)
     */
    resolve: function (deployUnit, force, callback) {},

    uninstall: function (deployUnit, force, callback) {},

    addRepository: function (url) {
        if (this.repositories.indexOf(url) === -1) this.repositories.push(url);
    }
});

module.exports = Resolver;
},{"./KevoreeLogger":48,"pseudoclass":112}],50:[function(require,module,exports){
'use strict';
var ansi = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasColor = require('has-color');
var defineProps = Object.defineProperties;
var chalk = module.exports;

var styles = (function () {
	var ret = {};

	ansi.grey = ansi.gray;

	Object.keys(ansi).forEach(function (key) {
		ret[key] = {
			get: function () {
				this._styles.push(key);
				return this;
			}
		};
	});

	return ret;
})();

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				var obj = defineProps(function self() {
					var str = [].slice.call(arguments).join(' ');

					if (!chalk.enabled) {
						return str;
					}

					return self._styles.reduce(function (str, name) {
						var code = ansi[name];
						return str ? code.open + str + code.close : '';
					}, str);
				}, styles);

				obj._styles = [];

				return obj[name];
			}
		}
	});

	return ret;
}

defineProps(chalk, init());

chalk.styles = ansi;
chalk.stripColor = stripAnsi;
chalk.supportsColor = hasColor;

// detect mode if not set manually
if (chalk.enabled === undefined) {
	chalk.enabled = chalk.supportsColor;
}

},{"ansi-styles":51,"has-color":52,"strip-ansi":53}],51:[function(require,module,exports){
'use strict';
var styles = module.exports;

var codes = {
	reset: [0, 0],

	bold: [1, 22],
	italic: [3, 23],
	underline: [4, 24],
	inverse: [7, 27],
	strikethrough: [9, 29],

	black: [30, 39],
	red: [31, 39],
	green: [32, 39],
	yellow: [33, 39],
	blue: [34, 39],
	magenta: [35, 39],
	cyan: [36, 39],
	white: [37, 39],
	gray: [90, 39],

	bgBlack: [40, 49],
	bgRed: [41, 49],
	bgGreen: [42, 49],
	bgYellow: [43, 49],
	bgBlue: [44, 49],
	bgMagenta: [45, 49],
	bgCyan: [46, 49],
	bgWhite: [47, 49]
};

Object.keys(codes).forEach(function (key) {
	var val = codes[key];
	var style = styles[key] = {};
	style.open = '\x1b[' + val[0] + 'm';
	style.close = '\x1b[' + val[1] + 'm';
});

},{}],52:[function(require,module,exports){
(function (process){
'use strict';
module.exports = (function () {
	if (process.argv.indexOf('--no-color') !== -1) {
		return false;
	}

	if (process.argv.indexOf('--color') !== -1) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))
},{"_process":14}],53:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return typeof str === 'string' ? str.replace(/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g, '') : str;
};

},{}],54:[function(require,module,exports){
var Class       = require('pseudoclass'),
    kevs        = require('./parser'),
    interpreter = require('./interpreter'),
    modelInterpreter = require('./model-interpreter');

var KevScript = Class({
    toString: 'KevScript',

    /**
     * Parses given KevScript source-code in parameter 'data' and returns a ContainerRoot.
     * @param {String} data string
     * @param {Object|Function} [ctxModel] a model to "start" on (in order not to create a model from scratch)
     * @param {Function} callback function (Error, ContainerRoot)
     * @throws Error on SyntaxError and on source code validity and such
     */
    parse: function (data, ctxModel, callback) {
        if (typeof(callback) === 'undefined') {
            callback = ctxModel;
            ctxModel = null;
        }

        var parser = new kevs.Parser();
        var ast = parser.parse(data);
        if (ast.type != 'kevScript') {
            callback(new Error(ast.toString()));
        } else {
            interpreter(ast, ctxModel, callback);
        }
    },

    /**
     * Parses a Kevoree model (ContainerRoot) and returns the equivalent KevScript string
     * @param model kevoree ContainerRoot model
     */
    parseModel: function (model) {
        return modelInterpreter(model);
    }
});

module.exports = KevScript;
},{"./interpreter":65,"./model-interpreter":67,"./parser":68,"pseudoclass":112}],55:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var grps = model.groups.iterator();

    var str = '';
    while (grps.hasNext()) {
        var grp = grps.next();
        if (grp.subNodes.size() > 0) {
            if (str.length !== 0) {
                str += '\n';
            }

            str += 'attach ';

            var subNodes = grp.subNodes.iterator();
            while (subNodes.hasNext()) {
                var subNode = subNodes.next();
                str += subNode.name;
                if (subNodes.hasNext()) {
                    str += ', ';
                }
            }

            str += ' '+grp.name;
        }
    }

    return str;
};
},{}],56:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var bindings = model.mBindings.iterator();

    var str = '';
    while (bindings.hasNext()) {
        var binding = bindings.next();
        if (str.length !== 0) {
            str += '\n';
        }

        str += 'bind ' +
            binding.port.eContainer().eContainer().name + '.' +
            binding.port.eContainer().name + '.' +
            binding.port.name + ' ' +
            binding.hub.name;
    }

    return str;
};
},{}],57:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var tdefs = model.typeDefinitions.iterator();
    var str = '';
    while (tdefs.hasNext()) {
        var du = tdefs.next().deployUnit;
        var type = 'mvn';
        if (du.type === 'npm') {
            type = 'npm';
        }

        var def = '';
        if (du.groupName) {
            def += du.groupName+':';
        }
        def += du.name+':';
        def += du.version;

        if (str.indexOf(def) === -1) {
            if (str.length !== 0) {
                str += '\n';
            }
            str += 'include '+type+':'+def;
        }
    }

    return str;
};
},{}],58:[function(require,module,exports){
var getFQN = require('../getFQN');

/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var str = '';

    function process(elems) {
        var map = {};
        while (elems.hasNext()) {
            var elem = elems.next();
            var fqn = getFQN(elem.typeDefinition);
            var list = map[fqn] || [];
            list.push(elem.name);
            map[fqn] = list;
        }

        for (var tdef in map) {
            if (map.hasOwnProperty(tdef)) {
                if (str.length !== 0) {
                    str += '\n';
                }
                str += 'add '+map[tdef].join(', ')+' : '+tdef;
            }
        }
    }

    function processRootNodes(elems) {
        var map = {};
        while (elems.hasNext()) {
            var elem = elems.next();
            var fqn = getFQN(elem.typeDefinition);
            var list = map[fqn] || [];

            if (!elem.host) {
                list.push(elem.name);
            }

            map[fqn] = list;
        }

        for (var tdef in map) {
            if (map.hasOwnProperty(tdef)) {
                if (map[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+map[tdef].join(', ')+' : '+tdef;
                }
            }
        }
    }

    function processHostedNodesAndComps(elems) {
        var compsMap = {};
        var subnodesMap = {};
        var list;
        while (elems.hasNext()) {
            var elem = elems.next(), fqn;

            if (elem.host) {
                // elem is a subNode
                fqn = getFQN(elem.typeDefinition);
                list = subnodesMap[fqn] || [];
                list.push(elem.host.name+'.'+elem.name);
                subnodesMap[fqn] = list;
            }

            var comps = elem.components.iterator();
            while (comps.hasNext()) {
                var comp = comps.next();
                fqn = getFQN(comp.typeDefinition);
                list = compsMap[fqn] || [];
                list.push(elem.name+'.'+comp.name);
                compsMap[fqn] = list;
            }
        }

        var tdef;
        for (tdef in compsMap) {
            if (compsMap.hasOwnProperty(tdef)) {
                if (compsMap[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+compsMap[tdef].join(', ')+' : '+tdef;
                }
            }
        }

        for (tdef in subnodesMap) {
            if (subnodesMap.hasOwnProperty(tdef)) {
                if (subnodesMap[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+subnodesMap[tdef].join(', ')+' : '+tdef;
                }
            }
        }
    }

    processRootNodes(model.nodes.iterator());
    processHostedNodesAndComps(model.nodes.iterator());
    process(model.groups.iterator());
    process(model.hubs.iterator());

    return str.replace(/org\.kevoree\.library\./g, '');
};
},{"../getFQN":63}],59:[function(require,module,exports){
/**
 * Created by leiko on 20/06/14.
 */
module.exports = function (model) {
    var str = '';
    var toStop = [];

    function addElems(instances, host) {
        while (instances.hasNext()) {
            var instance = instances.next();
            if (!instance.started) {
                // instance is stopped => add to toStop array
                if (host) {
                    toStop.push(host.name+'.'+instance.name);
                } else {
                    toStop.push(instance.name);
                }
            }

            // if instance has components => check for their state too
            if (instance.components) {
                addElems(instance.components.iterator(), instance);
            }
            // if instance has hosts => check for their state too
            if (instance.hosts) {
                addElems(instance.hosts.iterator(), instance);
            }
        }
    }

    addElems(model.nodes.iterator());
    addElems(model.groups.iterator());
    addElems(model.hubs.iterator());

    // generate statement
    if (toStop.length > 0) {
        str = 'stop ' + toStop.join(', ');
    }

    return str;
};
},{}],60:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var str = '';

    var nodes = model.nodes.iterator();
    while (nodes.hasNext()) {
        var node = nodes.next();
        var nets = node.networkInformation.iterator();
        while (nets.hasNext()) {
            var net = nets.next();
            var values = net.values.iterator();
            while (values.hasNext()) {
                var val = values.next();
                if (str.length !== 0) {
                    str += '\n';
                }

                str += 'network '+node.name+'.'+net.name+'.'+val.name+' '+val.value;
            }
        }
    }

    return str;
};
},{}],61:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 * @param model
 * @returns {string}
 */
module.exports = function (model) {
    var str = '';

    var repos = model.repositories.iterator();
    while (repos.hasNext()) {
        var repo = repos.next();
        if (str.length !== 0) {
            str += '\n';
        }
        str += 'repo "'+repo.url+'"';
    }

    return str;
};
},{}],62:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
function lexValue(value) {
    if (value) {
        var escaped = false;
        for (var i=0; i < value.length; i++) {
            if (value[i] === '"' && !escaped) {
                return '\''+value+'\'';
            }

            if (value[i] === '\'' && !escaped) {
                return '"'+value+'"';
            }

            escaped = (value[i] === '\\');
        }
        return '\''+value+'\'';
    } else {
        return '\'\'';
    }
}

module.exports = function (model) {
    var str = '';

    function processDictionary(instanceName, values, fragName, dicType) {
        while (values.hasNext()) {
            var val = values.next();
            var attr = dicType.findAttributesByID(val.name);
            if (attr.defaultValue !== val.value) {
                if (str.length !== 0) {
                    str += '\n';
                }

                if (fragName) {
                    str += 'set '+instanceName+'.'+val.name+'/'+fragName+' = '+lexValue(val.value);
                } else {
                    str += 'set '+instanceName+'.'+val.name+' = '+lexValue(val.value);
                }
            }
        }
    }

    function processInstance(instance, host) {
        var instanceName = (host) ? (host+'.'+instance.name) : (instance.name);

        if (instance.dictionary) {
            processDictionary(instanceName, instance.dictionary.values.iterator(), null, instance.typeDefinition.dictionaryType);
        }

        var fDics = instance.fragmentDictionary.iterator();
        while (fDics.hasNext()) {
            var dic = fDics.next();
            if (dic) {
                processDictionary(instanceName, dic.values.iterator(), dic.name, instance.typeDefinition.dictionaryType);
            }
        }
    }

    var nodes = model.nodes.iterator();
    while (nodes.hasNext()) {
        var node = nodes.next();
        if (!node.host) {
            // only process nodes that are not hosted (hosted nodes will be processed as subNodes later)
            processInstance(node);
        }

        var subNodes = node.hosts.iterator();
        while (subNodes.hasNext()) {
            processInstance(subNodes.next(), node.name);
        }

        var comps = node.components.iterator();
        while (comps.hasNext()) {
            processInstance(comps.next(), node.name);
        }
    }

    var groups = model.groups.iterator();
    while (groups.hasNext()) {
        processInstance(groups.next());
    }

    var hubs = model.hubs.iterator();
    while (hubs.hasNext()) {
        processInstance(hubs.next());
    }

    return str;
};
},{}],63:[function(require,module,exports){
// Created by leiko on 16/09/14 17:18
module.exports = function getFQN(tdef) {
    var fqn = tdef.name+'/'+tdef.version;
    function walk(pkg) {
        if (pkg.eContainer()) {
            fqn = pkg.name + '.' + fqn;
            walk(pkg.eContainer());
        }
    }

    walk(tdef.eContainer());

    return fqn;
};
},{}],64:[function(require,module,exports){
/**
 * Created by leiko on 19/06/14.
 */
module.exports.resolve = function resolve(model, stmt) {
    var instances, i, nodes;

    switch (stmt.type) {
        case 'instancePath':
            var children = [];
            for (i=0; i < stmt.children.length; i++) {
                children.push(stmt.children[i].children.join(''));
            }
            if (children.length < 3) {
                if (children.length === 2) {
                    // instance path with two segments => components or subnodes
                    nodes = [];
                    var subs = [];
                    if (children[0] === '*') {
                        var kNodes = model.nodes.iterator();
                        while (kNodes.hasNext()) {
                            nodes.push(kNodes.next());
                        }
                    } else {
                        var kNode = model.findNodesByID(children[0]);
                        if (kNode) {
                            nodes.push(kNode);
                        }
                    }

                    if (nodes.length > 0) {
                        for (i=0; i < nodes.length; i++) {
                            var comps = nodes[i].components.iterator();
                            while (comps.hasNext()) {
                                subs.push(comps.next());
                            }
                            var hosts = nodes[i].hosts.iterator();
                            while (hosts.hasNext()) {
                                subs.push(hosts.next());
                            }
                        }

                        if (subs.length > 0) {
                            return subs;
                        } else {
                            throw new Error('Unable to find '+children[1]+' in '+children[0]);
                        }
                    } else {
                        throw new Error('Unable to find node '+children[0]);
                    }
                } else {
                    // instance path with one segment
                    instances = [];
                    if (children[0] === '*') {
                        nodes = model.nodes.iterator();
                        while (nodes.hasNext()) {
                            instances.push(nodes.next());
                        }
                        var groups = model.groups.iterator();
                        while (groups.hasNext()) {
                            instances.push(groups.next());
                        }
                        var hubs = model.hubs.iterator();
                        while (hubs.hasNext()) {
                            instances.push(hubs.next());
                        }

                    } else {
                        var instance = model.findNodesByID(children[0]);
                        if (!instance) {
                            instance = model.findGroupsByID(children[0]);
                        }
                        if (!instance) {
                            instance = model.findHubsByID(children[0]);
                        }
                        if (instance) {
                            instances.push(instance);
                        }
                    }

                    if (instances.length > 0) {
                        return instances;
                    } else {
                        throw new Error('Unable to find instance '+children[0]);
                    }
                }
            } else {
                throw new Error('Namespaces are not implemented yet ('+children.join('.')+')');
            }
            break;

        case 'nameList':
            instances = [];
            for (i=0; i < stmt.children.length; i++) {
                var resolved = resolve(model, stmt.children[i]);
                for (var j=0; j < resolved.length; j++) {
                    instances.push(resolved[j]);
                }
            }
            return instances;

        default:
            throw new Error('Unknown statement type '+stmt.type);
    }
};
},{}],65:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree,
    async   = require('async'),
    path    = require('path');

var factory = new kevoree.factory.DefaultKevoreeFactory();
var cloner  = factory.createModelCloner();

// retrieve statements processors
var statements = {
    addRepo:                require('./statements/addRepo'),
    add:                    require('./statements/add'),
    move:                   require('./statements/move'),
    attach:                 require('./statements/attach'),
    addBinding:             require('./statements/addBinding'),
    delBinding:             require('./statements/delBinding'),
    include:                require('./statements/include'),
    set:                    require('./statements/set'),
    network:                require('./statements/network'),
    remove:                 require('./statements/remove'),
    detach:                 require('./statements/detach'),
    typeDef:                require('./statements/typeDef'),
    typeFQN:                require('./statements/typeFQN'),
    nameList:               require('./statements/nameList'),
    instancePath:           require('./statements/instancePath'),
    namespace:              require('./statements/namespace'),
    wildcard:               require('./statements/wildcard'),
    string:                 require('./statements/string'),
    string2:                require('./statements/string2'),
    string3:                require('./statements/string3'),
    repoString:             require('./statements/repoString'),
    version:                require('./statements/version'),
    anything:               require('./statements/anything'),
    realString:             require('./statements/realString'),
    realStringNoNewLine:    require('./statements/realStringNoNewLine'),
    newLine:                require('./statements/newLine'),
    singleQuoteLine:        require('./statements/singleQuoteLine'),
    doubleQuoteLine:        require('./statements/doubleQuoteLine'),
    escaped:                require('./statements/escaped'),
    start:                  require('./statements/start'),
    stop:                   require('./statements/stop'),
    pause:                  require('./statements/pause')
};

/**
 *
 * @param ast
 * @param ctxModel
 * @param callback
 */
var interpreter = function (ast, ctxModel, callback) {
    // output model
    var model = null;

    if (ctxModel) {
        // if we have a context model, clone it and use it has a base
        model = cloner.clone(ctxModel, false);
    } else {
        // otherwise start from a brand new model
        model = factory.createContainerRoot();
    }

    // this ContainerRoot is the root of the model
    factory.root(model);

    var options = { namespaces: {} };

    // process statements
    var tasks = [];
    ast.children.forEach(function (child0) {
        child0.children.forEach(function (stmt) {
            tasks.push(function (done) {
                if (typeof (statements[stmt.type]) === 'function') {
                    statements[stmt.type](model, statements, stmt, options, done);
                } else {
                    done(new Error('Unknown statement "'+stmt.type+'"'));
                }
            });
        });
    });

    // execute tasks
    async.series(tasks, function (err) {
        callback(err, model);
    });
};

module.exports = interpreter;
},{"./statements/add":69,"./statements/addBinding":70,"./statements/addRepo":71,"./statements/anything":72,"./statements/attach":73,"./statements/delBinding":74,"./statements/detach":75,"./statements/doubleQuoteLine":76,"./statements/escaped":77,"./statements/include":78,"./statements/instancePath":79,"./statements/move":80,"./statements/nameList":81,"./statements/namespace":82,"./statements/network":83,"./statements/newLine":84,"./statements/pause":85,"./statements/realString":86,"./statements/realStringNoNewLine":87,"./statements/remove":88,"./statements/repoString":89,"./statements/set":90,"./statements/singleQuoteLine":91,"./statements/start":92,"./statements/stop":93,"./statements/string":94,"./statements/string2":95,"./statements/string3":96,"./statements/typeDef":97,"./statements/typeFQN":98,"./statements/version":99,"./statements/wildcard":100,"async":101,"kevoree-library":109,"path":13}],66:[function(require,module,exports){
function findChanNodeGroupByName(model, name) {
  function findByName(elem) {
    var elems = (model[elem]) ? model[elem].iterator() : null;
    if (elems != null) {
      while (elems.hasNext()) {
        var entity = elems.next();
        if (entity.name === name) return entity;
      }
    }
    return null;
  }

  return findByName('nodes') || findByName('groups') || findByName('hubs') || null;
}

function findComponent(model, nodeName, compName) {
  var node = model.findNodesByID(nodeName);
  if (node) {
    return node.findComponentsByID(compName);
  } else return null;
}

module.exports = {
  findEntityByName: findChanNodeGroupByName,
  findComponentByName: findComponent
};
},{}],67:[function(require,module,exports){
var repos       = require('./elements/repositories'),
    includes    = require('./elements/includes'),
    instances   = require('./elements/instances'),
    attaches    = require('./elements/attaches'),
    lifecycles  = require('./elements/lifecycles'),
    bindings    = require('./elements/bindings'),
    sets        = require('./elements/sets'),
    networks    = require('./elements/networks');

/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var blocks = [
        // order matters !
        repos(model),
//        includes(model),
        instances(model),
        lifecycles(model),
        attaches(model),
        bindings(model),
        sets(model),
        networks(model)
    ];

    var kevscript = '';
    for (var i in blocks) {
        if (blocks.hasOwnProperty(i)) {
            kevscript += blocks[i];
            if (blocks[i].length > 0) {
                kevscript += '\n\n';
            }
        }
    }

    return kevscript.replace(/^([\n\t\r])+/, '').replace(/([\n\t\r])+$/, '\n');
};
},{"./elements/attaches":55,"./elements/bindings":56,"./elements/includes":57,"./elements/instances":58,"./elements/lifecycles":59,"./elements/networks":60,"./elements/repositories":61,"./elements/sets":62}],68:[function(require,module,exports){
/*
 * Generated by the Waxeye Parser Generator - version 0.8.0
 * www.waxeye.org
 */

var waxeye = waxeye;
if (typeof module !== 'undefined') {
    // require from module system
    waxeye = require('waxeye');
}

var Parser = (function() {

    var parser = function() { return this; };
    parser.prototype = new waxeye.WaxeyeParser(0, true, [new waxeye.FA("kevScript", [new waxeye.State([new waxeye.Edge(50, 1, false)], false),
            new waxeye.State([new waxeye.Edge(1, 2, false),
                new waxeye.Edge(48, 3, true)], true),
            new waxeye.State([new waxeye.Edge(50, 1, false)], false),
            new waxeye.State([new waxeye.Edge(49, 2, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("statement", [new waxeye.State([new waxeye.Edge(2, 1, false),
                new waxeye.Edge(3, 1, false),
                new waxeye.Edge(4, 1, false),
                new waxeye.Edge(5, 1, false),
                new waxeye.Edge(6, 1, false),
                new waxeye.Edge(7, 1, false),
                new waxeye.Edge(9, 1, false),
                new waxeye.Edge(10, 1, false),
                new waxeye.Edge(12, 1, false),
                new waxeye.Edge(8, 1, false),
                new waxeye.Edge(11, 1, false),
                new waxeye.Edge(16, 1, false),
                new waxeye.Edge(17, 1, false),
                new waxeye.Edge(18, 1, false),
                new waxeye.Edge(19, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("add", [new waxeye.State([new waxeye.Edge(35, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(":", 5, true)], false),
            new waxeye.State([new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge(14, 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("remove", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("move", [new waxeye.State([new waxeye.Edge(37, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("attach", [new waxeye.State([new waxeye.Edge(39, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("detach", [new waxeye.State([new waxeye.Edge(40, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("set", [new waxeye.State([new waxeye.Edge(38, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge("/", 4, true),
                new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge("=", 7, true)], false),
            new waxeye.State([new waxeye.Edge(50, 8, false)], false),
            new waxeye.State([new waxeye.Edge(27, 9, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("network", [new waxeye.State([new waxeye.Edge(41, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(23, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addBinding", [new waxeye.State([new waxeye.Edge(42, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("delBinding", [new waxeye.State([new waxeye.Edge(43, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addRepo", [new waxeye.State([new waxeye.Edge(33, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(31, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("include", [new waxeye.State([new waxeye.Edge(34, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(22, 3, false)], false),
            new waxeye.State([new waxeye.Edge(":", 4, true)], false),
            new waxeye.State([new waxeye.Edge(23, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("nameList", [new waxeye.State([new waxeye.Edge(20, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge([","], 3, true)], true),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("typeDef", [new waxeye.State([new waxeye.Edge(15, 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, true)], true),
            new waxeye.State([new waxeye.Edge(25, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("typeFQN", [new waxeye.State([new waxeye.Edge(24, 1, false)], false),
            new waxeye.State([new waxeye.Edge(["."], 2, false)], true),
            new waxeye.State([new waxeye.Edge(24, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("namespace", [new waxeye.State([new waxeye.Edge(44, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(22, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("start", [new waxeye.State([new waxeye.Edge(45, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("stop", [new waxeye.State([new waxeye.Edge(46, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("pause", [new waxeye.State([new waxeye.Edge(47, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("instancePath", [new waxeye.State([new waxeye.Edge(21, 1, false),
                new waxeye.Edge(22, 1, false)], false),
            new waxeye.State([new waxeye.Edge(["."], 2, true)], true),
            new waxeye.State([new waxeye.Edge(21, 1, false),
                new waxeye.Edge(22, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("wildcard", [new waxeye.State([new waxeye.Edge("*", 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("string", [new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("string2", [new waxeye.State([new waxeye.Edge(["%", [45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge(["%", [45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("string3", [new waxeye.State([new waxeye.Edge([[48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.PRUNE),
        new waxeye.FA("version", [new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("line", [new waxeye.State([new waxeye.Edge(52, 1, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false),
            new waxeye.State([new waxeye.Edge(51, 3, false)], true),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("realString", [new waxeye.State([new waxeye.Edge(["\'"], 1, true),
                new waxeye.Edge(["\""], 3, true)], false),
            new waxeye.State([new waxeye.Edge(32, 1, false),
                new waxeye.Edge(28, 1, false),
                new waxeye.Edge(29, 1, false),
                new waxeye.Edge(["\'"], 2, true)], false),
            new waxeye.State([], true),
            new waxeye.State([new waxeye.Edge(32, 3, false),
                new waxeye.Edge(28, 3, false),
                new waxeye.Edge(30, 3, false),
                new waxeye.Edge(["\""], 2, true)], false)], waxeye.FA.LEFT),
        new waxeye.FA("escaped", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([new waxeye.Edge(53, 2, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("singleQuoteLine", [new waxeye.State([new waxeye.Edge(59, 1, false)], false),
            new waxeye.State([new waxeye.Edge(58, 2, false)], false),
            new waxeye.State([new waxeye.Edge(57, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false),
            new waxeye.State([new waxeye.Edge(56, 5, false)], true),
            new waxeye.State([new waxeye.Edge(55, 6, false)], false),
            new waxeye.State([new waxeye.Edge(54, 7, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("doubleQuoteLine", [new waxeye.State([new waxeye.Edge(65, 1, false)], false),
            new waxeye.State([new waxeye.Edge(64, 2, false)], false),
            new waxeye.State([new waxeye.Edge(63, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false),
            new waxeye.State([new waxeye.Edge(62, 5, false)], true),
            new waxeye.State([new waxeye.Edge(61, 6, false)], false),
            new waxeye.State([new waxeye.Edge(60, 7, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("realStringNoNewLine", [new waxeye.State([new waxeye.Edge(["\'"], 1, true),
                new waxeye.Edge(["\""], 8, true)], false),
            new waxeye.State([new waxeye.Edge(["\\"], 2, false),
                new waxeye.Edge(69, 4, false),
                new waxeye.Edge(["\'"], 7, true)], false),
            new waxeye.State([new waxeye.Edge(66, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 1, false)], false),
            new waxeye.State([new waxeye.Edge(68, 5, false)], false),
            new waxeye.State([new waxeye.Edge(67, 6, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 1, false)], false),
            new waxeye.State([], true),
            new waxeye.State([new waxeye.Edge(["\\"], 9, false),
                new waxeye.Edge(73, 11, false),
                new waxeye.Edge(["\""], 7, true)], false),
            new waxeye.State([new waxeye.Edge(70, 10, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 8, false)], false),
            new waxeye.State([new waxeye.Edge(72, 12, false)], false),
            new waxeye.State([new waxeye.Edge(71, 13, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 8, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("newLine", [new waxeye.State([new waxeye.Edge("\r", 1, true),
                new waxeye.Edge("\n", 2, true),
                new waxeye.Edge("\r", 2, true)], false),
            new waxeye.State([new waxeye.Edge("\n", 2, true)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("repoToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("p", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("includeToken", [new waxeye.State([new waxeye.Edge("i", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("c", 3, false)], false),
            new waxeye.State([new waxeye.Edge("l", 4, false)], false),
            new waxeye.State([new waxeye.Edge("u", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([new waxeye.Edge("e", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("addToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("d", 2, false)], false),
            new waxeye.State([new waxeye.Edge("d", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("removeToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([new waxeye.Edge("v", 5, false)], false),
            new waxeye.State([new waxeye.Edge("e", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("moveToken", [new waxeye.State([new waxeye.Edge("m", 1, false)], false),
            new waxeye.State([new waxeye.Edge("o", 2, false)], false),
            new waxeye.State([new waxeye.Edge("v", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("setToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("attachToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("detachToken", [new waxeye.State([new waxeye.Edge("d", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("networkToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("w", 4, false)], false),
            new waxeye.State([new waxeye.Edge("o", 5, false)], false),
            new waxeye.State([new waxeye.Edge("r", 6, false)], false),
            new waxeye.State([new waxeye.Edge("k", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("bindToken", [new waxeye.State([new waxeye.Edge("b", 1, false)], false),
            new waxeye.State([new waxeye.Edge("i", 2, false)], false),
            new waxeye.State([new waxeye.Edge("n", 3, false)], false),
            new waxeye.State([new waxeye.Edge("d", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("unbindToken", [new waxeye.State([new waxeye.Edge("u", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("b", 3, false)], false),
            new waxeye.State([new waxeye.Edge("i", 4, false)], false),
            new waxeye.State([new waxeye.Edge("n", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("namespaceToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("a", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([new waxeye.Edge("s", 5, false)], false),
            new waxeye.State([new waxeye.Edge("p", 6, false)], false),
            new waxeye.State([new waxeye.Edge("a", 7, false)], false),
            new waxeye.State([new waxeye.Edge("c", 8, false)], false),
            new waxeye.State([new waxeye.Edge("e", 9, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("startToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("a", 3, false)], false),
            new waxeye.State([new waxeye.Edge("r", 4, false)], false),
            new waxeye.State([new waxeye.Edge("t", 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("stopToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("o", 3, false)], false),
            new waxeye.State([new waxeye.Edge("p", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("pauseToken", [new waxeye.State([new waxeye.Edge("p", 1, false)], false),
            new waxeye.State([new waxeye.Edge("a", 2, false)], false),
            new waxeye.State([new waxeye.Edge("u", 3, false)], false),
            new waxeye.State([new waxeye.Edge("s", 4, false)], false),
            new waxeye.State([new waxeye.Edge("e", 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("comment", [new waxeye.State([new waxeye.Edge("/", 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, false)], false),
            new waxeye.State([new waxeye.Edge(26, 3, false)], true),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("eol", [new waxeye.State([new waxeye.Edge("\r", 1, false),
                new waxeye.Edge("\n", 2, false),
                new waxeye.Edge("\r", 2, false)], false),
            new waxeye.State([new waxeye.Edge("\n", 2, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("ws", [new waxeye.State([new waxeye.Edge(["\t", " "], 0, false),
                new waxeye.Edge(49, 0, false)], true)], waxeye.FA.VOID),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG)]);
    return parser;
 
})();

// Add to module system
if (typeof module !== 'undefined') {
    module.exports.Parser = Parser;
}

},{"waxeye":108}],69:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();
var Kotlin  = require('kevoree-kotlin');
var getFQN  = require('../getFQN');

module.exports = function (model, statements, stmt, opts, done) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts);
    statements[stmt.children[1].type](model, statements, stmt.children[1], opts, function (err, tDef) {
        if (err) {
            done(err);
        } else {
            function inflateDictionary(instance) {
                var dicType = instance.typeDefinition.dictionaryType;
                if (dicType) {
                    var dic = factory.createDictionary();
                    var attrs = dicType.attributes.iterator();
                    while (attrs.hasNext()) {
                        var attr = attrs.next();
                        if (!attr.fragmentDependant && !attr.optional && typeof attr.defaultValue !== 'undefined') {
                            var val = factory.createValue();
                            val.name = attr.name;
                            val.value = attr.defaultValue;
                            dic.addValues(val);
                        }
                    }
                    if (dic.values.size() > 0) {
                        instance.dictionary = dic;
                    }
                }
            }

            // add node instance function
            function addNodeInstance(namespace, nodeName, parentNode) {
                if (nodeName !== '*') {
                    var node = factory.createContainerNode();
                    node.name = nodeName;
                    node.typeDefinition = model.findByPath(tDef.path());
                    node.started = true;
                    inflateDictionary(node);
                    model.addNodes(node);
                    if (parentNode) {
                        parentNode.addHosts(node);
                    }

                    if (namespace) {
                        if (opts.namespaces[namespace]) {
                            opts.namespaces[namespace][nodeName] = node;
                        } else {
                            done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    }
                } else {
                    done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                }
            }

            // create proper entity according to the type
            if (Kotlin.isType(tDef, kevoree.NodeType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 3, function (err, namespace, parentName, childName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (namespace) {
                            // TODO handle namespaces
                            done(new Error('Namespaces are not handled yet'));
                        } else {
                            if (parentName) {
                                if (parentName === '*') {
                                    // parentName can't be '*' because each node name must be unique within a model so you can't
                                    // duplicate the same childName on each parentNode
                                    done(new Error('You can not refer to all node instances with \'*\' when adding child node instances. (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                } else {
                                    var parentNode = model.findNodesByID(parentName);
                                    if (parentNode) {
                                        addNodeInstance(namespace, childName, parentNode);

                                    } else {
                                        done(new Error('Unable to find parent node instance "'+parentName+'" in model. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                    }
                                }

                            } else {
                                addNodeInstance(namespace, childName);
                            }
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.GroupType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 2, function (err, namespace, instanceName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (instanceName !== '*') {
                            var group = factory.createGroup();
                            group.name = instanceName;
                            group.typeDefinition = model.findByPath(tDef.path());
                            group.started = true;
                            inflateDictionary(group);
                            model.addGroups(group);

                            if (namespace) {
                                if (opts.namespaces[namespace]) {
                                    opts.namespaces[namespace][instanceName] = group;
                                } else {
                                    done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        } else {
                            done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.ChannelType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 2, function (err, namespace, instanceName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (instanceName !== '*') {
                            var chan = factory.createChannel();
                            chan.name = instanceName;
                            chan.typeDefinition = model.findByPath(tDef.path());
                            chan.started = true;
                            inflateDictionary(chan);
                            model.addHubs(chan);

                            if (namespace) {
                                if (opts.namespaces[namespace]) {
                                    opts.namespaces[namespace][instanceName] = chan;
                                } else {
                                    done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        } else {
                            done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.ComponentType)) {
                for (var i in nameList) {
                    nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
                        if (err) {
                            done(new Error('Component instances must be added to Node instances (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                            return;
                        }

                        if (namespace) {
                            // TODO handle namespace
                            done(new Error('Namespaces are not handled yet :/ Sorry'));

                        } else if (compName === '*') {
                            done(new Error('You cannot name a component instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));

                        } else {
                            var comp;
                            if (nodeName === '*') {
                                // add compName instance to all nodes in the model
                                var nodes = model.nodes.iterator();
                                while (nodes.hasNext()) {
                                    comp = factory.createComponentInstance();
                                    comp.name = compName;
                                    comp.typeDefinition = model.findByPath(tDef.path());;
                                    comp.started = true;
                                    inflateDictionary(comp);
                                    nodes.next().addComponents(comp);
                                }

                            } else {
                                var node = model.findNodesByID(nodeName);
                                if (node) {
                                    comp = factory.createComponentInstance();
                                    comp.name = compName;
                                    comp.typeDefinition = model.findByPath(tDef.path());;
                                    comp.started = true;
                                    inflateDictionary(comp);
                                    node.addComponents(comp);

                                } else {
                                    done(new Error('Unable to find container node "'+nodeName+'" in current model (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        }
                    });
                }

            } else {
                done(new Error('TypeDefinition "'+tDef.name+'/'+tDef.version+'" doesn\'t exist in current model. (Maybe you should add an "include" for it?)'));
                return;
            }
            done();
        }
    });
};
},{"../getFQN":63,"kevoree-kotlin":102,"kevoree-library":109}],70:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    function addBinding2(portName, comp, node, chanInst) {
        // start with an undefined portInst
        var portInst;

        // now lets try to find a Port instance in this component provided ports
        portInst = comp.findProvidedByID(portName);
        if (!portInst) {
            // if we can't find it in provided ports, lets try in required
            portInst = comp.findRequiredByID(portName);
        }
        if (!portInst) {
            // reaching this point means that we were not able to find any port instance
            // matching this portName, so we have to create a brand new port instance
            portInst = factory.createPort();
            // lets try to find a PortTypeRef in the component TypeDefinition provided ports that matches portName
            var inputRefs = comp.typeDefinition.provided.iterator();
            while (inputRefs.hasNext()) {
                var inRef = inputRefs.next();
                if (inRef.name === portName) {
                    // bingo, add it the the comp instance
                    portInst.portTypeRef = inRef;
                    portInst.name = portName;
                    comp.addProvided(portInst);
                    break;
                }
            }
            if (!portInst.portTypeRef) {
                // well, it isn't a provided port obviously, so now lets try to find out if it is a required
                var outputRefs = comp.typeDefinition.required.iterator();
                while (outputRefs.hasNext()) {
                    var outRef = outputRefs.next();
                    if (outRef.name == portName) {
                        // bingo, add it to the comp instance
                        portInst.portTypeRef = outRef;
                        portInst.name = portName;
                        comp.addRequired(portInst);
                        break;
                    }
                }
            }
        }

        if (portInst && portInst.portTypeRef && portInst.name === portName) {
            var bindings = model.mBindings.iterator();
            var alreadyBound = false;
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding.hub.name === chanInst.name &&
                    binding.port.name === portName &&
                    binding.port.eContainer().name === comp.name &&
                    binding.port.eContainer().eContainer().name === node.name) {
                    alreadyBound = true;
                    break;
                }
            }

            if (!alreadyBound) {
                binding = factory.createMBinding();
                binding.port = portInst;
                binding.hub  = chanInst;
                model.addMBindings(binding);
            }
        } else {
            // seems like you are trying to connect a port that do not belong to the comp you referred to
            return cb(new Error('Unable to find port "'+portName+'" in component '+comp.typeDefinition.name+'['+comp.name+'] (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function addBinding1(portName, compName, node, chanInst) {
        var comp = node.findComponentsByID(compName);
        if (comp) {
            if (portName === '*') {
                var inputRefs = comp.typeDefinition.provided.iterator();
                while (inputRefs.hasNext()) {
                    addBinding2(inputRefs.next().name, comp, node, chanInst);
                }
                var outputRefs = comp.typeDefinition.required.iterator();
                while (outputRefs.hasNext()) {
                    addBinding2(outputRefs.next().name, comp, node, chanInst);
                }

            } else {
                addBinding2(portName, comp, node, chanInst);
            }
        } else {
            return cb(new Error('Unable to find component instance "'+compName+'" in node "'+node.name+'" (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function addBinding0(portName, compName, nodeName, chanInst) {
        var node = model.findNodesByID(nodeName);
        if (node) {
            if (compName === '*') {
                var compz = node.components.iterator();
                while (compz.hasNext()) {
                    addBinding1(portName, compz.next().name, node, chanInst);
                }

            } else {
                addBinding1(portName, compName, node, chanInst);
            }
        } else {
            return cb(new Error('Unable to find node instance "'+nodeName+'" in model (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function bindPortToChan(chanInst) {
        port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
            if (err) {
                err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
                return cb(err);
            }

            if (namespace) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

            } else {
                if (nodeName === '*') {
                    var nodes = model.nodes.iterator();
                    while (nodes.hasNext()) {
                        addBinding0(portName, compName, nodes.next().name, chanInst);
                    }

                } else {
                    addBinding0(portName, compName, nodeName, chanInst);
                }
            }
        });
    }

    chan.expect(1, 2, function (err, namespace, name) {
        if (err) {
            err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
            return cb(err);
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

        } else {
            if (name === '*') {
                var chanz = model.hubs.iterator();
                while (chanz.hasNext()) {
                    bindPortToChan(chanz.next());
                }

            } else {
                var chanInst = model.findHubsByID(name);
                if (chanInst) {
                    bindPortToChan(chanInst);

                } else {
                    return cb(new Error('Unable to find target channel instance "'+name+'" (bind '+port.toString()+' '+chan.toString()+')'));
                }
            }
        }
    });

    cb();
};
},{"kevoree-library":109}],71:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var url = statements[stmt.children[0].type](model, statements, stmt, opts, cb);

    // create repository & add it to model
    var repo = factory.createRepository();
    repo.url = url;
    model.addRepositories(repo);

    cb();
};
},{"kevoree-library":109}],72:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
  return stmt.children.join('');
}
},{}],73:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function addNodeToGroup(group) {
    for (var i=0; i < nameList.length; i++) {
      nameList[i].expect(1, 2, function (err, namespace, nodeName) {
        if (err) {
          err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            // attach all nodes to group
            var nodes = model.nodes.iterator();
            while (nodes.hasNext()) group.addSubNodes(nodes.next());

          } else {
            var node = model.findNodesByID(nodeName);
            if (node) {
              group.addSubNodes(node);
            } else {
              return cb(new Error('Unable to find node "'+nodeName+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
            }
          }
        }
      });
    }
  }

  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

    } else {
      if (name === '*') {
        var groups = model.groups.iterator();
        while (groups.hasNext()) addNodeToGroup(groups.next());

      } else {
        var group = model.findGroupsByID(name);
        if (group) {
          addNodeToGroup(group);

        } else {
          return cb(new Error('Unable to find group "'+name+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{}],74:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
    var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    function unbindPortFromChan2(portName, comp, node, chanName) {
        var bindings = model.mBindings.iterator();
        while (bindings.hasNext()) {
            var binding = bindings.next();
            if (binding.port.portTypeRef.name === portName &&                // binding's port matches portName
                binding.port.eContainer().name === comp.name &&              // port's component matches comp.name
                binding.port.eContainer().eContainer().name === node.name && // component's container matches node.name
                binding.hub.name === chanName) {                             // binding's hub name matches chanName

                if (binding.port) binding.port.removeBindings(binding);
                if (binding.hub)  binding.hub.removeBindings(binding);
                model.removeMBindings(binding);
            }
        }
    }

    function unbindPortFromChan1(portName, comp, node, chanName) {
        if (portName === '*') {
            var inputRefs = comp.typeDefinition.provided.iterator();
            var outputRefs = comp.typeDefinition.required.iterator();

            while (inputRefs.hasNext()) {
                unbindPortFromChan2(inputRefs.next().name, comp, node, chanName);
            }

            while (outputRefs.hasNext()) {
                unbindPortFromChan2(outputRefs.next().name, comp, node, chanName);
            }

        } else {
            unbindPortFromChan2(portName, comp, node, chanName);
        }
    }

    function unbindPortFromChan0(portName, compName, node, chanName) {
        if (compName === '*') {
            var compz = node.components.iterator();
            while (compz.hasNext()) {
                unbindPortFromChan1(portName, compz.next(), node, chanName);
            }

        } else {
            var comp = node.findComponentsByID(compName);
            if (comp) {
                unbindPortFromChan1(portName, comp, node, chanName);
            } else {
                return cb(new Error('Unable to find component instance "'+compName+'" in node instance "'+node.name+'" (unbind '+port.toString()+' '+chan.toString()+')'));
            }
        }
    }

    function preUnbindProcess(chanInst) {
        port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
            if (err) {
                err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
                return cb(err);
            }

            if (namespace) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

            } else {
                if (nodeName === '*') {
                    var nodes = model.nodes.iterator();
                    while (nodes.hasNext()) {
                        unbindPortFromChan0(portName, compName, nodes.next(), chanInst.name);
                    }

                } else {
                    var node = model.findNodesByID(nodeName);
                    if (node) {
                        unbindPortFromChan0(portName, compName, node, chanInst.name);
                    } else {
                        return cb(new Error('Unable to find node instance "'+nodeName+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
                    }
                }
            }
        });
    }

    chan.expect(1, 2, function (err, namespace, name) {
        if (err) {
            err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
            return cb(err);
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

        } else {
            if (name === '*') {
                var chanz = model.hubs.iterator();
                while (chanz.hasNext()) {
                    preUnbindProcess(chanz.next());
                }

            } else {
                var chanInst = model.findHubsByID(name);
                if (chanInst) {
                    preUnbindProcess(chanInst);
                } else {
                    return cb(new Error('Unable to find channel instance "'+name+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
                }
            }
        }
    });

    cb();
}
},{}],75:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts);
    var groupName = statements[stmt.children[1].type](model, statements, stmt.children[1], opts);

    if (groupName.raw.length === 1) {
        groupName = groupName.toString();
        var group = model.findGroupsByID(groupName);
        if (group) {
            for (var i=0; i < nameList.length; i++) {
                if (nameList[i].raw.length === 1) {
                    var nodeName = nameList[i].toString();
                    var node = model.findNodesByID(nodeName);
                    if (node) {
                        node.removeGroups(group);
                        group.removeSubNodes(node);
                    } else {
                        cb(new Error('Unable to find node instance "'+nodeName+'" '+printLine(nameList, groupName)));
                        break;
                    }
                } else {
                    cb(new Error('Namespaces are not implemented yet '+printLine(nameList, groupName)));
                }
            }
            cb();
        } else {
            cb(new Error('Unable to find group instance "'+groupName+'" '+printLine(nameList, groupName)));
        }
    } else {
        cb(new Error('Namespaces are not implemented yet '+printLine(nameList, groupName)));
    }
};

function printLine(nameList, groupName) {
    return '(detach '+display(nameList)+' '+groupName.toString()+')';
}

function display(nameList) {
    return nameList.map(function (instancePath) {
        return instancePath.toString();
    }).join(', ');
}
},{}],76:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
  return stmt.children.join('');
}
},{}],77:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
  return stmt.children.join('');
};
},{}],78:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var path = require('path');

var factory = new kevoree.factory.DefaultKevoreeFactory();
var compare = factory.createModelCompare();

module.exports = function (model, statements, stmt, opts, cb) {
    console.log('"include" statement is deprecated since kevoree-kevscript@>=2.0.0');
    cb();
//    if (!cb) {
//        // if "cb" is undefined, then  there is no "opts" parameter given, so no resolver, so :/
//        return opts(new Error('You must give resolvers as options to "include.js" statement processor'));
//    }
//
//    if (!opts.resolvers) return cb(new Error('Unable to process include. No resolver given'));
//
//    var du = factory.createDeployUnit();
//    var type = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
//    var mergeDef = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
//
//    if (opts.resolvers[type]) {
//        var colons = mergeDef.split(':');
//        var arobas = mergeDef.split('@');
//        if (colons.length === 1 && arobas.length === 1) {
//            // mergeDef looks like: foo
//            du.name = mergeDef;
//
//        } else if (colons.length === 1 && arobas.length === 2) {
//            // mergeDef looks like: foo@version
//            du.name = arobas[0];
//            du.version = arobas[1];
//
//        } else if (colons.length === 2 && arobas.length === 1) {
//            // mergeDef looks like: foo:version
//            du.name = colons[0];
//            du.version = colons[1];
//
//        } else if (colons.length === 3 && arobas.length === 1) {
//            // mergeDef looks like: foo:bar:version
//            du.groupName = colons[0];
//            du.name = colons[1];
//            du.version = colons[2];
//
//        } else if (colons.length === 2 && arobas.length === 2) {
//            // mergeDef looks like: foo:bar@version
//            var subSplit = arobas[0].split(':');
//            du.groupName = subSplit[0];
//            du.name = subSplit[1];
//            du.version = arobas[1];
//        }
//
//        opts.resolvers[type].resolve(du, function (err, Clazz, duModel) {
//            if (err) return cb(err);
//
//            var loader = factory.createJSONLoader();
//            var serializer = factory.createJSONSerializer();
//
//            var tmp = loader.loadModelFromString(serializer.serialize(duModel)).get(0);
//            var mergeSeq = compare.merge(model, tmp);
//            mergeSeq.applyOn(model);
//            return cb();
//        });
//
//    } else {
//        // no resolver set for include statements with "type"
//        return cb(new Error('Error: include '+type+':'+mergeDef+' (Unable to handle "'+type+'" include type. Did you add a resolver for that?)'));
//    }
};
},{"kevoree-library":109,"path":13}],79:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var instancePath = [];
    for (var i in stmt.children) {
        instancePath.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts));
    }

    return {
        raw: instancePath,
        /**
         * 'a.b.c' with expect(2, 4, function (err, one, two, three, four) {
         *   if (err) {
         *     // something went wrong with instancePath.expect parsing
         *   }
         *
         *   // when parsing 'a.b.c' with expect(2, 4, ...) you get:
         *   // one   === null
         *   // two   === 'a'
         *   // three === 'b'
         *   // four  === 'c'
         * }
         * @param min minimum expected values in instancePath (ex: a.b.c with "min" = 4 will return an error in callback)
         * @param max maximum expected values in instancePath (same as minimum but for maximum :D )
         * @param callback function (err, [arg0, arg1, ...])
         * @returns {*}
         */
        expect: function (min, max, callback) {
            if (instancePath.length > max || instancePath.length < min) {
                var err = new Error('InstancePath does not match requirements (path: '+instancePath.join('.')+', length: '+instancePath.length+', min: '+min+', max: '+max+')');
                err.pathLength = instancePath.length;
                err.expectedMin = min;
                err.expectedMax = max;
                return callback(err);
            }

            instancePath.unshift(null); // prepend null error value to params array
            // nullify missing value in path (ex: 'a.b.c' with expect(2, 4, function (err, one, two, three, four) { }
            // will nullify 'one' and shift values so you get two => a, three => b and four => c
            for (var i=instancePath.length-1; i < max; i++) instancePath.unshift(null);
            return callback.apply(null, instancePath);
        },

        toString: function () {
            // remove useless dots
            return instancePath.join('.').replace(/^\.*/g, '');
        }
    };
};
},{}],80:[function(require,module,exports){
var Kotlin = require('kevoree-kotlin');
var kevoree = require('kevoree-library').org.kevoree;

module.exports = function (model, statements, stmt, opts, cb) {
  // instances to move
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  // target node to move instances to
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function processNameList(targetNode) {
    for (var i in nameList) {
      nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
        if (err) {
          err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            if (compName === '*') {
              // move *.* fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }

            } else {
              // move *.fooComp fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comp = fromNode.findComponentsByID(compName);
                if (comp) {
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }
            }

          } else {
            if (compName === '*') {
              // move fooNode.* barNode
              var fromNode = model.findNodesByID(nodeName);
              if (fromNode) {
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }

            } else {
              // move fooNode.fooComp barNode
              var node = model.findNodesByID(nodeName);
              if (node) {
                var comp = node.findComponentsByID(compName);
                if (comp) {
                  node.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }
            }
          }
        }
      });
    }
  }

  // process target instancePath
  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));
//      if (opts.namespaces[namespace]) {
//        var instance = opts.namespaces[namespace][name];
//        if (Kotlin.isType(instance.typeDefinition, kevoree.impl.NodeTypeImpl)) {
//          // target node exists
//          processNameList(instance);
//
//        } else {
//          return cb(new Error('Matched entity in namespace "'+[namespace, name].join('.')+'" must be a NodeType.'));
//        }
//
//      } else {
//        return cb(new Error('Unable to find namespace "'+namespace+'"'));
//      }

    } else {
      if (name === '*') {
        return cb(new Error('You must specify one and only node target (move '+nameList.toString()+' '+target.toString()+')'));

      } else {
        // check if the target exists
        var targetNode = model.findNodesByID(name);
        if (targetNode) {
          // target node exists
          processNameList(targetNode);

        } else {
          // node does not exist in current model
          return cb(new Error('Unable to find target node "'+target.toString()+'" in current model (move '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{"kevoree-kotlin":102,"kevoree-library":109}],81:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var ret = [];
    for (var i in stmt.children) {
        ret.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts));
    }
    return ret;
};
},{}],82:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  opts.namespaces = opts.namespaces || {};
  var name = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  opts.namespaces[name] = [];
}
},{}],83:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var networkPath  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    networkPath.expect(3, 4, function (err, namespace, nodeName, netName, propName) {
        if (err) {
            err.message += ' (network '+networkPath.toString()+' '+value+')';
            return cb(err);
        }

        function addProp(net, propName) {
            if (propName === '*') {
                var props = net.values.iterator();
                while (props.hasNext()) {
                    props.next().value = value;
                }

            } else {
                var prop = net.findValuesByID(propName);
                if (prop) {
                    prop.value = value;
                } else {
                    prop = factory.createValue();
                    prop.name = propName;
                    prop.value = value;
                    net.addValues(prop);
                }
            }
        }

        function addNet(node, netName, propName) {
            if (netName === '*') {
                var nets = node.networkInformation.iterator();
                while (nets.hasNext()) addProp(nets.next(), propName);

            } else {
                var net = node.findNetworkInformationByID(netName);
                if (net) {
                    addProp(net, propName);
                } else {
                    net = factory.createNetworkInfo();
                    net.name = netName;
                    node.addNetworkInformation(net);
                    addProp(net, propName);
                }
            }
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (network '+networkPath.toString()+' '+value+')'));

        } else {
            // networkPath looks like "network node.foo.bar 0.0.0.0"
            if (nodeName === '*') {
                var nodes = model.nodes.iterator();
                while (nodes.hasNext()) addNet(nodes.next(), netName, propName);

            } else {
                var node = model.findNodesByID(nodeName);
                if (node) {
                    addNet(node, netName, propName);
                } else {
                    return cb(new Error('Unable to find node instance "'+nodeName+'" (network '+networkPath.toString()+' '+value+')'));
                }
            }
        }
    });

    cb();
};
},{"kevoree-library":109}],84:[function(require,module,exports){
module.exports = function () {
    return '\n';
};
},{}],85:[function(require,module,exports){
/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    cb(new Error('Pause statement is not implemented yet'));
};
},{}],86:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var str = '';
    for (var i in stmt.children) {
        if (typeof (stmt.children[i]) === 'string') {
            str += stmt.children[i];
        } else if (stmt.children[i] instanceof Object) {
            str += statements[stmt.children[i].type](model, statements, stmt.children[i], opts);
        }
    }
    return str;
};
},{}],87:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
    return stmt.children[0].children.join('');
};
},{}],88:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var Kotlin = require('kevoree-kotlin');
var factory = kevoree.factory.DefaultKevoreeFactory();
var helper = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);

    function doRemove1(nodeName, third) {
        var node = model.findNodesByID(nodeName);
        if (node) {
            if (third === '*') {
                // remove all components within this node
                var compz = node.components.iterator();
                while (compz.hasNext()) doRemove(compz.next());

            } else {
                var comp = node.findComponentsByID(third);
                if (comp) {
                    doRemove(comp);
                } else {
                    return cb(new Error('Unable to find component instance "'+third+'" in node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
                }
            }
        } else {
            return cb(new Error('Unable to find node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
        }
    }

    function doRemove(instance) {
        if (Kotlin.isType(instance, kevoree.ContainerNode)) {
            // remove groups fragment dictionary related to this node
            var groups = model.groups.iterator();
            while (groups.hasNext()) {
                var grp = groups.next();
                var dic = grp.findFragmentDictionaryByID(instance.name);
                if (dic) grp.removeFragmentDictionary(dic);
            }

            // remove channels fragment dictionary related to this node
            var hubs = model.hubs.iterator();
            while (hubs.hasNext()) {
                var hub = hubs.next();
                var dic = hub.findFragmentDictionaryByID(instance.name);
                if (dic) hub.removeFragmentDictionary(dic);
            }

            // remove bindings related to this node
            var comps = instance.components.iterator();
            while (comps.hasNext()) {
                var comp = comps.next();
                var provided = comp.provided.iterator();
                while (provided.hasNext()) {
                    var pPort = provided.next();
                    var bindings = pPort.bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
                var required = comp.required.iterator();
                while (required.hasNext()) {
                    var rPort = required.next();
                    var bindings = rPort.bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
            }

            // delete links with groups
            var groups = instance.groups.iterator();
            while (groups.hasNext()) groups.next().removeSubNodes(instance);

            // remove node itself
            if (instance.host) instance.host.removeHosts(instance);
            model.removeNodes(instance);

        } else if (Kotlin.isType(instance, kevoree.Group)) {
            // remove link between this group and nodes
            var nodes = instance.subNodes.iterator();
            while (nodes.hasNext()) nodes.next().removeGroups(instance);
            // remove group
            model.removeGroups(instance);

        } else if (Kotlin.isType(instance, kevoree.Channel)) {
            var bindings = model.mBindings.iterator();
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding.hub.name === instance.name) {
                    if (binding.port) binding.port.removeBindings(binding);
                    if (binding.hub)  binding.hub.removeBindings(binding);
                    model.removeMBindings(binding);
                }
            }
            model.removeHubs(instance);

        } else if (Kotlin.isType(instance, kevoree.ComponentInstance)) {
            function deleteBindings(ports) {
                while (ports.hasNext()) {
                    var bindings = ports.next().bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        if (binding.port) binding.port.removeBindings(binding);
                        if (binding.hub)  binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
            }

            deleteBindings(instance.provided.iterator());
            deleteBindings(instance.required.iterator());
            instance.eContainer().removeComponents(instance);

        } else {
            return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
        }
    }

    for (var i in nameList) {
        nameList[i].expect(1, 3, function (err, first, second, third) {
            if (err) {
                err.message = ' (remove '+nameList.toString()+')';
                return cb(err);
            }

            if (first) {
                // TODO there is at least 3 parts in path so it must refer to a namespace 'first.second.third'
                return cb(new Error('Namespaces are not handled yet :/ Sorry (remove '+nameList.toString()+')'));

            } else {
                if (second) {
                    // two parts path: 'second.third'
                    if (second === '*') {
                        var nodes = model.nodes.iterator();
                        while (nodes.hasNext()) doRemove1(nodes.next().name, third);
                    } else {
                        doRemove1(second, third);
                    }
                } else {
                    // one part path: 'third'
                    if (third === '*') {
                        var nodes = model.nodes.iterator();
                        var groups = model.groups.iterator();
                        var hubs = model.hubs.iterator();

                        while (nodes.hasNext())  doRemove(nodes.next());
                        while (groups.hasNext()) doRemove(groups.next());
                        while (hubs.hasNext())   doRemove(hubs.next());

                    } else {
                        var instance = helper.findEntityByName(model, third);
                        if (instance)
                            doRemove(instance);
                        else
                            return cb(new Error('Unable to find instance "'+third+'" in model (remove '+nameList.toString()+')'));
                    }
                }
            }
        });
    }

    var names = [];

    if (stmt.children[0].type == 'nameList') {
        for (var i in stmt.children[0].children) {
            names.push(stmt.children[0].children[i].children.join(''));
        }
    } else {
        names.push(stmt.children[0].children.join(''));
    }

    for (var i in names) {
        var entity = helper.findEntityByName(model, names[i]);
        if (entity != null) {
            if (Kotlin.isType(entity, kevoree.ContainerNode)) {
                var groups = (model.groups) ? model.groups.iterator() : null;
                if (groups != null) {
                    while (groups.hasNext()) {
                        var group = groups.next();
                        var subNodes = group.subNodes.iterator();
                        while (subNodes.hasNext()) {
                            if (subNodes.next().name == entity.name) group.removeSubNodes(entity);
                        }
                        var values = group.dictionary.values.iterator();
                        while (values.hasNext()) {
                            var val = values.next();
                            if (val.targetNode.name == entity.name) group.dictionary.removeValues(val);
                        }
                    }
                }
                model.removeNodes(entity);

            } else if (Kotlin.isType(entity, kevoree.Group)) {
                model.removeGroups(entity);
            } else if (Kotlin.isType(entity, kevoree.Channel)) {
                model.removeHubs(entity);
            } else if (Kotlin.isType(entity, kevoree.ComponentInstance)) {
                entity.eContainer().removeComponents(entity);
            } else {
                return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
            }
        }
    }

    cb();
};
},{"../model-helper":66,"kevoree-kotlin":102,"kevoree-library":109}],89:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
  return stmt.children.join('');
};
},{}],90:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();
var helper  = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
    var attr  = null,
        node  = null,
        value = null;

    function processAttribute(dic, attrName) {
        var dicValue = dic.findValuesByID(attrName);
        if (dicValue) {
            // update value
            dicValue.value = value;
        } else {
            // dictionary value for attribute named attrName does not exist yet: create it and add it if possible
            var kAttr = dic.eContainer().typeDefinition.dictionaryType.findAttributesByID(attrName);
            if (kAttr) {
                dicValue = factory.createValue();
                dicValue.name = attrName;
                dicValue.value = value;
                dic.addValues(dicValue);
            } else {
                cb(new Error('Unknown attribute "'+attrName+'" in '+dic.eContainer().path()+' (set '+attr.toString()+' = "'+value+'")'));
            }
        }
    }

    function processNodeAndHostsAttribute(node, hostName, attrName) {
        if (hostName === '*') {
            var comps = node.components.iterator();
            while (comps.hasNext()) processInstanceAttribute(comps.next(), attrName);

        } else {
            var host = node.findComponentsByID(hostName);
            if (!host) {
                host = node.findHostsByID(hostName);
                if (!host) {
                    return cb(new Error('Unable to find instance "'+hostName+'" in "'+node.name+'" model (set '+attr.toString()+' = "'+value+'")'));
                }
            }
            processInstanceAttribute(host, attrName);
        }
    }

    function processInstanceAttribute(instance, attrName) {
        if (node) {
            // fragment dependant attribute
            var dic = instance.findFragmentDictionaryByID(node.toString());
            if (!dic) {
                // there is no fragmentDependant dictionary for this instance and fragment yet: create one
                dic = factory.createFragmentDictionary();
                dic.name = node.toString();
                instance.addFragmentDictionary(dic);
            }
            processAttribute(dic, attrName);

        } else {
            // non-fragment dependant attribute
            if (!instance.dictionary) instance.dictionary = factory.createDictionary();
            processAttribute(instance.dictionary, attrName);
        }
    }

    if (stmt.children.length === 2) {
        // set statement looks like: set an.instance.path = 'aValue'
        attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

        attr.expect(2, 4, function (err, ns, two, three, four) {
            if (err) {
                err.message += ' (set '+attr.toString()+' = "'+value+'")';
                return cb(err);
            }

            if (ns) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+' = "'+value+'")'));

            } else {
                if (two) {
                    // statement looks like foo.bar.baz = '42'
                    if (two === '*') {
                        // TODO handle namespaces too when using '*' ?
                        var nodes = model.nodes.iterator();
                        while (nodes.hasNext()) processNodeAndHostsAttribute(nodes.next(), three, four);

                    } else {
                        // check whether "two" is a namespace or a node name
                        var nodeInstance = model.findNodesByID(two);
                        if (nodeInstance) {
                            processNodeAndHostsAttribute(nodeInstance, three, four);

                        } else {
                            // TODO
                            return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+' = "'+value+'")'));
                        }
                    }

                } else {
                    // statement looks like foo.bar = '42'
                    var instance = helper.findEntityByName(model, three);
                    if (instance) {
                        processInstanceAttribute(instance, four);

                    } else {
                        return cb(new Error('Unable to find instance "'+two+'" in model (set '+attr.toString()+' = "'+value+'")'));
                    }
                }
            }
        });

    } else if (stmt.children.length === 3) {
        // set statement looks like: set an.instance.path/aNode = 'aValue'
        attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        node  = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
        value = statements[stmt.children[2].type](model, statements, stmt.children[2], opts, cb);

        attr.expect(2, 3, function (err, ns, instanceName, attrName) {
            if (err) {
                err.message += ' (set '+attr.toString()+'/'+node.toString()+' = "'+value+'")';
                return cb(err);
            }

            if (ns) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+'/'+node.toString()+' = "'+value+'")'));

            } else {
                if (instanceName === '*') {
                    var groups = model.groups.iterator();
                    while (groups.hasNext()) processInstanceAttribute(groups.next(), attrName);
                    var hubs = model.hubs.iterator();
                    while (hubs.hasNext()) processInstanceAttribute(hubs.next(), attrName);

                } else {
                    // instance is whether a group or a channel
                    var groups = model.groups.iterator();
                    while (groups.hasNext()) {
                        var grp = groups.next();
                        if (grp.name === instanceName) {
                            return processInstanceAttribute(grp, attrName);
                        }
                    }

                    var chans = model.hubs.iterator();
                    while (chans.hasNext()) {
                        var hub = chans.next();
                        if (hub.name === instanceName) {
                            return processInstanceAttribute(hub, attrName);
                        }
                    }
                }
            }
        });
    }

    cb();
};
},{"../model-helper":66,"kevoree-library":109}],91:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],92:[function(require,module,exports){
var resolver = require('../instance-resolver');

/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    var error = null;
    try {
        var instances = resolver.resolve(model, stmt.children[0]);
        for (var i=0; i < instances.length; i++) {
            instances[i].started = true;
        }
    } catch (err) {
        var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        err.message += ' ('+stmt.type+' '+nameList.join(', ')+')';
        error = err;
    } finally {
        cb(error);
    }
};
},{"../instance-resolver":64}],93:[function(require,module,exports){
var resolver = require('../instance-resolver');

/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    var error = null;
    try {
        var instances = resolver.resolve(model, stmt.children[0]);
        for (var i=0; i < instances.length; i++) {
            instances[i].started = false;
        }
    } catch (err) {
        var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        err.message += ' ('+stmt.type+' '+nameList.join(', ')+')';
        error = err;
    } finally {
        cb(error);
    }
};
},{"../instance-resolver":64}],94:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],95:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],96:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],97:[function(require,module,exports){
var SemVer = require('semver');
var registry = require('kevoree-registry-client');
var kevoree = require('kevoree-library').org.kevoree;
var getFqn = require('../getFQN');

module.exports = function (model, statements, stmt, opts, cb) {
    var tdef;
    var fqn = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var version;

    if (stmt.children[1]) {
        version = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
    }

    if (fqn.split('.').length === 1) {
        // default package to 'org.kevoree.library' for fqn-less TypeDefinitions (ie: add node: JavascriptNode)
        fqn = 'org.kevoree.library.'+fqn;
    }

    if (version) {
        fqn += '/' + version;
    }

    var path = getModelPath(fqn);
    var tdefs = model.select(path).array;
    if (tdefs.length === 0) {
        // retrieve model from registry.kevoree.org because it is not in the current model
        registry.get({ fqns: [fqn] }, function (err, tdefModel) {
            if (err) {
                var errMsg = 'Unable to find "'+fqn+'" in current model nor on Kevoree registry.';
                if (err.code === 'ENOTFOUND') {
                    errMsg += ' (Might it be a connectivity issue?)';
                }
                cb(new Error(errMsg));
                
            } else {
                var factory = new kevoree.factory.DefaultKevoreeFactory();
                var loader = factory.createJSONLoader();
                tdefModel = loader.loadModelFromString(tdefModel).get(0);

                tdefs = tdefModel.select(path).array;
                if (tdefs.length === 0) {
                    cb(new Error('Unable to find "'+fqn+'" on Kevoree registry.'));

                } else {
                    if (tdefs.length === 1) {
                        // there is only one TypeDefinition found, we can merge
                        var compare = factory.createModelCompare();
                        var mergeSeq = compare.merge(model, tdefModel);
                        mergeSeq.applyOn(model);
                        // ...and answer with the newly added TypeDefinition from the registry
                        cb(null, tdefs[0]);
                    } else {
                        // there are more than one TypeDefinition that matches the given fqn on the registry
                        // so lets take the greater version
                        tdef = getBestVersion(tdefs);
                        // ask registry again for a model with this specific TypeDefinition only
                        fqn = getFqn(tdef);
                        registry.get({ fqns : [fqn] }, function (err, tdefModel) {
                            if (err) {
                                cb(new Error('Unable to find "'+fqn+'" on Kevoree registry.'));
                            } else {
                                tdefModel = loader.loadModelFromString(tdefModel).get(0);
                                var compare = factory.createModelCompare();
                                var mergeSeq = compare.merge(model, tdefModel);
                                mergeSeq.applyOn(model);
                                cb(null, tdef);
                            }
                        });
                    }
                }
            }
        });

    } else if (tdefs.length === 1) {
        // there is 1 availability for that TDef
        cb(null, tdefs[0]);
    } else {
        // there are multiple versions of this TDef: take the greater version
        cb(null, getBestVersion(tdefs));
    }
};

function getModelPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = 'packages[' + fqn.join(']/packages[') + ']/typeDefinitions[name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    fqn += ']';

    return fqn;
}

/**
 * Tries to find the greater version (snapshot excluded), if none found, tries to find the greater version
 * snapshots included
 * @param tdefs
 * @returns {*}
 */
function getBestVersion(tdefs) {
    var onlyReleases = tdefs.filter(function (tdef) {
        var v = new SemVer(tdef.version);
        if (v.prerelease.length === 0) {
            return tdef;
        }
    });

    function getGreater(tdefs) {
        var tdef = tdefs[0];
        for (var i=0; i < tdefs.length; i++) {
            if (SemVer.gt(tdefs[i].version, tdef.version)) {
                tdef = tdefs[i];
            }
        }
        return tdef;
    }

    return getGreater((onlyReleases.length === 0) ? tdefs : onlyReleases);
}
},{"../getFQN":63,"kevoree-library":109,"kevoree-registry-client":104,"semver":107}],98:[function(require,module,exports){
// Created by leiko on 27/08/14 15:15
module.exports = function (model, statements, stmt, opts, cb) {
    var typeFqn = [];
    for (var i in stmt.children) {
        if (typeof (stmt.children[i]) === 'string') {
            typeFqn.push(stmt.children[i]);
        } else {
            typeFqn.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts, cb));
        }
    }
    return typeFqn.join('');
};
},{}],99:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
    return stmt.children.join('');
};
},{}],100:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  return stmt.children.join('');
}
},{}],101:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":14}],102:[function(require,module,exports){
module.exports = require('./lib/kotlin');

},{"./lib/kotlin":103}],103:[function(require,module,exports){
'use strict';var Kotlin = {};
(function() {
  function g(a, b) {
    if (null != a && null != b) {
      for (var c in b) {
        b.hasOwnProperty(c) && (a[c] = b[c]);
      }
    }
  }
  function h(a) {
    for (var b = 0;b < a.length;b++) {
      if (null != a[b] && null == a[b].$metadata$ || a[b].$metadata$.type === Kotlin.TYPE.CLASS) {
        return a[b];
      }
    }
    return null;
  }
  function e(a, b, c) {
    for (var f = 0;f < b.length;f++) {
      if (null == b[f] || null != b[f].$metadata$) {
        var d = c(b[f]), k;
        for (k in d) {
          d.hasOwnProperty(k) && (!a.hasOwnProperty(k) || a[k].$classIndex$ < d[k].$classIndex$) && (a[k] = d[k]);
        }
      }
    }
  }
  function d(a, b) {
    var c = {};
    c.baseClasses = null == a ? [] : Array.isArray(a) ? a : [a];
    c.baseClass = h(c.baseClasses);
    c.classIndex = Kotlin.newClassIndex();
    c.functions = {};
    c.properties = {};
    if (null != b) {
      for (var f in b) {
        if (b.hasOwnProperty(f)) {
          var d = b[f];
          d.$classIndex$ = c.classIndex;
          "function" === typeof d ? c.functions[f] = d : c.properties[f] = d;
        }
      }
    }
    e(c.functions, c.baseClasses, function(a) {
      return a.$metadata$.functions;
    });
    e(c.properties, c.baseClasses, function(a) {
      return a.$metadata$.properties;
    });
    return c;
  }
  function a() {
    var a = this.object_initializer$();
    Object.defineProperty(this, "object", {value:a});
    return a;
  }
  function b(a) {
    return "function" === typeof a ? a() : a;
  }
  function c(a, b) {
    if (null != a && null == a.$metadata$ || a.$metadata$.classIndex < b.$metadata$.classIndex) {
      return!1;
    }
    var f = a.$metadata$.baseClasses, d;
    for (d = 0;d < f.length;d++) {
      if (f[d] === b) {
        return!0;
      }
    }
    for (d = 0;d < f.length;d++) {
      if (c(f[d], b)) {
        return!0;
      }
    }
    return!1;
  }
  function f(a, b) {
    return function() {
      if (null !== b) {
        var c = b;
        b = null;
        c.call(a);
      }
      return a;
    };
  }
  function m(a) {
    var b = {};
    if (null == a) {
      return b;
    }
    for (var c in a) {
      a.hasOwnProperty(c) && ("function" === typeof a[c] ? a[c].type === Kotlin.TYPE.INIT_FUN ? (a[c].className = c, Object.defineProperty(b, c, {get:a[c], configurable:!0})) : b[c] = a[c] : Object.defineProperty(b, c, a[c]));
    }
    return b;
  }
  var l = function() {
    return function() {
    };
  };
  Kotlin.TYPE = {CLASS:"class", TRAIT:"trait", OBJECT:"object", INIT_FUN:"init fun"};
  Kotlin.classCount = 0;
  Kotlin.newClassIndex = function() {
    var a = Kotlin.classCount;
    Kotlin.classCount++;
    return a;
  };
  Kotlin.createClassNow = function(b, c, f, e) {
    null == c && (c = l());
    g(c, e);
    b = d(b, f);
    b.type = Kotlin.TYPE.CLASS;
    f = null !== b.baseClass ? Object.create(b.baseClass.prototype) : {};
    Object.defineProperties(f, b.properties);
    g(f, b.functions);
    f.constructor = c;
    null != b.baseClass && (c.baseInitializer = b.baseClass);
    c.$metadata$ = b;
    c.prototype = f;
    Object.defineProperty(c, "object", {get:a, configurable:!0});
    return c;
  };
  Kotlin.createObjectNow = function(a, b, c) {
    a = new (Kotlin.createClassNow(a, b, c));
    a.$metadata$ = {type:Kotlin.TYPE.OBJECT};
    return a;
  };
  Kotlin.createTraitNow = function(b, c, f) {
    var e = function() {
    };
    g(e, f);
    e.$metadata$ = d(b, c);
    e.$metadata$.type = Kotlin.TYPE.TRAIT;
    e.prototype = {};
    Object.defineProperties(e.prototype, e.$metadata$.properties);
    g(e.prototype, e.$metadata$.functions);
    Object.defineProperty(e, "object", {get:a, configurable:!0});
    return e;
  };
  Kotlin.createClass = function(a, c, f, d) {
    function e() {
      var k = Kotlin.createClassNow(b(a), c, f, d);
      Object.defineProperty(this, e.className, {value:k});
      return k;
    }
    e.type = Kotlin.TYPE.INIT_FUN;
    return e;
  };
  Kotlin.createTrait = function(a, c, f) {
    function d() {
      var e = Kotlin.createTraitNow(b(a), c, f);
      Object.defineProperty(this, d.className, {value:e});
      return e;
    }
    d.type = Kotlin.TYPE.INIT_FUN;
    return d;
  };
  Kotlin.createObject = function(a, c, f) {
    return Kotlin.createObjectNow(b(a), c, f);
  };
  Kotlin.callGetter = function(a, b, c) {
    return b.$metadata$.properties[c].get.call(a);
  };
  Kotlin.callSetter = function(a, b, c, f) {
    b.$metadata$.properties[c].set.call(a, f);
  };
  Kotlin.isType = function(a, b) {
    return null == a || null == b ? !1 : a instanceof b ? !0 : null != b && null == b.$metadata$ || b.$metadata$.type == Kotlin.TYPE.CLASS ? !1 : c(a.constructor, b);
  };
  Kotlin.modules = {};
  Kotlin.definePackage = function(a, b) {
    var c = m(b);
    return null === a ? {value:c} : {get:f(c, a)};
  };
  Kotlin.defineRootPackage = function(a, b) {
    var c = m(b);
    c.$initializer$ = null === a ? l() : a;
    return c;
  };
  Kotlin.defineModule = function(a, b) {
    if (a in Kotlin.modules) {
      throw Error("Module " + a + " is already defined");
    }
    b.$initializer$.call(b);
    Object.defineProperty(Kotlin.modules, a, {value:b});
  };
})();
(function() {
  function g(a) {
    return function() {
      throw new TypeError(void 0 !== a ? "Function " + a + " is abstract" : "Function is abstract");
    };
  }
  String.prototype.startsWith = function(a) {
    return 0 === this.indexOf(a);
  };
  String.prototype.endsWith = function(a) {
    return-1 !== this.indexOf(a, this.length - a.length);
  };
  String.prototype.contains = function(a) {
    return-1 !== this.indexOf(a);
  };
  Kotlin.equals = function(a, b) {
    return null == a ? null == b : Array.isArray(a) ? Kotlin.arrayEquals(a, b) : "object" == typeof a && void 0 !== a.equals_za3rmp$ ? a.equals_za3rmp$(b) : a === b;
  };
  Kotlin.toString = function(a) {
    return null == a ? "null" : Array.isArray(a) ? Kotlin.arrayToString(a) : a.toString();
  };
  Kotlin.arrayToString = function(a) {
    return "[" + a.join(", ") + "]";
  };
  Kotlin.intUpto = function(a, b) {
    return new Kotlin.NumberRange(a, b);
  };
  Kotlin.intDownto = function(a, b) {
    return new Kotlin.Progression(a, b, -1);
  };
  Kotlin.RuntimeException = Kotlin.createClassNow();
  Kotlin.NullPointerException = Kotlin.createClassNow();
  Kotlin.NoSuchElementException = Kotlin.createClassNow();
  Kotlin.IllegalArgumentException = Kotlin.createClassNow();
  Kotlin.IllegalStateException = Kotlin.createClassNow();
  Kotlin.UnsupportedOperationException = Kotlin.createClassNow();
  Kotlin.IOException = Kotlin.createClassNow();
  Kotlin.throwNPE = function() {
    throw new Kotlin.NullPointerException;
  };
  Kotlin.Iterator = Kotlin.createClassNow(null, null, {next:g("Iterator#next"), hasNext:g("Iterator#hasNext")});
  var h = Kotlin.createClassNow(Kotlin.Iterator, function(a) {
    this.array = a;
    this.index = 0;
  }, {next:function() {
    return this.array[this.index++];
  }, hasNext:function() {
    return this.index < this.array.length;
  }, remove:function() {
    if (0 > this.index || this.index > this.array.length) {
      throw new RangeError;
    }
    this.index--;
    this.array.splice(this.index, 1);
  }}), e = Kotlin.createClassNow(h, function(a) {
    this.list = a;
    this.size = a.size();
    this.index = 0;
  }, {next:function() {
    return this.list.get(this.index++);
  }});
  Kotlin.Collection = Kotlin.createClassNow();
  Kotlin.Enum = Kotlin.createClassNow(null, function() {
    this.ordinal$ = this.name$ = void 0;
  }, {name:function() {
    return this.name$;
  }, ordinal:function() {
    return this.ordinal$;
  }, toString:function() {
    return this.name();
  }});
  (function() {
    function a(a) {
      return this[a];
    }
    function b() {
      return this.values$;
    }
    Kotlin.createEnumEntries = function(c) {
      var f = 0, d = [], e;
      for (e in c) {
        if (c.hasOwnProperty(e)) {
          var g = c[e];
          d[f] = g;
          g.ordinal$ = f;
          g.name$ = e;
          f++;
        }
      }
      c.values$ = d;
      c.valueOf_61zpoe$ = c.valueOf = a; // FIX because Enum.valueOf() is called instead of valueOf_61zpoe$()
      c.values = b;
      return c;
    };
  })();
  Kotlin.PropertyMetadata = Kotlin.createClassNow(null, function(a) {
    this.name = a;
  });
  Kotlin.AbstractCollection = Kotlin.createClassNow(Kotlin.Collection, null, {addAll_xeylzf$:function(a) {
    var b = !1;
    for (a = a.iterator();a.hasNext();) {
      this.add_za3rmp$(a.next()) && (b = !0);
    }
    return b;
  }, removeAll_xeylzf$:function(a) {
    for (var b = !1, c = this.iterator();c.hasNext();) {
      a.contains_za3rmp$(c.next()) && (c.remove(), b = !0);
    }
    return b;
  }, retainAll_xeylzf$:function(a) {
    for (var b = !1, c = this.iterator();c.hasNext();) {
      a.contains_za3rmp$(c.next()) || (c.remove(), b = !0);
    }
    return b;
  }, containsAll_xeylzf$:function(a) {
    for (a = a.iterator();a.hasNext();) {
      if (!this.contains_za3rmp$(a.next())) {
        return!1;
      }
    }
    return!0;
  }, isEmpty:function() {
    return 0 === this.size();
  }, iterator:function() {
    return new h(this.toArray());
  }, equals_za3rmp$:function(a) {
    if (this.size() !== a.size()) {
      return!1;
    }
    var b = this.iterator();
    a = a.iterator();
    for (var c = this.size();0 < c--;) {
      if (!Kotlin.equals(b.next(), a.next())) {
        return!1;
      }
    }
    return!0;
  }, toString:function() {
    for (var a = "[", b = this.iterator(), c = !0, f = this.size();0 < f--;) {
      c ? c = !1 : a += ", ", a += b.next();
    }
    return a + "]";
  }, toJSON:function() {
    return this.toArray();
  }});
  Kotlin.AbstractList = Kotlin.createClassNow(Kotlin.AbstractCollection, null, {iterator:function() {
    return new e(this);
  }, remove_za3rmp$:function(a) {
    a = this.indexOf_za3rmp$(a);
    return-1 !== a ? (this.remove_za3lpa$(a), !0) : !1;
  }, contains_za3rmp$:function(a) {
    return-1 !== this.indexOf_za3rmp$(a);
  }});
  Kotlin.ArrayList = Kotlin.createClassNow(Kotlin.AbstractList, function() {
    this.array = [];
  }, {get_za3lpa$:function(a) {
    this.checkRange(a);
    return this.array[a];
  },get:function(a){return this.get_za3lpa$(a);}
   , set_vux3hl$:function(a, b) {
    this.checkRange(a);
    this.array[a] = b;
  }, size:function() {
    return this.array.length;
  }, iterator:function() {
    return Kotlin.arrayIterator(this.array);
  }, add_za3rmp$:function(a) {
    this.array.push(a);
    return!0;
  }, add_vux3hl$:function(a, b) {
    this.array.splice(a, 0, b);
  }, addAll_xeylzf$:function(a) {
    var b = a.iterator(), c = this.array.length;
    for (a = a.size();0 < a--;) {
      this.array[c++] = b.next();
    }
  }, remove_za3lpa$:function(a) {
    this.checkRange(a);
    return this.array.splice(a, 1)[0];
  }, clear:function() {
    this.array.length = 0;
  }, indexOf_za3rmp$:function(a) {
    for (var b = 0;b < this.array.length;b++) {
      if (Kotlin.equals(this.array[b], a)) {
        return b;
      }
    }
    return-1;
  }, lastIndexOf_za3rmp$:function(a) {
    for (var b = this.array.length - 1;0 <= b;b--) {
      if (Kotlin.equals(this.array[b], a)) {
        return b;
      }
    }
    return-1;
  }, toArray:function() {
    return this.array.slice(0);
  }, toString:function() {
    return "[" + this.array.join(", ") + "]";
  }, toJSON:function() {
    return this.array;
  }, checkRange:function(a) {
    if (0 > a || a >= this.array.length) {
      throw new RangeError;
    }
  }});
  Kotlin.Runnable = Kotlin.createClassNow(null, null, {run:g("Runnable#run")});
  Kotlin.Comparable = Kotlin.createClassNow(null, null, {compareTo:g("Comparable#compareTo")});
  Kotlin.Appendable = Kotlin.createClassNow(null, null, {append:g("Appendable#append")});
  Kotlin.Closeable = Kotlin.createClassNow(null, null, {close:g("Closeable#close")});
  Kotlin.safeParseInt = function(a) {
    a = parseInt(a, 10);
    return isNaN(a) ? null : a;
  };
  Kotlin.safeParseDouble = function(a) {
    a = parseFloat(a);
    return isNaN(a) ? null : a;
  };
  Kotlin.arrayEquals = function(a, b) {
    if (a === b) {
      return!0;
    }
    if (!Array.isArray(b) || a.length !== b.length) {
      return!1;
    }
    for (var c = 0, f = a.length;c < f;c++) {
      if (!Kotlin.equals(a[c], b[c])) {
        return!1;
      }
    }
    return!0;
  };
  Kotlin.System = function() {
    var a = "", b = function(b) {
      void 0 !== b && (a = null === b || "object" !== typeof b ? a + b : a + b.toString());
    }, c = function(b) {
      this.print(b);
      a += "\n";
    };
    return{out:function() {
      return{print:b, println:c};
    }, output:function() {
      return a;
    }, flush:function() {
      a = "";
    }};
  }();
  Kotlin.println = function(a) {
    Kotlin.System.out().println(a);
  };
  Kotlin.print = function(a) {
    Kotlin.System.out().print(a);
  };
  Kotlin.RangeIterator = Kotlin.createClassNow(Kotlin.Iterator, function(a, b, c) {
    this.start = a;
    this.end = b;
    this.increment = c;
    this.i = a;
  }, {next:function() {
    var a = this.i;
    this.i += this.increment;
    return a;
  }, hasNext:function() {
    return this.i <= this.end;
  }});
  Kotlin.NumberRange = Kotlin.createClassNow(null, function(a, b) {
    this.start = a;
    this.end = b;
    this.increment = 1;
  }, {contains:function(a) {
    return this.start <= a && a <= this.end;
  }, iterator:function() {
    return new Kotlin.RangeIterator(this.start, this.end);
  }});
  Kotlin.Progression = Kotlin.createClassNow(null, function(a, b, c) {
    this.start = a;
    this.end = b;
    this.increment = c;
  }, {iterator:function() {
    return new Kotlin.RangeIterator(this.start, this.end, this.increment);
  }});
  Kotlin.Comparator = Kotlin.createClassNow(null, null, {compare:g("Comparator#compare")});
  var d = Kotlin.createClassNow(Kotlin.Comparator, function(a) {
    this.compare = a;
  });
  Kotlin.comparator = function(a) {
    return new d(a);
  };
  Kotlin.collectionsMax = function(a, b) {
    if (a.isEmpty()) {
      throw Error();
    }
    for (var c = a.iterator(), f = c.next();c.hasNext();) {
      var d = c.next();
      0 > b.compare(f, d) && (f = d);
    }
    return f;
  };
  Kotlin.collectionsSort = function(a, b) {
    var c = void 0;
    void 0 !== b && (c = b.compare.bind(b));
    a instanceof Array && a.sort(c);
    for (var f = [], d = a.iterator();d.hasNext();) {
      f.push(d.next());
    }
    f.sort(c);
    c = 0;
    for (d = f.length;c < d;c++) {
      a.set_vux3hl$(c, f[c]);
    }
  };
  Kotlin.copyToArray = function(a) {
    var b = [];
    for (a = a.iterator();a.hasNext();) {
      b.push(a.next());
    }
    return b;
  };
  Kotlin.StringBuilder = Kotlin.createClassNow(null, function() {
    this.string = "";
  }, {append:function(a) {
    this.string += a.toString();
    return this;
  }, toString:function() {
    return this.string;
  }});
  Kotlin.splitString = function(a, b, c) {
    return a.split(RegExp(b), c);
  };
  Kotlin.nullArray = function(a) {
    for (var b = [];0 < a;) {
      b[--a] = null;
    }
    return b;
  };
  Kotlin.numberArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return 0;
    });
  };
  Kotlin.charArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return "\x00";
    });
  };
  Kotlin.booleanArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return!1;
    });
  };
  Kotlin.arrayFromFun = function(a, b) {
    for (var c = Array(a), d = 0;d < a;d++) {
      c[d] = b(d);
    }
    return c;
  };
  Kotlin.arrayIndices = function(a) {
    return new Kotlin.NumberRange(0, a.length - 1);
  };
  Kotlin.arrayIterator = function(a) {
    return new h(a);
  };
  Kotlin.jsonFromTuples = function(a) {
    for (var b = a.length, c = {};0 < b;) {
      --b, c[a[b][0]] = a[b][1];
    }
    return c;
  };
  Kotlin.jsonAddProperties = function(a, b) {
    for (var c in b) {
      b.hasOwnProperty(c) && (a[c] = b[c]);
    }
    return a;
  };
})();
(function() {
  function g(a) {
    if ("string" == typeof a) {
      return a;
    }
    if ("function" == typeof a.hashCode) {
      return a = a.hashCode(), "string" == typeof a ? a : g(a);
    }
    if ("function" == typeof a.toString) {
      return a.toString();
    }
    try {
      return String(a);
    } catch (b) {
      return Object.prototype.toString.call(a);
    }
  }
  function h(a, b) {
    return a.equals(b);
  }
  function e(a, b) {
    return "function" == typeof b.equals ? b.equals(a) : a === b;
  }
  function d(a) {
    return function(b) {
      if (null === b) {
        throw Error("null is not a valid " + a);
      }
      if ("undefined" == typeof b) {
        throw Error(a + " must not be undefined");
      }
    };
  }
  function a(a, b, c, d) {
    this[0] = a;
    this.entries = [];
    this.addEntry(b, c);
    null !== d && (this.getEqualityFunction = function() {
      return d;
    });
  }
  function b(a) {
    return function(b) {
      for (var c = this.entries.length, d, f = this.getEqualityFunction(b);c--;) {
        if (d = this.entries[c], f(b, d[0])) {
          switch(a) {
            case n:
              return!0;
            case s:
              return d;
            case t:
              return[c, d[1]];
          }
        }
      }
      return!1;
    };
  }
  function c(a) {
    return function(b) {
      for (var c = b.length, d = 0, f = this.entries.length;d < f;++d) {
        b[c + d] = this.entries[d][a];
      }
    };
  }
  function f(b, c) {
    var d = b[c];
    return d && d instanceof a ? d : null;
  }
  var m = "function" == typeof Array.prototype.splice ? function(a, b) {
    a.splice(b, 1);
  } : function(a, b) {
    var c, d, f;
    if (b === a.length - 1) {
      a.length = b;
    } else {
      for (c = a.slice(b + 1), a.length = b, d = 0, f = c.length;d < f;++d) {
        a[b + d] = c[d];
      }
    }
  }, l = d("key"), r = d("value"), n = 0, s = 1, t = 2;
  a.prototype = {getEqualityFunction:function(a) {
    return "function" == typeof a.equals ? h : e;
  }, getEntryForKey:b(s), getEntryAndIndexForKey:b(t), removeEntryForKey:function(a) {
    return(a = this.getEntryAndIndexForKey(a)) ? (m(this.entries, a[0]), a[1]) : null;
  }, addEntry:function(a, b) {
    this.entries[this.entries.length] = [a, b];
  }, keys:c(0), values:c(1), getEntries:function(a) {
    for (var b = a.length, c = 0, d = this.entries.length;c < d;++c) {
      a[b + c] = this.entries[c].slice(0);
    }
  }, containsKey_za3rmp$:b(n), containsValue_za3rmp$:function(a) {
    for (var b = this.entries.length;b--;) {
      if (a === this.entries[b][1]) {
        return!0;
      }
    }
    return!1;
  }};
  var u = function(b, c) {
    var d = this, e = [], h = {}, p = "function" == typeof b ? b : g, n = "function" == typeof c ? c : null;
    this.put_wn2jw4$ = function(b, c) {
      l(b);
      r(c);
      var d = p(b), g, k = null;
      (g = f(h, d)) ? (d = g.getEntryForKey(b)) ? (k = d[1], d[1] = c) : g.addEntry(b, c) : (g = new a(d, b, c, n), e[e.length] = g, h[d] = g);
      return k;
    };
    this.get_za3rmp$ = function(a) {
      l(a);
      var b = p(a);
      if (b = f(h, b)) {
        if (a = b.getEntryForKey(a)) {
          return a[1];
        }
      }
      return null;
    };
    this.containsKey_za3rmp$ = function(a) {
      l(a);
      var b = p(a);
      return(b = f(h, b)) ? b.containsKey_za3rmp$(a) : !1;
    };
    this.containsValue_za3rmp$ = function(a) {
      r(a);
      for (var b = e.length;b--;) {
        if (e[b].containsValue_za3rmp$(a)) {
          return!0;
        }
      }
      return!1;
    };
    this.clear = function() {
      e.length = 0;
      h = {};
    };
    this.isEmpty = function() {
      return!e.length;
    };
    var q = function(a) {
      return function() {
        for (var b = [], c = e.length;c--;) {
          e[c][a](b);
        }
        return b;
      };
    };
    this._keys = q("keys");
    this._values = q("values");
    this._entries = q("getEntries");
    this.values = function() {
      for (var a = this._values(), b = a.length, c = new Kotlin.ArrayList;b--;) {
        c.add_za3rmp$(a[b]);
      }
      return c;
    };
    this.remove_za3rmp$ = function(a) {
      l(a);
      var b = p(a), c = null, d = f(h, b);
      if (d && (c = d.removeEntryForKey(a), null !== c && !d.entries.length)) {
        a: {
          for (a = e.length;a--;) {
            if (d = e[a], b === d[0]) {
              break a;
            }
          }
          a = null;
        }
        m(e, a);
        delete h[b];
      }
      return c;
    };
    this.size = function() {
      for (var a = 0, b = e.length;b--;) {
        a += e[b].entries.length;
      }
      return a;
    };
    this.each = function(a) {
      for (var b = d._entries(), c = b.length, e;c--;) {
        e = b[c], a(e[0], e[1]);
      }
    };
    this.putAll_za3j1t$ = function(a, b) {
      for (var c = a._entries(), e, f, g, h = c.length, k = "function" == typeof b;h--;) {
        e = c[h], f = e[0], e = e[1], k && (g = d.get(f)) && (e = b(f, g, e)), d.put_wn2jw4$(f, e);
      }
    };
    this.clone = function() {
      var a = new u(b, c);
      a.putAll_za3j1t$(d);
      return a;
    };
    this.keySet = function() {
      for (var a = new Kotlin.ComplexHashSet, b = this._keys(), c = b.length;c--;) {
        a.add_za3rmp$(b[c]);
      }
      return a;
    };
  };
  Kotlin.HashTable = u;
})();
Kotlin.Map = Kotlin.createClassNow();
Kotlin.HashMap = Kotlin.createClassNow(Kotlin.Map, function() {
  Kotlin.HashTable.call(this);
});
Kotlin.ComplexHashMap = Kotlin.HashMap;
(function() {
  var g = Kotlin.createClassNow(Kotlin.Iterator, function(e, d) {
    this.map = e;
    this.keys = d;
    this.size = d.length;
    this.index = 0;
  }, {next:function() {
    return this.map[this.keys[this.index++]];
  }, hasNext:function() {
    return this.index < this.size;
  }}), h = Kotlin.createClassNow(Kotlin.Collection, function(e) {
    this.map = e;
  }, {iterator:function() {
    return new g(this.map.map, Object.keys(this.map.map));
  }, isEmpty:function() {
    return 0 === this.map.$size;
  }, contains:function(e) {
    return this.map.containsValue_za3rmp$(e);
  }});
  Kotlin.PrimitiveHashMap = Kotlin.createClassNow(Kotlin.Map, function() {
    this.$size = 0;
    this.map = {};
  }, {size:function() {
    return this.$size;
  }, isEmpty:function() {
    return 0 === this.$size;
  }, containsKey_za3rmp$:function(e) {
    return void 0 !== this.map[e];
  }, containsValue_za3rmp$:function(e) {
    var d = this.map, a;
    for (a in d) {
      if (d.hasOwnProperty(a) && d[a] === e) {
        return!0;
      }
    }
    return!1;
  }, get_za3rmp$:function(e) {
    return this.map[e];
  }, put_wn2jw4$:function(e, d) {
    var a = this.map[e];
    this.map[e] = void 0 === d ? null : d;
    void 0 === a && this.$size++;
    return a;
  }, remove_za3rmp$:function(e) {
    var d = this.map[e];
    void 0 !== d && (delete this.map[e], this.$size--);
    return d;
  }, clear:function() {
    this.$size = 0;
    this.map = {};
  }, putAll_za3j1t$:function(e) {
    e = e.map;
    for (var d in e) {
      e.hasOwnProperty(d) && (this.map[d] = e[d], this.$size++);
    }
  }, keySet:function() {
    var e = new Kotlin.PrimitiveHashSet, d = this.map, a;
    for (a in d) {
      d.hasOwnProperty(a) && e.add_za3rmp$(a);
    }
    return e;
  }, values:function() {
    return new h(this);
  }, toJSON:function() {
    return this.map;
  }});
})();
Kotlin.Set = Kotlin.createClassNow(Kotlin.Collection);
var SetIterator = Kotlin.createClassNow(Kotlin.Iterator, function(g) {
  this.set = g;
  this.keys = g.toArray();
  this.index = 0;
}, {next:function() {
  return this.keys[this.index++];
}, hasNext:function() {
  return this.index < this.keys.length;
}, remove:function() {
  this.set.remove_za3rmp$(this.keys[this.index - 1]);
}});
Kotlin.PrimitiveHashSet = Kotlin.createClassNow(Kotlin.AbstractCollection, function() {
  this.$size = 0;
  this.map = {};
}, {contains_s9cetl$:function(g) {
  return!0 === this.map[g];
}, iterator:function() {
  return new SetIterator(this);
}, size:function() {
    return this.$size;
}, add_za3rmp$:function(g) {
  var h = this.map[g];
  this.map[g] = !0;
  if (!0 === h) {
    return!1;
  }
  this.$size++;
  return!0;
}, remove_za3rmp$:function(g) {
  return!0 === this.map[g] ? (delete this.map[g], this.$size--, !0) : !1;
}, clear:function() {
  this.$size = 0;
  this.map = {};
}, toArray:function() {
  return Object.keys(this.map);
}});
(function() {
  function g(h, e) {
    var d = new Kotlin.HashTable(h, e);
    this.addAll_xeylzf$ = Kotlin.AbstractCollection.prototype.addAll_xeylzf$;
    this.removeAll_xeylzf$ = Kotlin.AbstractCollection.prototype.removeAll_xeylzf$;
    this.retainAll_xeylzf$ = Kotlin.AbstractCollection.prototype.retainAll_xeylzf$;
    this.containsAll_xeylzf$ = Kotlin.AbstractCollection.prototype.containsAll_xeylzf$;
    this.add_za3rmp$ = function(a) {
      return!d.put_wn2jw4$(a, !0);
    };
    this.toArray = function() {
      return d._keys();
    };
    this.iterator = function() {
      return new SetIterator(this);
    };
    this.remove_za3rmp$ = function(a) {
      return null != d.remove_za3rmp$(a);
    };
    this.contains_za3rmp$ = function(a) {
      return d.containsKey_za3rmp$(a);
    };
    this.clear = function() {
      d.clear();
    };
    this.size = function() {
      return d.size();
    };
    this.isEmpty = function() {
      return d.isEmpty();
    };
    this.clone = function() {
      var a = new g(h, e);
      a.addAll_xeylzf$(d.keys());
      return a;
    };
    this.equals = function(a) {
      if (null === a || void 0 === a) {
        return!1;
      }
      if (this.size() === a.size()) {
        var b = this.iterator();
        for (a = a.iterator();;) {
          var c = b.hasNext(), d = a.hasNext();
          if (c != d) {
            break;
          }
          if (d) {
            if (c = b.next(), d = a.next(), !Kotlin.equals(c, d)) {
              break;
            }
          } else {
            return!0;
          }
        }
      }
      return!1;
    };
    this.toString = function() {
      for (var a = "[", b = this.iterator(), c = !0;b.hasNext();) {
        c ? c = !1 : a += ", ", a += b.next();
      }
      return a + "]";
    };
    this.intersection = function(a) {
      var b = new g(h, e);
      a = a.values();
      for (var c = a.length, f;c--;) {
        f = a[c], d.containsKey_za3rmp$(f) && b.add_za3rmp$(f);
      }
      return b;
    };
    this.union = function(a) {
      var b = this.clone();
      a = a.values();
      for (var c = a.length, e;c--;) {
        e = a[c], d.containsKey_za3rmp$(e) || b.add_za3rmp$(e);
      }
      return b;
    };
    this.isSubsetOf = function(a) {
      for (var b = d.keys(), c = b.length;c--;) {
        if (!a.contains_za3rmp$(b[c])) {
          return!1;
        }
      }
      return!0;
    };
  }
  Kotlin.HashSet = Kotlin.createClassNow(Kotlin.Set, function() {
    g.call(this);
  });
  Kotlin.ComplexHashSet = Kotlin.HashSet;
})();
module.exports = Kotlin;
},{}],104:[function(require,module,exports){
// Created by leiko on 09/09/14 15:23
module.exports.get = require('./lib/get');
module.exports.post = require('./lib/post');
},{"./lib/get":105,"./lib/post":106}],105:[function(require,module,exports){
// Created by leiko on 09/09/14 15:23
var http = require('http');

/**
 *
 * @param {Object}   options    - fqns:      Fully Qualified Names of Packages/DeployUnits/TypeDefinitions
 *                                           (e.g 'org.kevoree.library.js.JavascriptNode')
 *                              - [version]: TypeDefinition version (if version is not given, then '*' will be used)
 *                              - [type]:    Retrieved model type (default to 'json', but you can ask for 'xmi'
 *                                           or 'trace')
 *                              - [parse]:   If set to true, it will parse the last part of the fqn to get the
 *                                           TypeDefinition name from it (default: true)
 *                              - [kevPath]: Boolean to tell whether or not the fqns should be parsed or if they are
 *                                           already Kevoree model paths (default: false).
 *                                           e.g  options.kevPath = true
 *                                                => fqns array is supposed to contain real Kevoree model paths
 *                              - [host]:    Hostname of the request (default: 'registry.kevoree.org')
 *                              - [port]:    Port of the request (default: 80)
 * @param {Function} callback
 */
function fromFQN(options, callback) {
    options.type    = options.type  || 'json';
    options.host    = options.host  || 'registry.kevoree.org';
    options.port    = options.port  || 80;

    var reqOpts = {
        hostname: options.host,
        port: options.port,
        headers: {},
        withCredentials: false
    };

    var fqn, fqns = [];
    if (options.kevPath) {
        fqns = JSON.stringify(options.fqns);
        reqOpts.method = 'POST';
        reqOpts.path = '/';
        reqOpts.headers['Content-Type'] = 'text/plain';
        reqOpts.headers['Content-Length'] = fqns.length;
    } else {
        if (options.fqns.length === 1) {
            // using GET method
            fqn = getUrlPath(options.fqns[0]);

            reqOpts.method = 'GET';
            reqOpts.path = '/' + fqn;
            reqOpts.headers.Accept = (function () {
                switch (options.type) {
                    default:
                    case 'json':
                        return 'application/json';

                    case 'xmi':
                        return 'application/vnd.xmi+xml';

                    case 'trace':
                        return 'text/plain';
                }
            })();
        } else {
            // multiple FQN => need to use POST method
            fqns = JSON.stringify(options.fqns.map(function (fqn) {
                return getModelPath(fqn);
            }));

            reqOpts.method = 'POST';
            reqOpts.path = '/';
            reqOpts.headers['Content-Type'] = 'text/plain';
            reqOpts.headers['Content-Length'] = fqns.length;
        }
    }

    var req = http.request(reqOpts, function (res) {
        switch (res.statusCode) {
            case 200:
                var data = '';
                res.on('data', function (chunk) { data += chunk; });
                res.on('end', function () {
                    switch (res.headers['content-type']) {
                        case 'application/json':
                            callback(null, data);
                            break;

                        case 'application/vnd.xmi+xml':
                        case 'text/plain':
                            callback(null, data);
                            break;

                        default:
                            callback(new Error('Response content MIME Type should be "'+reqOpts.headers.Accept+'" ' +
                                '(and not "'+res.headers['content-type']+'")'));
                            break;
                    }
                });
                break;

            case 404:
                callback(new Error('Unable to find "'+options.fqns+'" on Kevoree registry'));
                break;

            default:
            case 500:
                callback(new Error('Server error'));
                break;
        }
    }).on('error', function (err) {
        callback(err);
    });

    if (fqns.length > 1) {
        req.write(fqns);
    }

    req.end();
}

function getModelPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = 'packages[' + fqn.join(']/packages[') + ']/*[name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    fqn += ']';

    return fqn;
}

function getUrlPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = fqn.join('/');
    fqn += '/name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    return fqn;
}

module.exports = fromFQN;
},{"http":7}],106:[function(require,module,exports){
// Created by leiko on 09/09/14 15:24
var http = require('http');

/**
 *
 * @param {Object}   options    - model   String representation of the model to push (JSON, xmi or trace)
 *                              - [type]  String for the Content-Type of your model (default: json)
 *                                        This "type" can be [json, xmi, trace]
 *                              - [host]  Hostname of the request (default: 'registry.kevoree.org')
 *                              - [port]  Port of the request (default: 80)
 * @param {Function} callback
 */
function pushModel(options, callback) {
    options.type = options.type || 'json';
    options.host = options.host || 'registry.kevoree.org';
    options.port = options.port || 80;


    var reqOpts = {
        hostname: options.host,
        port: options.port,
        path: '/deploy',
        method: 'POST',
        headers: {
            'Content-Type': (function () {
                switch (options.type) {
                    default:
                    case 'json':
                        return 'application/json';
                    case 'xmi':
                        return 'application/vnd.xmi+xml';
                    case 'trace':
                        return 'text/plain';
                }
            })(),
            'Content-Length': options.model.length
        }
    };

    var req = http.request(reqOpts, function (res) {
        switch (res.statusCode) {
            case 201:
                callback(null);
                break;

            case 406:
                callback(new Error('Unable to process model type "'+reqOpts.headers['Content-Type']+'" on registry'));
                break;

            default:
            case 500:
                callback(new Error('Server error'));
                break;
        }
    }).on('error', function (err) {
        callback(err);
    });

    req.write(options.model);
    req.end();
}

module.exports = pushModel;
},{"http":7}],107:[function(require,module,exports){
;(function(exports) {

// export the class if we are in a Node-like system.
if (typeof module === 'object' && module.exports === exports)
  exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  ;
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  ;
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      return (/^[0-9]+$/.test(id)) ? +id : id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.inspect = function() {
  return '<SemVer "' + this + '">';
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  ;
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    ;
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(b);
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  ;
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  ;
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.inspect = function() {
  return '<SemVer Comparator "' + this + '">';
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  ;

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};


exports.Range = Range;
function Range(range, loose) {
  if ((range instanceof Range) && range.loose === loose)
    return range;

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.inspect = function() {
  return '<SemVer Range "' + this.range + '">';
};

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  ;
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  ;
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  ;

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  ;
  comp = replaceCarets(comp, loose);
  ;
  comp = replaceTildes(comp, loose);
  ;
  comp = replaceXRanges(comp, loose);
  ;
  comp = replaceStars(comp, loose);
  ;
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    ;
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0- <1.3.0-
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      ;
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    ;
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  ;
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    ;
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      ;
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      ;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    ;
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  ;
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    ;
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm)
          M = +M + 1
        else
          m = +m + 1
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    ;

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  ;
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      ;
      if (set[i].semver === ANY)
        return true;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  return versions.filter(function(version) {
    return satisfies(version, range, loose);
  }).sort(function(a, b) {
    return rcompare(a, b, loose);
  })[0] || null;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

// Use the define() function if we're in AMD land
if (typeof define === 'function' && define.amd)
  define(exports);

})(
  typeof exports === 'object' ? exports :
  typeof define === 'function' && define.amd ? {} :
  semver = {}
);

},{}],108:[function(require,module,exports){
var waxeye;
/*
# Waxeye Parser Generator
# www.waxeye.org
# Copyright (C) 2008-2010 Orlando Hill
# Licensed under the MIT license. See 'LICENSE' for details.
*/
waxeye = (function() {
  var AST, Edge, FA, InnerParser, ParseError, State, WaxeyeParser, namespace;
  Edge = function(_a, _b, _c) {
    this.voided = _c;
    this.state = _b;
    this.trans = _a;
    return this;
  };
  State = function(_a, _b) {
    this.match = _b;
    this.edges = _a;
    return this;
  };
  FA = function(_a, _b, _c) {
    this.mode = _c;
    this.states = _b;
    this.type = _a;
    return this;
  };
  FA.VOID = 0;
  FA.PRUNE = 1;
  FA.LEFT = 2;
  FA.POS = 3;
  FA.NEG = 4;
  ParseError = function(_a, _b, _c, _d) {
    this.nt = _d;
    this.col = _c;
    this.line = _b;
    this.pos = _a;
    return this;
  };
  ParseError.prototype.toString = function() {
    return "parse error: failed to match '" + this.nt + "' at line=" + this.line + ", col=" + this.col + ", pos=" + this.pos;
  };
  AST = function(_a, _b, _c) {
    this.pos = _c;
    this.children = _b;
    this.type = _a;
    return this;
  };
  AST.prototype.toString = function() {
    var acc, indent, toStringIter;
    acc = "";
    indent = 0;
    toStringIter = function(ast) {
      var _a, _b, _c, a, i;
      i = 0;
      while (i < indent - 1) {
        acc += '    ';
        i++;
      }
      indent > 0 ? acc += '->  ' : null;
      acc += ast.type;
      indent++;
      _b = ast.children;
      for (_a = 0, _c = _b.length; _a < _c; _a++) {
        a = _b[_a];
        acc += '\n';
        if ((typeof a) === 'string') {
          i = 0;
          while (i < indent - 1) {
            acc += '    ';
            i++;
          }
          indent > 0 ? acc += '|   ' : null;
          acc += a;
        } else {
          toStringIter(a);
        }
      }
      indent--;
      return acc;
    };
    return toStringIter(this);
  };
  WaxeyeParser = function(_a, _b, _c) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    return this;
  };
  WaxeyeParser.prototype.parse = function(input) {
    return new InnerParser(this.start, this.eofCheck, this.automata, input).parse();
  };
  InnerParser = function(_a, _b, _c, input) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    this.input = input;
    this.inputLen = input.length;
    this.inputPos = 0;
    this.line = 1;
    this.column = 0;
    this.lastCR = false;
    this.errorPos = 0;
    this.errorLine = 1;
    this.errorCol = 0;
    this.errorNT = this.automata[this.start].type;
    this.faStack = [];
    this.cache = {};
    return this;
  };
  InnerParser.prototype.parse = function() {
    return this.doEOFCheck(this.matchAutomaton(this.start));
  };
  InnerParser.prototype.matchAutomaton = function(index) {
    var _a, automaton, cached, key, mode, res, startCR, startCol, startLine, startPos, type, value;
    startPos = this.inputPos;
    key = ("" + index + "," + startPos);
    cached = this.cache[key];
    if (typeof cached !== "undefined" && cached !== null) {
      this.restorePos(cached[1], cached[2], cached[3], cached[4]);
      return cached[0];
    }
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    automaton = this.automata[index];
    type = automaton.type;
    mode = automaton.mode;
    this.faStack.push(automaton);
    res = this.matchState(0);
    this.faStack.pop();
    value = (function() {
      if (mode === FA.POS) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          return true;
        } else {
          this.updateError();
          return false;
        }
      } else if (mode === FA.NEG) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          this.updateError();
          return false;
        } else {
          return true;
        }
      } else {
        if (res) {
          if (mode === FA.VOID) {
            return true;
          } else if (mode === FA.PRUNE) {
            if ((_a = res.length) === 0) {
              return true;
            } else if (_a === 1) {
              return res[0];
            } else {
              return new AST(type, res, [startPos, this.inputPos]);
            }
          } else {
            return new AST(type, res, [startPos, this.inputPos]);
          }
        } else {
          return this.updateError();
        }
      }
    }).call(this);
    this.cache[key] = [value, this.inputPos, this.line, this.column, this.lastCR];
    return value;
  };
  InnerParser.prototype.matchState = function(index) {
    var res, state;
    state = this.faStack[this.faStack.length - 1].states[index];
    res = this.matchEdges(state.edges, 0);
    return res ? res : state.match && [];
  };
  InnerParser.prototype.matchEdges = function(edges, index) {
    var res;
    if (index === edges.length) {
      return false;
    } else {
      res = this.matchEdge(edges[index]);
      return res ? res : this.matchEdges(edges, (index + 1));
    }
  };
  InnerParser.prototype.matchEdge = function(edge) {
    var res, startCR, startCol, startLine, startPos, t, tranRes;
    startPos = this.inputPos;
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    t = edge.trans;
    res = t === -1 ? this.inputPos < this.inputLen ? this.mv() : this.updateError() : typeof t === 'string' ? this.inputPos < this.inputLen && t === this.input[this.inputPos] ? this.mv() : this.updateError() : t instanceof Array ? this.inputPos < this.inputLen && this.withinSet(t, 0, (this.input[this.inputPos].charCodeAt(0))) ? this.mv() : this.updateError() : typeof t === 'number' ? this.matchAutomaton(t) : false;
    if (res) {
      tranRes = this.matchState(edge.state);
      if (tranRes) {
        return edge.voided || res === true ? tranRes : [res].concat(tranRes);
      } else {
        this.restorePos(startPos, startLine, startCol, startCR);
        return false;
      }
    } else {
      return false;
    }
  };
  InnerParser.prototype.restorePos = function(pos, line, col, cr) {
    this.inputPos = pos;
    this.line = line;
    this.column = col;
    return (this.lastCR = cr);
  };
  InnerParser.prototype.updateError = function() {
    if (this.errorPos < this.inputPos) {
      this.errorPos = this.inputPos;
      this.errorLine = this.line;
      this.errorCol = this.column;
      this.errorNT = this.faStack[this.faStack.length - 1].type;
    }
    return false;
  };
  InnerParser.prototype.mv = function() {
    var ch;
    ch = this.input[this.inputPos];
    this.inputPos++;
    if (ch === '\r') {
      this.line++;
      this.column = 0;
      this.lastCR = true;
    } else {
      if (ch === '\n') {
        if (!this.lastCR) {
          this.line++;
          this.column = 0;
        }
      } else {
        this.column++;
      }
      this.lastCR = false;
    }
    return ch;
  };
  InnerParser.prototype.doEOFCheck = function(res) {
    return res ? this.eofCheck && this.inputPos < this.inputLen ? new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT) : res : new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT);
  };
  InnerParser.prototype.withinSet = function(set, index, c) {
    var aa;
    if (index === set.length) {
      return false;
    } else {
      aa = set[index];
      return typeof aa === 'string' ? (aa.charCodeAt(0)) === c ? true : (aa.charCodeAt(0)) < c ? this.withinSet(set, index + 1, c) : false : c >= aa[0] && c <= aa[1] ? true : c > aa[1] ? this.withinSet(set, index + 1, c) : false;
    }
  };
  namespace = {
    Edge: Edge,
    State: State,
    FA: FA,
    ParseError: ParseError,
    AST: AST,
    WaxeyeParser: WaxeyeParser
  };
  return namespace;
})();
if (typeof module !== "undefined" && module !== null) {
  module.exports.AST = waxeye.AST;
  module.exports.Edge = waxeye.Edge;
  module.exports.FA = waxeye.FA;
  module.exports.ParseError = waxeye.ParseError;
  module.exports.State = waxeye.State;
  module.exports.WaxeyeParser = waxeye.WaxeyeParser;
}
},{}],109:[function(require,module,exports){
(function (global){
if (!global.Kotlin) {
    global.Kotlin = require('kevoree-kotlin');
}
var Kotlin = global.Kotlin;

if (!Kotlin.modules['kevoree']) {
  var _ = Kotlin.defineRootPackage(null, /** @lends _ */ {
    org: Kotlin.definePackage(null, /** @lends _.org */ {
      kevoree: Kotlin.definePackage(null, /** @lends _.org.kevoree */ {
        DataType: Kotlin.createClass(function () {
          return [Kotlin.Enum];
        }, function $fun() {
          $fun.baseInitializer.call(this);
        }, null, /** @lends _.org.kevoree.DataType */ {
          object_initializer$: function () {
            return Kotlin.createEnumEntries({
              BYTE: new _.org.kevoree.DataType(),
              SHORT: new _.org.kevoree.DataType(),
              INT: new _.org.kevoree.DataType(),
              LONG: new _.org.kevoree.DataType(),
              FLOAT: new _.org.kevoree.DataType(),
              DOUBLE: new _.org.kevoree.DataType(),
              BOOLEAN: new _.org.kevoree.DataType(),
              CHAR: new _.org.kevoree.DataType(),
              STRING: new _.org.kevoree.DataType()
            });
          }
        }),
        ComponentInstance: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ComponentInstance.prototype */ {
          provided: {
            get: function () {
              return this.$provided_2hpw3s$;
            },
            set: function (tmp$0) {
              this.$provided_2hpw3s$ = tmp$0;
            }
          },
          required: {
            get: function () {
              return this.$required_7c57n8$;
            },
            set: function (tmp$0) {
              this.$required_7c57n8$ = tmp$0;
            }
          }
        }),
        Instance: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Instance.prototype */ {
          started: {
            get: function () {
              return this.$started_sh883l$;
            },
            set: function (tmp$0) {
              this.$started_sh883l$ = tmp$0;
            }
          },
          typeDefinition: {
            get: function () {
              return this.$typeDefinition_ezyus3$;
            },
            set: function (tmp$0) {
              this.$typeDefinition_ezyus3$ = tmp$0;
            }
          },
          dictionary: {
            get: function () {
              return this.$dictionary_pt7ca2$;
            },
            set: function (tmp$0) {
              this.$dictionary_pt7ca2$ = tmp$0;
            }
          },
          fragmentDictionary: {
            get: function () {
              return this.$fragmentDictionary_6cu6ii$;
            },
            set: function (tmp$0) {
              this.$fragmentDictionary_6cu6ii$ = tmp$0;
            }
          },
          metaData: {
            get: function () {
              return this.$metaData_18932n$;
            },
            set: function (tmp$0) {
              this.$metaData_18932n$ = tmp$0;
            }
          }
        }),
        Port: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Port.prototype */ {
          bindings: {
            get: function () {
              return this.$bindings_5hhece$;
            },
            set: function (tmp$0) {
              this.$bindings_5hhece$ = tmp$0;
            }
          },
          portTypeRef: {
            get: function () {
              return this.$portTypeRef_mhir4s$;
            },
            set: function (tmp$0) {
              this.$portTypeRef_mhir4s$ = tmp$0;
            }
          }
        }),
        ComponentType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ComponentType.prototype */ {
          required: {
            get: function () {
              return this.$required_oda9db$;
            },
            set: function (tmp$0) {
              this.$required_oda9db$ = tmp$0;
            }
          },
          provided: {
            get: function () {
              return this.$provided_ejf5mb$;
            },
            set: function (tmp$0) {
              this.$provided_ejf5mb$ = tmp$0;
            }
          }
        }),
        TypeDefinition: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.TypeDefinition.prototype */ {
          version: {
            get: function () {
              return this.$version_tm0unk$;
            },
            set: function (tmp$0) {
              this.$version_tm0unk$ = tmp$0;
            }
          },
          abstract: {
            get: function () {
              return this.$abstract_ez9r92$;
            },
            set: function (tmp$0) {
              this.$abstract_ez9r92$ = tmp$0;
            }
          },
          deployUnits: {
            get: function () {
              return this.$deployUnits_y68grk$;
            },
            set: function (tmp$0) {
              this.$deployUnits_y68grk$ = tmp$0;
            }
          },
          superTypes: {
            get: function () {
              return this.$superTypes_dv6lpi$;
            },
            set: function (tmp$0) {
              this.$superTypes_dv6lpi$ = tmp$0;
            }
          },
          dictionaryType: {
            get: function () {
              return this.$dictionaryType_vkfvko$;
            },
            set: function (tmp$0) {
              this.$dictionaryType_vkfvko$ = tmp$0;
            }
          },
          metaData: {
            get: function () {
              return this.$metaData_jxmodz$;
            },
            set: function (tmp$0) {
              this.$metaData_jxmodz$ = tmp$0;
            }
          }
        }),
        PortTypeRef: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortTypeRef.prototype */ {
          optional: {
            get: function () {
              return this.$optional_x07kgh$;
            },
            set: function (tmp$0) {
              this.$optional_x07kgh$ = tmp$0;
            }
          },
          noDependency: {
            get: function () {
              return this.$noDependency_t9zxol$;
            },
            set: function (tmp$0) {
              this.$noDependency_t9zxol$ = tmp$0;
            }
          },
          ref: {
            get: function () {
              return this.$ref_yibe1w$;
            },
            set: function (tmp$0) {
              this.$ref_yibe1w$ = tmp$0;
            }
          },
          mappings: {
            get: function () {
              return this.$mappings_sheb7w$;
            },
            set: function (tmp$0) {
              this.$mappings_sheb7w$ = tmp$0;
            }
          }
        }),
        ContainerNode: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ContainerNode.prototype */ {
          components: {
            get: function () {
              return this.$components_easq5i$;
            },
            set: function (tmp$0) {
              this.$components_easq5i$ = tmp$0;
            }
          },
          hosts: {
            get: function () {
              return this.$hosts_f0e4hl$;
            },
            set: function (tmp$0) {
              this.$hosts_f0e4hl$ = tmp$0;
            }
          },
          host: {
            get: function () {
              return this.$host_fjzar0$;
            },
            set: function (tmp$0) {
              this.$host_fjzar0$ = tmp$0;
            }
          },
          groups: {
            get: function () {
              return this.$groups_vg5qvs$;
            },
            set: function (tmp$0) {
              this.$groups_vg5qvs$ = tmp$0;
            }
          },
          networkInformation: {
            get: function () {
              return this.$networkInformation_nv4882$;
            },
            set: function (tmp$0) {
              this.$networkInformation_nv4882$ = tmp$0;
            }
          }
        }),
        Group: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Group.prototype */ {
          subNodes: {
            get: function () {
              return this.$subNodes_lc0dmh$;
            },
            set: function (tmp$0) {
              this.$subNodes_lc0dmh$ = tmp$0;
            }
          }
        }),
        NetworkInfo: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.NetworkInfo.prototype */ {
          values: {
            get: function () {
              return this.$values_itr2zx$;
            },
            set: function (tmp$0) {
              this.$values_itr2zx$ = tmp$0;
            }
          }
        }),
        ContainerRoot: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ContainerRoot.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_ejvotm$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_ejvotm$ = tmp$0;
            }
          },
          nodes: {
            get: function () {
              return this.$nodes_c2xjm5$;
            },
            set: function (tmp$0) {
              this.$nodes_c2xjm5$ = tmp$0;
            }
          },
          repositories: {
            get: function () {
              return this.$repositories_z79tl8$;
            },
            set: function (tmp$0) {
              this.$repositories_z79tl8$ = tmp$0;
            }
          },
          hubs: {
            get: function () {
              return this.$hubs_6hj9z2$;
            },
            set: function (tmp$0) {
              this.$hubs_6hj9z2$ = tmp$0;
            }
          },
          mBindings: {
            get: function () {
              return this.$mBindings_gns4jb$;
            },
            set: function (tmp$0) {
              this.$mBindings_gns4jb$ = tmp$0;
            }
          },
          groups: {
            get: function () {
              return this.$groups_g3uzy0$;
            },
            set: function (tmp$0) {
              this.$groups_g3uzy0$ = tmp$0;
            }
          },
          packages: {
            get: function () {
              return this.$packages_1mi63z$;
            },
            set: function (tmp$0) {
              this.$packages_1mi63z$ = tmp$0;
            }
          }
        }),
        Repository: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Repository.prototype */ {
          url: {
            get: function () {
              return this.$url_htkyl8$;
            },
            set: function (tmp$0) {
              this.$url_htkyl8$ = tmp$0;
            }
          }
        }),
        Channel: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Channel.prototype */ {
          bindings: {
            get: function () {
              return this.$bindings_ty2776$;
            },
            set: function (tmp$0) {
              this.$bindings_ty2776$ = tmp$0;
            }
          }
        }),
        MBinding: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.MBinding.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_fziggz$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_fziggz$ = tmp$0;
            }
          },
          port: {
            get: function () {
              return this.$port_6otxb6$;
            },
            set: function (tmp$0) {
              this.$port_6otxb6$ = tmp$0;
            }
          },
          hub: {
            get: function () {
              return this.$hub_ijo8js$;
            },
            set: function (tmp$0) {
              this.$hub_ijo8js$ = tmp$0;
            }
          }
        }),
        Package: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Package.prototype */ {
          packages: {
            get: function () {
              return this.$packages_v2u0ry$;
            },
            set: function (tmp$0) {
              this.$packages_v2u0ry$ = tmp$0;
            }
          },
          typeDefinitions: {
            get: function () {
              return this.$typeDefinitions_exad6t$;
            },
            set: function (tmp$0) {
              this.$typeDefinitions_exad6t$ = tmp$0;
            }
          },
          deployUnits: {
            get: function () {
              return this.$deployUnits_xu9pd3$;
            },
            set: function (tmp$0) {
              this.$deployUnits_xu9pd3$ = tmp$0;
            }
          }
        }),
        NamedElement: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.NamedElement.prototype */ {
          name: {
            get: function () {
              return this.$name_mc5v37$;
            },
            set: function (tmp$0) {
              this.$name_mc5v37$ = tmp$0;
            }
          }
        }),
        DeployUnit: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DeployUnit.prototype */ {
          version: {
            get: function () {
              return this.$version_m3ipvy$;
            },
            set: function (tmp$0) {
              this.$version_m3ipvy$ = tmp$0;
            }
          },
          hashcode: {
            get: function () {
              return this.$hashcode_a0cemd$;
            },
            set: function (tmp$0) {
              this.$hashcode_a0cemd$ = tmp$0;
            }
          },
          url: {
            get: function () {
              return this.$url_i45wyt$;
            },
            set: function (tmp$0) {
              this.$url_i45wyt$ = tmp$0;
            }
          },
          filters: {
            get: function () {
              return this.$filters_25emcx$;
            },
            set: function (tmp$0) {
              this.$filters_25emcx$ = tmp$0;
            }
          },
          requiredLibs: {
            get: function () {
              return this.$requiredLibs_vqdz55$;
            },
            set: function (tmp$0) {
              this.$requiredLibs_vqdz55$ = tmp$0;
            }
          }
        }),
        PortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortType.prototype */ {
          synchrone: {
            get: function () {
              return this.$synchrone_81cijd$;
            },
            set: function (tmp$0) {
              this.$synchrone_81cijd$ = tmp$0;
            }
          }
        }),
        Dictionary: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Dictionary.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_4n99az$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_4n99az$ = tmp$0;
            }
          },
          values: {
            get: function () {
              return this.$values_relsch$;
            },
            set: function (tmp$0) {
              this.$values_relsch$ = tmp$0;
            }
          }
        }),
        Value: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Value.prototype */ {
          value: {
            get: function () {
              return this.$value_mehebp$;
            },
            set: function (tmp$0) {
              this.$value_mehebp$ = tmp$0;
            }
          }
        }),
        FragmentDictionary: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.Dictionary, _.org.kevoree.modeling.api.KMFContainer];
        }),
        DictionaryType: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DictionaryType.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_i5cet1$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_i5cet1$ = tmp$0;
            }
          },
          attributes: {
            get: function () {
              return this.$attributes_ajawmc$;
            },
            set: function (tmp$0) {
              this.$attributes_ajawmc$ = tmp$0;
            }
          }
        }),
        DictionaryAttribute: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DictionaryAttribute.prototype */ {
          optional: {
            get: function () {
              return this.$optional_q3pn27$;
            },
            set: function (tmp$0) {
              this.$optional_q3pn27$ = tmp$0;
            }
          },
          state: {
            get: function () {
              return this.$state_o1zrsg$;
            },
            set: function (tmp$0) {
              this.$state_o1zrsg$ = tmp$0;
            }
          },
          datatype: {
            get: function () {
              return this.$datatype_4t2ef9$;
            },
            set: function (tmp$0) {
              this.$datatype_4t2ef9$ = tmp$0;
            }
          },
          fragmentDependant: {
            get: function () {
              return this.$fragmentDependant_tefpca$;
            },
            set: function (tmp$0) {
              this.$fragmentDependant_tefpca$ = tmp$0;
            }
          },
          defaultValue: {
            get: function () {
              return this.$defaultValue_5tt7f5$;
            },
            set: function (tmp$0) {
              this.$defaultValue_5tt7f5$ = tmp$0;
            }
          }
        }),
        TypedElement: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.TypedElement.prototype */ {
          genericTypes: {
            get: function () {
              return this.$genericTypes_32ol0l$;
            },
            set: function (tmp$0) {
              this.$genericTypes_32ol0l$ = tmp$0;
            }
          }
        }),
        PortTypeMapping: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortTypeMapping.prototype */ {
          beanMethodName: {
            get: function () {
              return this.$beanMethodName_sgmp8w$;
            },
            set: function (tmp$0) {
              this.$beanMethodName_sgmp8w$ = tmp$0;
            }
          },
          serviceMethodName: {
            get: function () {
              return this.$serviceMethodName_kdedgt$;
            },
            set: function (tmp$0) {
              this.$serviceMethodName_kdedgt$ = tmp$0;
            }
          },
          paramTypes: {
            get: function () {
              return this.$paramTypes_fy6jxc$;
            },
            set: function (tmp$0) {
              this.$paramTypes_fy6jxc$ = tmp$0;
            }
          },
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_690oqi$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_690oqi$ = tmp$0;
            }
          }
        }),
        ServicePortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.PortType, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ServicePortType.prototype */ {
          interface: {
            get: function () {
              return this.$interface_wlgea$;
            },
            set: function (tmp$0) {
              this.$interface_wlgea$ = tmp$0;
            }
          },
          operations: {
            get: function () {
              return this.$operations_ggf0fx$;
            },
            set: function (tmp$0) {
              this.$operations_ggf0fx$ = tmp$0;
            }
          }
        }),
        Operation: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Operation.prototype */ {
          parameters: {
            get: function () {
              return this.$parameters_nryb4m$;
            },
            set: function (tmp$0) {
              this.$parameters_nryb4m$ = tmp$0;
            }
          },
          returnType: {
            get: function () {
              return this.$returnType_98xmpi$;
            },
            set: function (tmp$0) {
              this.$returnType_98xmpi$ = tmp$0;
            }
          }
        }),
        Parameter: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Parameter.prototype */ {
          order: {
            get: function () {
              return this.$order_tm5icw$;
            },
            set: function (tmp$0) {
              this.$order_tm5icw$ = tmp$0;
            }
          },
          type: {
            get: function () {
              return this.$type_3moby0$;
            },
            set: function (tmp$0) {
              this.$type_3moby0$ = tmp$0;
            }
          }
        }),
        MessagePortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.PortType, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.MessagePortType.prototype */ {
          filters: {
            get: function () {
              return this.$filters_a0gt4a$;
            },
            set: function (tmp$0) {
              this.$filters_a0gt4a$ = tmp$0;
            }
          }
        }),
        ChannelType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ChannelType.prototype */ {
          lowerBindings: {
            get: function () {
              return this.$lowerBindings_8zhvff$;
            },
            set: function (tmp$0) {
              this.$lowerBindings_8zhvff$ = tmp$0;
            }
          },
          upperBindings: {
            get: function () {
              return this.$upperBindings_ffz8ee$;
            },
            set: function (tmp$0) {
              this.$upperBindings_ffz8ee$ = tmp$0;
            }
          },
          lowerFragments: {
            get: function () {
              return this.$lowerFragments_r3d52k$;
            },
            set: function (tmp$0) {
              this.$lowerFragments_r3d52k$ = tmp$0;
            }
          },
          upperFragments: {
            get: function () {
              return this.$upperFragments_32uu0b$;
            },
            set: function (tmp$0) {
              this.$upperFragments_32uu0b$ = tmp$0;
            }
          }
        }),
        GroupType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }),
        NodeType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }),
        log: Kotlin.definePackage(function () {
          this.Log = Kotlin.createObject(null, function () {
            this.LEVEL_NONE = 6;
            this.LEVEL_ERROR = 5;
            this.LEVEL_WARN = 4;
            this.LEVEL_INFO = 3;
            this.LEVEL_DEBUG = 2;
            this.LEVEL_TRACE = 1;
            this.$level_qhmnt5$ = this.LEVEL_INFO;
            this._ERROR_oj0992$ = this.level <= this.LEVEL_ERROR;
            this._WARN_qp2148$ = this.level <= this.LEVEL_WARN;
            this._INFO_qpapkw$ = this.level <= this.LEVEL_INFO;
            this._DEBUG_oi7u3l$ = this.level <= this.LEVEL_DEBUG;
            this._TRACE_or8t8z$ = this.level <= this.LEVEL_TRACE;
            this.logger = new _.org.kevoree.log.Logger();
            this.beginParam = '{';
            this.endParam = '}';
          }, {
            level: {
              get: function () {
                return this.$level_qhmnt5$;
              },
              set: function (newLevel) {
                this.$level_qhmnt5$ = newLevel;
                this._ERROR_oj0992$ = newLevel <= this.LEVEL_ERROR;
                this._WARN_qp2148$ = newLevel <= this.LEVEL_WARN;
                this._INFO_qpapkw$ = newLevel <= this.LEVEL_INFO;
                this._DEBUG_oi7u3l$ = newLevel <= this.LEVEL_DEBUG;
                this._TRACE_or8t8z$ = newLevel <= this.LEVEL_TRACE;
              }
            },
            NONE: function () {
              this.level = this.LEVEL_NONE;
            },
            ERROR: function () {
              this.level = this.LEVEL_ERROR;
            },
            WARN: function () {
              this.level = this.LEVEL_WARN;
            },
            INFO: function () {
              this.level = this.LEVEL_INFO;
            },
            DEBUG: function () {
              this.level = this.LEVEL_DEBUG;
            },
            TRACE: function () {
              this.level = this.LEVEL_TRACE;
            },
            processMessage: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = new Kotlin.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    {
                      if (param === 1) {
                        buffer = new Kotlin.StringBuilder();
                        buffer.append(message.substring(0, i - 1));
                        buffer.append((p1 != null ? p1 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 2) {
                        buffer.append((p2 != null ? p2 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 3) {
                        buffer.append((p3 != null ? p3 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 4) {
                        buffer.append((p4 != null ? p4 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 5) {
                        buffer.append((p5 != null ? p5 : Kotlin.throwNPE()).toString());
                      }
                       else {
                      }
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            },
            error_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._ERROR_oj0992$) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            error: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._ERROR_oj0992$) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_error: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            },
            warn_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._WARN_qp2148$) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            warn: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._WARN_qp2148$) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_warn: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            },
            info_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._INFO_qpapkw$) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            info: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._INFO_qpapkw$) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_info: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            },
            debug_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._DEBUG_oi7u3l$) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            debug: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._DEBUG_oi7u3l$) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_debug: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            },
            trace_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._TRACE_or8t8z$) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            trace: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._TRACE_or8t8z$) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_trace: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }
          });
        }, /** @lends _.org.kevoree.log */ {
          Logger: Kotlin.createClass(null, function () {
            this.firstLogTime = (new Date()).getTime();
            this.error_msg = ' ERROR: ';
            this.warn_msg = ' WARN: ';
            this.info_msg = ' INFO: ';
            this.debug_msg = ' DEBUG: ';
            this.trace_msg = ' TRACE: ';
            this.category = null;
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: function (category) {
              this.category = category;
            },
            log: function (level, message, ex) {
              var builder = new Kotlin.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append('0');
              builder.append(minutes.toString());
              builder.append(':');
              if (seconds <= 9)
                builder.append('0');
              builder.append(seconds.toString());
              {
                if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                  builder.append(this.error_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                  builder.append(this.warn_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                  builder.append(this.info_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                  builder.append(this.debug_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                  builder.append(this.trace_msg);
                }
                 else {
                }
              }
              if (this.category != null) {
                builder.append('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              {
                if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                  console.error(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                  console.warn(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                  console.info(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                  console.log(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                  console.log(builder.toString());
                }
                 else {
                }
              }
            }
          })
        }),
        container: Kotlin.definePackage(function () {
          this.cleanCacheVisitor = Kotlin.createObject(function () {
            return [_.org.kevoree.modeling.api.util.ModelVisitor];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            visit: function (elem, refNameInParent, parent) {
            },
            endVisitElem: function (elem) {
              elem.path_cache = null;
            }
          });
        }, /** @lends _.org.kevoree.container */ {
          KMFContainerImpl: Kotlin.createTrait(function () {
            return [_.org.kevoree.modeling.api.util.InboundRefAware, _.org.kevoree.modeling.api.KMFContainer];
          }, /** @lends _.org.kevoree.container.KMFContainerImpl.prototype */ {
            internal_hashcode_fdnqaa$: {
              get: function () {
                return this.$internal_hashcode_fdnqaa$;
              },
              set: function (tmp$0) {
                this.$internal_hashcode_fdnqaa$ = tmp$0;
              }
            },
            hashCode: function () {
              if (this.internal_hashcode_fdnqaa$ == null) {
                this.internal_hashcode_fdnqaa$ = Math.floor(Math.random() * 10000000) + (new Date()).getTime();
              }
              var tmp$0;
              return (tmp$0 = this.internal_hashcode_fdnqaa$) != null ? tmp$0 : Kotlin.throwNPE();
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_xvryed$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_xvryed$ = tmp$0;
              }
            },
            isDeleted: function () {
              return this.internal_is_deleted;
            },
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_v316j1$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_v316j1$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_clnprc$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_clnprc$ = tmp$0;
              }
            },
            eContainer: function () {
              return this.internal_eContainer;
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_2rxjyb$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_2rxjyb$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_bdx8q0$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_bdx8q0$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_uv4k8b$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_uv4k8b$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_czt5qs$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_czt5qs$ = tmp$0;
              }
            },
            addInboundReference: function (path, refName) {
              if (!this.internal_deleteInProgress) {
                _.kotlin.getOrPut_ynyybx$(this.internal_inboundReferences, path, _.org.kevoree.container.KMFContainerImpl.addInboundReference$f).add_za3rmp$(refName);
              }
            },
            removeInboundReference: function (path, refName) {
              if (!this.internal_deleteInProgress) {
                var refs = this.internal_inboundReferences.get_za3rmp$(path);
                if (refs != null) {
                  if (refs.size() > 1) {
                    refs.remove_za3rmp$(refName);
                  }
                   else {
                    this.internal_inboundReferences.remove_za3rmp$(path);
                  }
                }
              }
            },
            advertiseInboundRefs: function (action, value) {
              {
                var tmp$0 = this.internal_inboundReferences.keySet().iterator();
                while (tmp$0.hasNext()) {
                  var inboundElem = tmp$0.next();
                  if (!inboundElem.isDeleted()) {
                    var tmp$1;
                    var refList = (tmp$1 = this.internal_inboundReferences.get_za3rmp$(inboundElem)) != null ? tmp$1 : Kotlin.throwNPE();
                    {
                      var tmp$2 = refList.iterator();
                      while (tmp$2.hasNext()) {
                        var ref = tmp$2.next();
                        inboundElem.reflexiveMutator(action, ref, value, false, true);
                      }
                    }
                  }
                }
              }
            },
            setRecursiveReadOnly: function () {
              if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
                return;
              }
              this.setInternalRecursiveReadOnly();
              var recVisitor = _.org.kevoree.container.KMFContainerImpl.setRecursiveReadOnly$f();
              this.visit(recVisitor, true, true, true);
              this.setInternalReadOnly();
            },
            setInternalReadOnly: function () {
              this.internal_readOnlyElem = true;
            },
            setInternalRecursiveReadOnly: function () {
              this.internal_recursive_readOnlyElem = true;
            },
            getRefInParent: function () {
              return this.internal_containmentRefName;
            },
            isReadOnly: function () {
              return this.internal_readOnlyElem;
            },
            isRecursiveReadOnly: function () {
              return this.internal_recursive_readOnlyElem;
            },
            setEContainer: function (container, unsetCmd, refNameInParent) {
              if (this.internal_readOnlyElem) {
                return;
              }
              if (Kotlin.equals(this.eContainer(), container)) {
                return;
              }
              this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              var tempUnsetCmd = this.internal_unsetCmd;
              this.internal_unsetCmd = null;
              if (tempUnsetCmd != null) {
                tempUnsetCmd.run();
              }
              this.internal_eContainer = container;
              this.internal_unsetCmd = unsetCmd;
              this.internal_containmentRefName = refNameInParent;
              this.path_cache = null;
            },
            select: function (query) {
              if (Kotlin.equals(this.path(), '/') && query.startsWith('/')) {
                return _.org.kevoree.modeling.api.util.Selector.select(this, query.substring(1));
              }
               else {
                return _.org.kevoree.modeling.api.util.Selector.select(this, query);
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_dtvvyj$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_dtvvyj$ = tmp$0;
              }
            },
            fireModelEvent: function (evt) {
              if (this.internal_modelElementListeners != null) {
                var tmp$0;
                {
                  var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var lst = tmp$1.next();
                    lst.elementChanged(evt);
                  }
                }
              }
              this.fireModelEventOnTree(evt);
            },
            addModelElementListener: function (lst) {
              if (this.internal_modelElementListeners == null) {
                this.internal_modelElementListeners = new Kotlin.ArrayList();
              }
              var tmp$0;
              ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$(lst);
            },
            removeModelElementListener: function (lst) {
              if (this.internal_modelElementListeners != null) {
                var tmp$0, tmp$1;
                ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove_za3rmp$(lst);
                if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
                  this.internal_modelElementListeners = null;
                }
              }
            },
            removeAllModelElementListeners: function () {
              if (this.internal_modelElementListeners != null) {
                var tmp$0;
                ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
                this.internal_modelElementListeners = null;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_uom9b$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_uom9b$ = tmp$0;
              }
            },
            fireModelEventOnTree: function (evt) {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0;
                {
                  var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var lst = tmp$1.next();
                    lst.elementChanged(evt);
                  }
                }
              }
              if (this.eContainer() != null) {
                var tmp$2;
                ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
              }
            },
            addModelTreeListener: function (lst) {
              if (this.internal_modelTreeListeners == null) {
                this.internal_modelTreeListeners = new Kotlin.ArrayList();
              }
              var tmp$0;
              ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$(lst);
            },
            removeModelTreeListener: function (lst) {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0, tmp$1;
                ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove_za3rmp$(lst);
                if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
                  this.internal_modelTreeListeners = null;
                }
              }
            },
            removeAllModelTreeListeners: function () {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0;
                ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
                this.internal_modelElementListeners = null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
            },
            visitAttributes: function (visitor) {
            },
            internal_visit: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
              if (internalElem != null) {
                if (nonContainedReference && recursive) {
                  var elemPath = internalElem.path();
                  var tmp$0, tmp$1;
                  if (visitor.alreadyVisited != null && ((tmp$0 = visitor.alreadyVisited) != null ? tmp$0 : Kotlin.throwNPE()).containsKey_za3rmp$(elemPath)) {
                    return;
                  }
                  if (visitor.alreadyVisited == null) {
                    visitor.alreadyVisited = new Kotlin.PrimitiveHashMap();
                  }
                  ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).put_wn2jw4$(elemPath, internalElem);
                }
                visitor.visit(internalElem, refName, this);
                if (!visitor.visitStopped) {
                  if (recursive && (visitor.visitChildren || visitor.visitReferences)) {
                    var visitSubReferences = nonContainedReference && visitor.visitReferences;
                    var visitSubChilds = containedReference && visitor.visitChildren;
                    internalElem.visit(visitor, recursive, visitSubChilds, visitSubReferences);
                  }
                  visitor.visitChildren = true;
                  visitor.visitReferences = true;
                }
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_5gbaib$;
              },
              set: function (tmp$0) {
                this.$path_cache_5gbaib$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_vns4l3$;
              },
              set: function (tmp$0) {
                this.$key_cache_vns4l3$ = tmp$0;
              }
            },
            isRoot: function () {
              return this.is_root;
            },
            is_root: {
              get: function () {
                return this.$is_root_v4yqtw$;
              },
              set: function (tmp$0) {
                this.$is_root_v4yqtw$ = tmp$0;
              }
            },
            path: function () {
              if (this.path_cache != null) {
                var tmp$0;
                return (tmp$0 = this.path_cache) != null ? tmp$0 : Kotlin.throwNPE();
              }
              var container = this.eContainer();
              if (container != null) {
                var parentPath = container.path();
                if (Kotlin.equals(parentPath, '')) {
                  var tmp$1;
                  this.path_cache = ((tmp$1 = this.internal_containmentRefName) != null ? tmp$1 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
                 else if (Kotlin.equals(parentPath, '/')) {
                  var tmp$2;
                  this.path_cache = parentPath + ((tmp$2 = this.internal_containmentRefName) != null ? tmp$2 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
                 else {
                  var tmp$3;
                  this.path_cache = parentPath + '/' + ((tmp$3 = this.internal_containmentRefName) != null ? tmp$3 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
              }
               else {
                if (this.is_root) {
                  this.path_cache = '/';
                }
                 else {
                  this.path_cache = '';
                }
              }
              var tmp$4;
              return (tmp$4 = this.path_cache) != null ? tmp$4 : Kotlin.throwNPE();
            },
            modelEquals: function (similarObj) {
              if (similarObj == null) {
                return false;
              }
              if (Kotlin.equals(this, similarObj)) {
                return true;
              }
              if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
                return false;
              }
              var values = new Kotlin.PrimitiveHashMap();
              var attVisitor = _.org.kevoree.container.KMFContainerImpl.modelEquals$f(values);
              this.visitAttributes(attVisitor);
              similarObj.visitAttributes(attVisitor);
              if (!values.isEmpty()) {
                return false;
              }
              var payload = '';
              var refVisitor = _.org.kevoree.container.KMFContainerImpl.modelEquals$f_0(values, payload);
              this.visit(refVisitor, false, false, true);
              similarObj.visit(refVisitor, false, false, true);
              if (!values.isEmpty()) {
                return false;
              }
              return true;
            },
            deepModelEquals: function (similarObj) {
              if (!this.modelEquals(similarObj)) {
                return false;
              }
              var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
              while (similarRoot.eContainer() != null) {
                var tmp$0;
                similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
              }
              var resultTest = {v: true};
              var finalRoot = similarRoot;
              var objVisitor = _.org.kevoree.container.KMFContainerImpl.deepModelEquals$f(finalRoot, resultTest);
              this.visit(objVisitor, true, true, false);
              return resultTest.v;
            },
            findByPath: function (query) {
              if (Kotlin.equals(query, this.path())) {
                return this;
              }
              if (Kotlin.equals(this.path(), '/') && query.startsWith('/')) {
                return this.findByPath(query.substring(1));
              }
              var firstSepIndex = _.js.indexOf_960177$(query, '[');
              if (firstSepIndex === -1) {
                if (query.length === 0) {
                  return this;
                }
                 else {
                  return null;
                }
              }
              var queryID = '';
              var extraReadChar = 2;
              var relationName = query.substring(0, _.js.indexOf_960177$(query, '['));
              if (_.js.indexOf_960177$(query, '{') === firstSepIndex + 1) {
                queryID = query.substring(_.js.indexOf_960177$(query, '{') + 1, _.js.indexOf_960177$(query, '}'));
                extraReadChar = extraReadChar + 2;
              }
               else {
                var indexFirstClose = _.js.indexOf_960177$(query, ']');
                while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
                  indexFirstClose = _.js.indexOf_orzsrp$(query, ']', indexFirstClose + 1);
                  if (indexFirstClose === -1) {
                    return null;
                  }
                }
                queryID = query.substring(_.js.indexOf_960177$(query, '[') + 1, indexFirstClose);
              }
              var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
              if (_.js.indexOf_960177$(subquery, '/') !== -1) {
                subquery = subquery.substring(_.js.indexOf_960177$(subquery, '/') + 1, subquery.length);
              }
              var objFound = this.findByID(relationName, queryID);
              if (!Kotlin.equals(subquery, '') && objFound != null) {
                return objFound.findByPath(subquery);
              }
               else {
                return objFound;
              }
            },
            createTraces: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
              var traces = new Kotlin.ArrayList();
              var values = new Kotlin.PrimitiveHashMap();
              if (onlyAttributes) {
                var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.createTraces$f(values);
                this.visitAttributes(attVisitorFill);
                var attVisitor = _.org.kevoree.container.KMFContainerImpl.createTraces$f_0(values, isInter, traces, this);
                if (similarObj != null) {
                  similarObj.visitAttributes(attVisitor);
                }
                if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
                  {
                    var tmp$0 = values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var hashLoopRes = tmp$0.next();
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this.path(), hashLoopRes, null, null, null));
                    }
                  }
                }
              }
              if (onlyReferences) {
                var payload = '';
                var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.createTraces$f_1(values, payload);
                this.visit(refVisitorFill, false, false, true);
                var refVisitor = _.org.kevoree.container.KMFContainerImpl.createTraces$f_2(values, isInter, traces, this);
                if (similarObj != null) {
                  similarObj.visit(refVisitor, false, false, true);
                }
                if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
                  {
                    var tmp$1 = values.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var hashLoopRes_0 = tmp$1.next();
                      var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(this.path(), splittedVal[0], splittedVal[1]));
                    }
                  }
                }
              }
              return traces;
            },
            toTraces: function (attributes, references) {
              var traces = new Kotlin.ArrayList();
              if (attributes) {
                var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.toTraces$f(traces, this);
                this.visitAttributes(attVisitorFill);
              }
              if (references) {
                var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.toTraces$f_0(traces, this);
                this.visit(refVisitorFill, false, true, true);
              }
              return traces;
            },
            visitNotContained: function (visitor) {
              this.visit(visitor, false, false, true);
            },
            visitContained: function (visitor) {
              this.visit(visitor, false, true, false);
            },
            visitReferences: function (visitor) {
              this.visit(visitor, false, true, true);
            },
            deepVisitNotContained: function (visitor) {
              this.visit(visitor, true, false, true);
            },
            deepVisitContained: function (visitor) {
              this.visit(visitor, true, true, false);
            },
            deepVisitReferences: function (visitor) {
              this.visit(visitor, true, true, true);
            }
          }, /** @lends _.org.kevoree.container.KMFContainerImpl */ {
            addInboundReference$f: function () {
              return new Kotlin.PrimitiveHashSet();
            },
            setRecursiveReadOnly$f: function () {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  if (elem.isRecursiveReadOnly()) {
                    this.noChildrenVisit();
                  }
                   else {
                    elem.setInternalRecursiveReadOnly();
                    elem.setInternalReadOnly();
                  }
                }
              });
            },
            modelEquals$f: function (values) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  if (values.containsKey_za3rmp$(name)) {
                    if (Kotlin.equals(values.get_za3rmp$(name), value != null ? value.toString() : null)) {
                      values.remove_za3rmp$(name);
                    }
                  }
                   else {
                    values.put_wn2jw4$(name, value != null ? value.toString() : null);
                  }
                }
              });
            },
            modelEquals$f_0: function (values, payload) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  if (values.containsKey_za3rmp$(concatedKey)) {
                    values.remove_za3rmp$(concatedKey);
                  }
                   else {
                    values.put_wn2jw4$(concatedKey, payload);
                  }
                }
              });
            },
            deepModelEquals$f: function (finalRoot, resultTest) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var similarSubObj = finalRoot.findByPath(elem.path());
                  if (!elem.modelEquals(similarSubObj)) {
                    resultTest.v = false;
                    this.stopVisit();
                  }
                }
              });
            },
            createTraces$f: function (values) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  values.put_wn2jw4$(name, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                }
              });
            },
            createTraces$f_0: function (values, isInter, traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  var attVal2 = _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value);
                  if (Kotlin.equals(values.get_za3rmp$(name), attVal2)) {
                    if (isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, attVal2, null));
                    }
                  }
                   else {
                    if (!isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, attVal2, null));
                    }
                  }
                  values.remove_za3rmp$(name);
                }
              });
            },
            createTraces$f_1: function (values, payload) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  values.put_wn2jw4$(concatedKey, payload);
                }
              });
            },
            createTraces$f_2: function (values, isInter, traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  if (values.get_za3rmp$(concatedKey) != null) {
                    if (isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                    }
                  }
                   else {
                    if (!isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                    }
                  }
                  values.remove_za3rmp$(concatedKey);
                }
              });
            },
            toTraces$f: function (traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value), null));
                }
              });
            },
            toTraces$f_0: function (traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                }
              });
            }
          }),
          RemoveFromContainerCommand: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            this.target = target;
            this.mutatorType = mutatorType;
            this.refName = refName;
            this.element = element;
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: function () {
              if (!this.target.isDeleted()) {
                this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
              }
            }
          })
        }),
        impl: Kotlin.definePackage(null, /** @lends _.org.kevoree.impl */ {
          MBindingImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.MBinding, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_z1m2g3$ = null;
            this.$internal_containmentRefName_eftcj$ = null;
            this.$internal_unsetCmd_w1bnki$ = null;
            this.$internal_readOnlyElem_u2nvzi$ = false;
            this.$internal_recursive_readOnlyElem_wmnhfj$ = false;
            this.$internal_inboundReferences_48ffeo$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_9zuf2a$ = false;
            this.$internal_is_deleted_x6r7np$ = false;
            this.$is_root_raraxi$ = false;
            this.$internal_modelElementListeners_ovnd8r$ = null;
            this.$internal_modelTreeListeners_2bor1j$ = null;
            this.$path_cache_1c2e9j$ = null;
            this.$key_cache_3y1q8x$ = null;
            this.$generated_KMF_ID_4131jt$ = '' + Math.random() + (new Date()).getTime();
            this.$port_xzicf2$ = null;
            this.$hub_5og40c$ = null;
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_z1m2g3$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_z1m2g3$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_eftcj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_eftcj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_w1bnki$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_w1bnki$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_u2nvzi$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_u2nvzi$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_wmnhfj$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_wmnhfj$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_48ffeo$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_48ffeo$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_9zuf2a$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_9zuf2a$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_x6r7np$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_x6r7np$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_raraxi$;
              },
              set: function (tmp$0) {
                this.$is_root_raraxi$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ovnd8r$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ovnd8r$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_2bor1j$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_2bor1j$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_1c2e9j$;
              },
              set: function (tmp$0) {
                this.$path_cache_1c2e9j$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_3y1q8x$;
              },
              set: function (tmp$0) {
                this.$key_cache_3y1q8x$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.port != null) {
                var tmp$0;
                ((tmp$0 = this.port) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                this.port = null;
              }
              if (this.hub != null) {
                var tmp$1;
                ((tmp$1 = this.hub) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                this.hub = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_4131jt$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_4131jt$;
                this.$generated_KMF_ID_4131jt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            port: {
              get: function () {
                return this.$port_xzicf2$;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port_xzicf2$, portP)) {
                if (setOpposite) {
                  if (this.$port_xzicf2$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port_xzicf2$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$port_xzicf2$;
                if (portP != null) {
                  (portP != null ? portP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                }
                 else {
                  if (this.$port_xzicf2$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$port_xzicf2$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                  }
                }
                this.$port_xzicf2$ = portP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withPort: function (ref) {
              return this;
            },
            hub: {
              get: function () {
                return this.$hub_5og40c$;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub_5og40c$, hubP)) {
                if (setOpposite) {
                  if (this.$hub_5og40c$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub_5og40c$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$hub_5og40c$;
                if (hubP != null) {
                  (hubP != null ? hubP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                }
                 else {
                  if (this.$hub_5og40c$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$hub_5og40c$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                  }
                }
                this.$hub_5og40c$ = hubP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withHub: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_port(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_port(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_port(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_hub(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_hub(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_hub(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                  var objFound = this.port;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                  var objFound_0 = this.hub;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel)) {
                  this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }
          }),
          ParameterImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Parameter, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_vv9dd0$ = null;
            this.$internal_containmentRefName_ivuvlg$ = null;
            this.$internal_unsetCmd_dv8oyv$ = null;
            this.$internal_readOnlyElem_9ick9z$ = false;
            this.$internal_recursive_readOnlyElem_e2jwhy$ = false;
            this.$internal_inboundReferences_ura3rt$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_e1nyyt$ = false;
            this.$internal_is_deleted_t2ilho$ = false;
            this.$is_root_ggf0wt$ = false;
            this.$internal_modelElementListeners_5y73xg$ = null;
            this.$internal_modelTreeListeners_gylxwg$ = null;
            this.$path_cache_t5jwrm$ = null;
            this.$key_cache_pjuc2w$ = null;
            this.$name_8gjzyd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$order_ludsj0$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$type_8gobqs$ = null;
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_vv9dd0$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_vv9dd0$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ivuvlg$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ivuvlg$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_dv8oyv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_dv8oyv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_9ick9z$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_9ick9z$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_e2jwhy$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_e2jwhy$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ura3rt$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ura3rt$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_e1nyyt$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_e1nyyt$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_t2ilho$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_t2ilho$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ggf0wt$;
              },
              set: function (tmp$0) {
                this.$is_root_ggf0wt$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_5y73xg$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_5y73xg$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_gylxwg$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_gylxwg$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_t5jwrm$;
              },
              set: function (tmp$0) {
                this.$path_cache_t5jwrm$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_pjuc2w$;
              },
              set: function (tmp$0) {
                this.$key_cache_pjuc2w$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.type != null) {
                var tmp$0;
                ((tmp$0 = this.type) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                this.type = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_8gjzyd$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_8gjzyd$;
                this.$name_8gjzyd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOrder: function (p) {
              this.order = p;
              return this;
            },
            order: {
              get: function () {
                return this.$order_ludsj0$;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                var kmf_previousVal = this.$order_ludsj0$;
                this.$order_ludsj0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order, kmf_previousVal, this, oldPath));
                }
              }
            },
            type: {
              get: function () {
                return this.$type_8gobqs$;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type_8gobqs$, typeP)) {
                var kmf_previousVal = this.$type_8gobqs$;
                if (typeP != null) {
                  (typeP != null ? typeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                }
                 else {
                  if (this.$type_8gobqs$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$type_8gobqs$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                  }
                }
                this.$type_8gobqs$ = typeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withType: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_order) {
                  this.internal_order(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_type(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_type(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_type(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                  var objFound = this.type;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }
          }),
          GroupImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Group, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_6cdzuu$ = null;
            this.$internal_containmentRefName_vebtpy$ = null;
            this.$internal_unsetCmd_veg8dr$ = null;
            this.$internal_readOnlyElem_8pw15d$ = false;
            this.$internal_recursive_readOnlyElem_wbvzx8$ = false;
            this.$internal_inboundReferences_wq9wfx$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_wmbq8r$ = false;
            this.$internal_is_deleted_954rq6$ = false;
            this.$is_root_hr8or1$ = false;
            this.$internal_modelElementListeners_2mjqeq$ = null;
            this.$internal_modelTreeListeners_xbkrey$ = null;
            this.$path_cache_juq6q4$ = null;
            this.$key_cache_yezpfi$ = null;
            this.$name_6q21d$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_cjcnfn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._subNodes = new _.java.util.concurrent.ConcurrentHashMap();
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_48mgnl$ = null;
            this.$dictionary_801d16$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_6cdzuu$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_6cdzuu$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_vebtpy$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_vebtpy$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_veg8dr$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_veg8dr$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_8pw15d$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_8pw15d$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_wbvzx8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_wbvzx8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_wq9wfx$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_wq9wfx$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_wmbq8r$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_wmbq8r$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_954rq6$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_954rq6$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_hr8or1$;
              },
              set: function (tmp$0) {
                this.$is_root_hr8or1$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_2mjqeq$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_2mjqeq$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_xbkrey$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_xbkrey$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_juq6q4$;
              },
              set: function (tmp$0) {
                this.$path_cache_juq6q4$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_yezpfi$;
              },
              set: function (tmp$0) {
                this.$key_cache_yezpfi$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.removeAllSubNodes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_6q21d$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_6q21d$;
                this.$name_6q21d$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_cjcnfn$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_cjcnfn$;
                this.$started_cjcnfn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            subNodes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                var kmf_previousVal = this._subNodes;
                this.internal_removeAllSubNodes(true, false);
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSubNodes: function (subNodesP) {
              var _key_ = subNodesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey_za3rmp$(_key_)) {
                this._subNodes.put_wn2jw4$(_key_, subNodesP);
                subNodesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
              }
            },
            addSubNodes: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
              return this;
            },
            addAllSubNodes: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
              return this;
            },
            internal_addSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (setOpposite) {
                subNodesP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null, this, this.path()));
              }
            },
            internal_addAllSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null, this, this.path()));
              }
            },
            removeSubNodes: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
              return this;
            },
            removeAllSubNodes: function () {
              this.internal_removeAllSubNodes(true, true);
              return this;
            },
            internal_removeSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey_za3rmp$(subNodesP.internalGetKey())) {
                var previousPathToBeRemoved = subNodesP.path();
                this._subNodes.remove_za3rmp$(subNodesP.internalGetKey());
                subNodesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  subNodesP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                }
              }
            },
            internal_removeAllSubNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.subNodes;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els, null, this, this.path()));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_48mgnl$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_48mgnl$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_48mgnl$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_48mgnl$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_48mgnl$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_48mgnl$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_801d16$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_801d16$, dictionaryP)) {
                if (this.$dictionary_801d16$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_801d16$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_801d16$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_801d16$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_801d16$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_801d16$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllSubNodes(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._subNodes.size() !== 0 && this._subNodes.containsKey_za3rmp$(value)) {
                        var obj_1 = this._subNodes.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._subNodes.remove_za3rmp$(value);
                        this._subNodes.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findSubNodesByID: function (key) {
              return this._subNodes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                  return this.findSubNodesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$2 = this._subNodes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._subNodes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }
          }),
          ChannelImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Channel, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_cchzb2$ = null;
            this.$internal_containmentRefName_90vn2m$ = null;
            this.$internal_unsetCmd_4t8cab$ = null;
            this.$internal_readOnlyElem_h5s8p9$ = false;
            this.$internal_recursive_readOnlyElem_9xg1b4$ = false;
            this.$internal_inboundReferences_d3fkxt$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_x70dk1$ = false;
            this.$internal_is_deleted_9jr7fq$ = false;
            this.$is_root_v6dcw9$ = false;
            this.$internal_modelElementListeners_yynwp6$ = null;
            this.$internal_modelTreeListeners_73mpdm$ = null;
            this.$path_cache_lhhprs$ = null;
            this.$key_cache_5vawfy$ = null;
            this.$name_j026ln$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_pyhbkv$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._bindings = new _.java.util.concurrent.ConcurrentHashMap();
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_57fvd9$ = null;
            this.$dictionary_xc6jgq$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_cchzb2$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_cchzb2$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_90vn2m$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_90vn2m$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_4t8cab$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_4t8cab$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_h5s8p9$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_h5s8p9$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_9xg1b4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_9xg1b4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_d3fkxt$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_d3fkxt$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_x70dk1$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_x70dk1$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_9jr7fq$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_9jr7fq$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_v6dcw9$;
              },
              set: function (tmp$0) {
                this.$is_root_v6dcw9$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_yynwp6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_yynwp6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_73mpdm$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_73mpdm$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_lhhprs$;
              },
              set: function (tmp$0) {
                this.$path_cache_lhhprs$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_5vawfy$;
              },
              set: function (tmp$0) {
                this.$key_cache_5vawfy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.removeAllBindings();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_j026ln$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_j026ln$;
                this.$name_j026ln$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_pyhbkv$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_pyhbkv$;
                this.$started_pyhbkv$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = bindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey_za3rmp$(_key_)) {
                this._bindings.put_wn2jw4$(_key_, bindingsP);
                bindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
              return this;
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
              return this;
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
              return this;
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
              return this;
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(bindingsP.internalGetKey())) {
                var previousPathToBeRemoved = bindingsP.path();
                this._bindings.remove_za3rmp$(bindingsP.internalGetKey());
                bindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.bindings;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null, this, this.path()));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_57fvd9$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_57fvd9$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_57fvd9$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_57fvd9$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_57fvd9$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_57fvd9$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_xc6jgq$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_xc6jgq$, dictionaryP)) {
                if (this.$dictionary_xc6jgq$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_xc6jgq$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_xc6jgq$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_xc6jgq$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_xc6jgq$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_xc6jgq$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllBindings(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(value)) {
                        var obj_1 = this._bindings.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._bindings.remove_za3rmp$(value);
                        this._bindings.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findBindingsByID: function (key) {
              return this._bindings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                  return this.findBindingsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$2 = this._bindings.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._bindings.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }
          }),
          ServicePortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ServicePortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_t4v1n$ = null;
            this.$internal_containmentRefName_upkekb$ = null;
            this.$internal_unsetCmd_8nhco0$ = null;
            this.$internal_readOnlyElem_o9efxc$ = false;
            this.$internal_recursive_readOnlyElem_n0v3f1$ = false;
            this.$internal_inboundReferences_sfntse$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_t3ukok$ = false;
            this.$internal_is_deleted_1zlwtp$ = false;
            this.$is_root_hm7xek$ = false;
            this.$internal_modelElementListeners_l9972b$ = null;
            this.$internal_modelTreeListeners_ssbgvb$ = null;
            this.$path_cache_fvb3ph$ = null;
            this.$key_cache_qe1lf3$ = null;
            this.$name_lcvr6m$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_osjjtx$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_maxytn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_8uttoy$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$interface_8uxxve$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$dictionaryType_lwo0sj$ = null;
            this._operations = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllOperationsCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_t4v1n$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_t4v1n$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_upkekb$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_upkekb$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_8nhco0$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_8nhco0$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_o9efxc$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_o9efxc$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_n0v3f1$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_n0v3f1$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_sfntse$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_sfntse$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_t3ukok$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_t3ukok$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_1zlwtp$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_1zlwtp$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_hm7xek$;
              },
              set: function (tmp$0) {
                this.$is_root_hm7xek$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_l9972b$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_l9972b$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ssbgvb$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ssbgvb$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_fvb3ph$;
              },
              set: function (tmp$0) {
                this.$path_cache_fvb3ph$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_qe1lf3$;
              },
              set: function (tmp$0) {
                this.$key_cache_qe1lf3$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              {
                var tmp$2 = this.operations.iterator();
                while (tmp$2.hasNext()) {
                  var el_0 = tmp$2.next();
                  el_0.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$3;
                ((tmp$3 = this.internal_unsetCmd) != null ? tmp$3 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_lcvr6m$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_lcvr6m$;
                this.$name_lcvr6m$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_osjjtx$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_osjjtx$;
                this.$version_osjjtx$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_maxytn$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_maxytn$;
                this.$abstract_maxytn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_8uttoy$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_8uttoy$;
                this.$synchrone_8uttoy$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            withInterface: function (p) {
              this.interface = p;
              return this;
            },
            interface: {
              get: function () {
                return this.$interface_8uxxve$;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$interface_8uxxve$;
                this.$interface_8uxxve$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_lwo0sj$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_lwo0sj$, dictionaryTypeP)) {
                if (this.$dictionaryType_lwo0sj$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_lwo0sj$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_lwo0sj$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_lwo0sj$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_lwo0sj$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_lwo0sj$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            operations: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                var kmf_previousVal = this._operations;
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddOperations: function (operationsP) {
              var _key_ = operationsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey_za3rmp$(_key_)) {
                this._operations.put_wn2jw4$(_key_, operationsP);
                operationsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
                operationsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
              }
            },
            addOperations: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
              return this;
            },
            addAllOperations: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
              return this;
            },
            internal_addOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null, this, this.path()));
              }
            },
            internal_addAllOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null, this, this.path()));
              }
            },
            removeOperations: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
              return this;
            },
            removeAllOperations: function () {
              this.internal_removeAllOperations(true, true);
              return this;
            },
            internal_removeOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey_za3rmp$(operationsP.internalGetKey())) {
                var previousPathToBeRemoved = operationsP.path();
                this._operations.remove_za3rmp$(operationsP.internalGetKey());
                operationsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
                operationsP.setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllOperations: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var temp_els = this.operations;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els, null, this, this.path()));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                  this.internal_interface(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllOperations();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._operations.size() !== 0 && this._operations.containsKey_za3rmp$(value)) {
                        var obj_2 = this._operations.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._operations.remove_za3rmp$(value);
                        this._operations.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findOperationsByID: function (key) {
              return this._operations.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                  return this.findOperationsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation)) {
                  {
                    var tmp$1 = this._operations.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._operations.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$2 = this._deployUnits.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$3 = this._superTypes.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }
          }),
          FragmentDictionaryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.FragmentDictionary, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_yo6lx$ = null;
            this.$internal_containmentRefName_ze982j$ = null;
            this.$internal_unsetCmd_vf3nr4$ = null;
            this.$internal_readOnlyElem_mt2abk$ = false;
            this.$internal_recursive_readOnlyElem_cyra1f$ = false;
            this.$internal_inboundReferences_hjj2mq$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_igi7ro$ = false;
            this.$internal_is_deleted_3reyh9$ = false;
            this.$is_root_tygcxo$ = false;
            this.$internal_modelElementListeners_1snu5f$ = null;
            this.$internal_modelTreeListeners_xh0adj$ = null;
            this.$path_cache_nygoij$ = null;
            this.$key_cache_tys64v$ = null;
            this.$generated_KMF_ID_jtp83r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$name_f26ebm$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.FragmentDictionaryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_yo6lx$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_yo6lx$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ze982j$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ze982j$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_vf3nr4$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_vf3nr4$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_mt2abk$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_mt2abk$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_cyra1f$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_cyra1f$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_hjj2mq$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_hjj2mq$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_igi7ro$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_igi7ro$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3reyh9$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3reyh9$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_tygcxo$;
              },
              set: function (tmp$0) {
                this.$is_root_tygcxo$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_1snu5f$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_1snu5f$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_xh0adj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_xh0adj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_nygoij$;
              },
              set: function (tmp$0) {
                this.$path_cache_nygoij$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_tys64v$;
              },
              set: function (tmp$0) {
                this.$key_cache_tys64v$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_jtp83r$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_jtp83r$;
                this.$generated_KMF_ID_jtp83r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_f26ebm$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_f26ebm$;
                this.$name_f26ebm$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary;
            }
          }),
          PortTypeRefImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortTypeRef, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_pm392r$ = null;
            this.$internal_containmentRefName_atv9kz$ = null;
            this.$internal_unsetCmd_cj7bs$ = null;
            this.$internal_readOnlyElem_hbvq08$ = false;
            this.$internal_recursive_readOnlyElem_p412fp$ = false;
            this.$internal_inboundReferences_m7ab6e$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_m15cx8$ = false;
            this.$internal_is_deleted_mtch7f$ = false;
            this.$is_root_oootrg$ = false;
            this.$internal_modelElementListeners_prt097$ = null;
            this.$internal_modelTreeListeners_8wmbvz$ = null;
            this.$path_cache_3zokj7$ = null;
            this.$key_cache_l34n9l$ = null;
            this.$name_g95rrq$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional_jfj7it$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$noDependency_4fourt$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$ref_e9sxd4$ = null;
            this._mappings = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMappingsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_pm392r$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_pm392r$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_atv9kz$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_atv9kz$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_cj7bs$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_cj7bs$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_hbvq08$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_hbvq08$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_p412fp$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_p412fp$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_m7ab6e$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_m7ab6e$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_m15cx8$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_m15cx8$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_mtch7f$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_mtch7f$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_oootrg$;
              },
              set: function (tmp$0) {
                this.$is_root_oootrg$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_prt097$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_prt097$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_8wmbvz$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_8wmbvz$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_3zokj7$;
              },
              set: function (tmp$0) {
                this.$path_cache_3zokj7$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_l34n9l$;
              },
              set: function (tmp$0) {
                this.$key_cache_l34n9l$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.ref != null) {
                var tmp$0;
                ((tmp$0 = this.ref) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                this.ref = null;
              }
              {
                var tmp$1 = this.mappings.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_g95rrq$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_g95rrq$;
                this.$name_g95rrq$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOptional: function (p) {
              this.optional = p;
              return this;
            },
            optional: {
              get: function () {
                return this.$optional_jfj7it$;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional_jfj7it$;
                this.$optional_jfj7it$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal, this, oldPath));
                }
              }
            },
            withNoDependency: function (p) {
              this.noDependency = p;
              return this;
            },
            noDependency: {
              get: function () {
                return this.$noDependency_4fourt$;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$noDependency_4fourt$;
                this.$noDependency_4fourt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency, kmf_previousVal, this, oldPath));
                }
              }
            },
            ref: {
              get: function () {
                return this.$ref_e9sxd4$;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref_e9sxd4$, refP)) {
                var kmf_previousVal = this.$ref_e9sxd4$;
                if (refP != null) {
                  (refP != null ? refP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                }
                 else {
                  if (this.$ref_e9sxd4$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$ref_e9sxd4$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                  }
                }
                this.$ref_e9sxd4$ = refP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withRef: function (ref) {
              return this;
            },
            mappings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                var kmf_previousVal = this._mappings;
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMappings: function (mappingsP) {
              var _key_ = mappingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey_za3rmp$(_key_)) {
                this._mappings.put_wn2jw4$(_key_, mappingsP);
                mappingsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
                mappingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
              }
            },
            addMappings: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
              return this;
            },
            addAllMappings: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
              return this;
            },
            internal_addMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null, this, this.path()));
              }
            },
            internal_addAllMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null, this, this.path()));
              }
            },
            removeMappings: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
              return this;
            },
            removeAllMappings: function () {
              this.internal_removeAllMappings(true, true);
              return this;
            },
            internal_removeMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey_za3rmp$(mappingsP.internalGetKey())) {
                var previousPathToBeRemoved = mappingsP.path();
                this._mappings.remove_za3rmp$(mappingsP.internalGetKey());
                mappingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
                mappingsP.setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMappings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var temp_els = this.mappings;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els, null, this, this.path()));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                  this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                  this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_ref(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_ref(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_ref(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMappings();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._mappings.size() !== 0 && this._mappings.containsKey_za3rmp$(value)) {
                        var obj = this._mappings.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._mappings.remove_za3rmp$(value);
                        this._mappings.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findMappingsByID: function (key) {
              return this._mappings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                  var objFound = this.ref;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                  return this.findMappingsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping)) {
                  {
                    var tmp$0 = this._mappings.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._mappings.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType)) {
                  this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }
          }),
          MessagePortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.MessagePortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_hbz6o3$ = null;
            this.$internal_containmentRefName_3jq7sj$ = null;
            this.$internal_unsetCmd_l6u4j6$ = null;
            this.$internal_readOnlyElem_ev9acy$ = false;
            this.$internal_recursive_readOnlyElem_kihxen$ = false;
            this.$internal_inboundReferences_kva28w$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_icn5gi$ = false;
            this.$internal_is_deleted_k4pyjf$ = false;
            this.$is_root_he4nm2$ = false;
            this.$internal_modelElementListeners_z33frp$ = null;
            this.$internal_modelTreeListeners_5gz5hj$ = null;
            this.$path_cache_2nrm5l$ = null;
            this.$key_cache_ta1ta9$ = null;
            this.$name_hyjd84$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_p0mtmf$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_fc4ja5$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_5ytlts$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_f4566n$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._filters = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_hbz6o3$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_hbz6o3$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_3jq7sj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_3jq7sj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_l6u4j6$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_l6u4j6$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ev9acy$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ev9acy$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_kihxen$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_kihxen$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_kva28w$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_kva28w$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_icn5gi$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_icn5gi$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_k4pyjf$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_k4pyjf$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_he4nm2$;
              },
              set: function (tmp$0) {
                this.$is_root_he4nm2$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_z33frp$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_z33frp$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_5gz5hj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_5gz5hj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_2nrm5l$;
              },
              set: function (tmp$0) {
                this.$path_cache_2nrm5l$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ta1ta9$;
              },
              set: function (tmp$0) {
                this.$key_cache_ta1ta9$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.removeAllFilters();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_hyjd84$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_hyjd84$;
                this.$name_hyjd84$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_p0mtmf$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_p0mtmf$;
                this.$version_p0mtmf$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_fc4ja5$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_fc4ja5$;
                this.$abstract_fc4ja5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_5ytlts$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_5ytlts$;
                this.$synchrone_5ytlts$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_f4566n$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_f4566n$, dictionaryTypeP)) {
                if (this.$dictionaryType_f4566n$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_f4566n$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_f4566n$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_f4566n$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_f4566n$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_f4566n$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                var kmf_previousVal = this._filters;
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = filtersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey_za3rmp$(_key_)) {
                this._filters.put_wn2jw4$(_key_, filtersP);
                filtersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
              return this;
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
              return this;
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
              return this;
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
              return this;
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(filtersP.internalGetKey())) {
                var previousPathToBeRemoved = filtersP.path();
                this._filters.remove_za3rmp$(filtersP.internalGetKey());
                filtersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.filters;
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFilters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(value)) {
                        var obj_2 = this._filters.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._filters.remove_za3rmp$(value);
                        this._filters.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findFiltersByID: function (key) {
              return this._filters.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                  return this.findFiltersByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$3 = this._filters.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._filters.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }
          }),
          NetworkInfoImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NetworkInfo, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_keo2h5$ = null;
            this.$internal_containmentRefName_wec9a1$ = null;
            this.$internal_unsetCmd_px0nvw$ = null;
            this.$internal_readOnlyElem_rpdj9w$ = false;
            this.$internal_recursive_readOnlyElem_vcdys9$ = false;
            this.$internal_inboundReferences_oir15y$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_99g4k8$ = false;
            this.$internal_is_deleted_n7euch$ = false;
            this.$is_root_yuvqsw$ = false;
            this.$internal_modelElementListeners_tf4qpd$ = null;
            this.$internal_modelTreeListeners_ybl6z1$ = null;
            this.$path_cache_kbu46n$ = null;
            this.$key_cache_mz3tob$ = null;
            this.$name_keyy5q$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NetworkInfoImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_keo2h5$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_keo2h5$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_wec9a1$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_wec9a1$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_px0nvw$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_px0nvw$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_rpdj9w$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_rpdj9w$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_vcdys9$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_vcdys9$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_oir15y$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_oir15y$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_99g4k8$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_99g4k8$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_n7euch$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_n7euch$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_yuvqsw$;
              },
              set: function (tmp$0) {
                this.$is_root_yuvqsw$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_tf4qpd$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_tf4qpd$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ybl6z1$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ybl6z1$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_kbu46n$;
              },
              set: function (tmp$0) {
                this.$path_cache_kbu46n$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mz3tob$;
              },
              set: function (tmp$0) {
                this.$key_cache_mz3tob$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_keyy5q$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_keyy5q$;
                this.$name_keyy5q$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkInfo;
            }
          }),
          ComponentInstanceImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ComponentInstance, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_nmak19$ = null;
            this.$internal_containmentRefName_kll01p$ = null;
            this.$internal_unsetCmd_y60xya$ = null;
            this.$internal_readOnlyElem_ikwqaq$ = false;
            this.$internal_recursive_readOnlyElem_7d07xt$ = false;
            this.$internal_inboundReferences_h2chgw$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_70mf3m$ = false;
            this.$internal_is_deleted_ktjs5x$ = false;
            this.$is_root_d8h6g6$ = false;
            this.$internal_modelElementListeners_ef9b0b$ = null;
            this.$internal_modelTreeListeners_ioc2cp$ = null;
            this.$path_cache_mu1bpj$ = null;
            this.$key_cache_f2th5b$ = null;
            this.$name_wk34d8$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_igd7rk$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._provided = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllProvidedCurrentlyProcessing = false;
            this.$typeDefinition_fs7rgi$ = null;
            this.$dictionary_yoq5eh$ = null;
            this._required = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRequiredCurrentlyProcessing = false;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_nmak19$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_nmak19$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_kll01p$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_kll01p$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_y60xya$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_y60xya$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ikwqaq$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ikwqaq$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7d07xt$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7d07xt$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_h2chgw$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_h2chgw$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_70mf3m$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_70mf3m$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_ktjs5x$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_ktjs5x$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_d8h6g6$;
              },
              set: function (tmp$0) {
                this.$is_root_d8h6g6$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ef9b0b$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ef9b0b$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ioc2cp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ioc2cp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_mu1bpj$;
              },
              set: function (tmp$0) {
                this.$path_cache_mu1bpj$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_f2th5b$;
              },
              set: function (tmp$0) {
                this.$key_cache_f2th5b$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              {
                var tmp$4 = this.provided.iterator();
                while (tmp$4.hasNext()) {
                  var el_1 = tmp$4.next();
                  el_1.delete();
                }
              }
              {
                var tmp$5 = this.required.iterator();
                while (tmp$5.hasNext()) {
                  var el_2 = tmp$5.next();
                  el_2.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$6;
                ((tmp$6 = this.internal_unsetCmd) != null ? tmp$6 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_wk34d8$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_wk34d8$;
                this.$name_wk34d8$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_igd7rk$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_igd7rk$;
                this.$started_igd7rk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = providedP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey_za3rmp$(_key_)) {
                this._provided.put_wn2jw4$(_key_, providedP);
                providedP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
                providedP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
              return this;
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
              return this;
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
              return this;
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
              return this;
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(providedP.internalGetKey())) {
                var previousPathToBeRemoved = providedP.path();
                this._provided.remove_za3rmp$(providedP.internalGetKey());
                providedP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                providedP.setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var temp_els = this.provided;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null, this, this.path()));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_fs7rgi$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_fs7rgi$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_fs7rgi$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_fs7rgi$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_fs7rgi$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_fs7rgi$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_yoq5eh$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_yoq5eh$, dictionaryP)) {
                if (this.$dictionary_yoq5eh$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_yoq5eh$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_yoq5eh$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_yoq5eh$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_yoq5eh$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_yoq5eh$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            required: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = requiredP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey_za3rmp$(_key_)) {
                this._required.put_wn2jw4$(_key_, requiredP);
                requiredP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
                requiredP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
              return this;
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
              return this;
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
              return this;
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
              return this;
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(requiredP.internalGetKey())) {
                var previousPathToBeRemoved = requiredP.path();
                this._required.remove_za3rmp$(requiredP.internalGetKey());
                requiredP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                requiredP.setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var temp_els = this.required;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null, this, this.path()));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllProvided();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(value)) {
                        var obj_1 = this._provided.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._provided.remove_za3rmp$(value);
                        this._provided.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequired();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(value)) {
                        var obj_2 = this._required.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._required.remove_za3rmp$(value);
                        this._required.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get_za3rmp$(key);
            },
            findRequiredByID: function (key) {
              return this._required.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                  return this.findProvidedByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                  return this.findRequiredByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  {
                    var tmp$2 = this._provided.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._provided.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  {
                    var tmp$3 = this._required.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._required.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }
          }),
          PortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_k3n6zk$ = null;
            this.$internal_containmentRefName_80yn9s$ = null;
            this.$internal_unsetCmd_4o77px$ = null;
            this.$internal_readOnlyElem_nsfz3f$ = false;
            this.$internal_recursive_readOnlyElem_my4e4i$ = false;
            this.$internal_inboundReferences_99n2l9$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_79oef3$ = false;
            this.$internal_is_deleted_hawf48$ = false;
            this.$is_root_xh4ot5$ = false;
            this.$internal_modelElementListeners_68i7zc$ = null;
            this.$internal_modelTreeListeners_9y7kys$ = null;
            this.$path_cache_nk0f8a$ = null;
            this.$key_cache_qk3e3g$ = null;
            this.$name_scm1hl$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_4us42i$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_13k1nk$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_9858rn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_h35dea$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_k3n6zk$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_k3n6zk$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_80yn9s$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_80yn9s$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_4o77px$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_4o77px$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_nsfz3f$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_nsfz3f$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_my4e4i$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_my4e4i$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_99n2l9$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_99n2l9$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_79oef3$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_79oef3$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_hawf48$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_hawf48$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_xh4ot5$;
              },
              set: function (tmp$0) {
                this.$is_root_xh4ot5$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_68i7zc$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_68i7zc$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9y7kys$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9y7kys$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_nk0f8a$;
              },
              set: function (tmp$0) {
                this.$path_cache_nk0f8a$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_qk3e3g$;
              },
              set: function (tmp$0) {
                this.$key_cache_qk3e3g$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_scm1hl$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_scm1hl$;
                this.$name_scm1hl$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_4us42i$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_4us42i$;
                this.$version_4us42i$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_13k1nk$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_13k1nk$;
                this.$abstract_13k1nk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_9858rn$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_9858rn$;
                this.$synchrone_9858rn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_h35dea$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_h35dea$, dictionaryTypeP)) {
                if (this.$dictionaryType_h35dea$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_h35dea$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_h35dea$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_h35dea$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_h35dea$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_h35dea$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortType;
            }
          }),
          NodeTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NodeType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_gxuzfj$ = null;
            this.$internal_containmentRefName_j0daa7$ = null;
            this.$internal_unsetCmd_x7k7oq$ = null;
            this.$internal_readOnlyElem_yh9u3u$ = false;
            this.$internal_recursive_readOnlyElem_b2xs77$ = false;
            this.$internal_inboundReferences_n5xt8k$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_hhai0u$ = false;
            this.$internal_is_deleted_jqlrav$ = false;
            this.$is_root_d6010a$ = false;
            this.$internal_modelElementListeners_ze1rjt$ = null;
            this.$internal_modelTreeListeners_kxm7z7$ = null;
            this.$path_cache_c8tlx7$ = null;
            this.$key_cache_a5jobf$ = null;
            this.$name_qycue0$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_fgcjqd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_8lfy9r$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_mhkxfx$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_gxuzfj$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_gxuzfj$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_j0daa7$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_j0daa7$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_x7k7oq$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_x7k7oq$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_yh9u3u$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_yh9u3u$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_b2xs77$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_b2xs77$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_n5xt8k$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_n5xt8k$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_hhai0u$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_hhai0u$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_jqlrav$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_jqlrav$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_d6010a$;
              },
              set: function (tmp$0) {
                this.$is_root_d6010a$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ze1rjt$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ze1rjt$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_kxm7z7$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_kxm7z7$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_c8tlx7$;
              },
              set: function (tmp$0) {
                this.$path_cache_c8tlx7$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_a5jobf$;
              },
              set: function (tmp$0) {
                this.$key_cache_a5jobf$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_qycue0$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_qycue0$;
                this.$name_qycue0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_fgcjqd$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_fgcjqd$;
                this.$version_fgcjqd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_8lfy9r$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_8lfy9r$;
                this.$abstract_8lfy9r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_mhkxfx$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_mhkxfx$, dictionaryTypeP)) {
                if (this.$dictionaryType_mhkxfx$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_mhkxfx$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_mhkxfx$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_mhkxfx$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_mhkxfx$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_mhkxfx$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }
          }),
          PackageImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Package, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_epqzi9$ = null;
            this.$internal_containmentRefName_jrgxqp$ = null;
            this.$internal_unsetCmd_gn28ty$ = null;
            this.$internal_readOnlyElem_efznuy$ = false;
            this.$internal_recursive_readOnlyElem_rxnajn$ = false;
            this.$internal_inboundReferences_5kxrj0$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_wlbk4e$ = false;
            this.$internal_is_deleted_bx07mx$ = false;
            this.$is_root_l2e4vu$ = false;
            this.$internal_modelElementListeners_r0onjb$ = null;
            this.$internal_modelTreeListeners_hu801p$ = null;
            this.$path_cache_4jijz9$ = null;
            this.$key_cache_is02bf$ = null;
            this.$name_n9iebs$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._packages = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllPackagesCurrentlyProcessing = false;
            this._typeDefinitions = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllTypeDefinitionsCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllDeployUnitsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PackageImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_epqzi9$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_epqzi9$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_jrgxqp$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_jrgxqp$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_gn28ty$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_gn28ty$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_efznuy$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_efznuy$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_rxnajn$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_rxnajn$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_5kxrj0$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_5kxrj0$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_wlbk4e$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_wlbk4e$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_bx07mx$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_bx07mx$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_l2e4vu$;
              },
              set: function (tmp$0) {
                this.$is_root_l2e4vu$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_r0onjb$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_r0onjb$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_hu801p$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_hu801p$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_4jijz9$;
              },
              set: function (tmp$0) {
                this.$path_cache_4jijz9$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_is02bf$;
              },
              set: function (tmp$0) {
                this.$key_cache_is02bf$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.packages.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              {
                var tmp$1 = this.typeDefinitions.iterator();
                while (tmp$1.hasNext()) {
                  var el_0 = tmp$1.next();
                  el_0.delete();
                }
              }
              {
                var tmp$2 = this.deployUnits.iterator();
                while (tmp$2.hasNext()) {
                  var el_1 = tmp$2.next();
                  el_1.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$3;
                ((tmp$3 = this.internal_unsetCmd) != null ? tmp$3 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_n9iebs$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_n9iebs$;
                this.$name_n9iebs$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            packages: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._packages.values());
              },
              set: function (packagesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (packagesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_packages(packagesP, true, true);
              }
            },
            internal_packages: function (packagesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._packages.values(), packagesP)) {
                var kmf_previousVal = this._packages;
                this._packages.clear();
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._packages.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, el), _.org.kevoree.util.Constants.Ref_packages);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddPackages: function (packagesP) {
              var _key_ = packagesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._packages.containsKey_za3rmp$(_key_)) {
                this._packages.put_wn2jw4$(_key_, packagesP);
                packagesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, packagesP), _.org.kevoree.util.Constants.Ref_packages);
                packagesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
              }
            },
            addPackages: function (packagesP) {
              this.internal_addPackages(packagesP, true, true);
              return this;
            },
            addAllPackages: function (packagesP) {
              this.internal_addAllPackages(packagesP, true, true);
              return this;
            },
            internal_addPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPackages(packagesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            internal_addAllPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPackages(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = packagesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPackages(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            removePackages: function (packagesP) {
              this.internal_removePackages(packagesP, true, true);
              return this;
            },
            removeAllPackages: function () {
              this.internal_removeAllPackages(true, true);
              return this;
            },
            internal_removePackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(packagesP.internalGetKey())) {
                var previousPathToBeRemoved = packagesP.path();
                this._packages.remove_za3rmp$(packagesP.internalGetKey());
                packagesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                packagesP.setEContainer(null, null, null);
                if (!this.removeAllPackagesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllPackages: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllPackagesCurrentlyProcessing = true;
              }
              var temp_els = this.packages;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._packages.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, temp_els, null, this, this.path()));
                this.removeAllPackagesCurrentlyProcessing = false;
              }
            },
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                var kmf_previousVal = this._typeDefinitions;
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddTypeDefinitions: function (typeDefinitionsP) {
              var _key_ = typeDefinitionsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey_za3rmp$(_key_)) {
                this._typeDefinitions.put_wn2jw4$(_key_, typeDefinitionsP);
                typeDefinitionsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                typeDefinitionsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            },
            addTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            addAllTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            internal_addTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null, this, this.path()));
              }
            },
            internal_addAllTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null, this, this.path()));
              }
            },
            removeTypeDefinitions: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            removeAllTypeDefinitions: function () {
              this.internal_removeAllTypeDefinitions(true, true);
              return this;
            },
            internal_removeTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey_za3rmp$(typeDefinitionsP.internalGetKey())) {
                var previousPathToBeRemoved = typeDefinitionsP.path();
                this._typeDefinitions.remove_za3rmp$(typeDefinitionsP.internalGetKey());
                typeDefinitionsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                typeDefinitionsP.setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllTypeDefinitions: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var temp_els = this.typeDefinitions;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els, null, this, this.path()));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                deployUnitsP.setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var temp_els = this.deployUnits;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_packages) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removePackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllPackages();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(value)) {
                        var obj = this._packages.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._packages.remove_za3rmp$(value);
                        this._packages.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllTypeDefinitions();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey_za3rmp$(value)) {
                        var obj_0 = this._typeDefinitions.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._typeDefinitions.remove_za3rmp$(value);
                        this._typeDefinitions.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj_1 = this._deployUnits.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findPackagesByID: function (key) {
              return this._packages.get_za3rmp$(key);
            },
            findTypeDefinitionsByNameVersion: function (name, version) {
              return this.findTypeDefinitionsByID('name=' + name + ',version=' + version);
            },
            findTypeDefinitionsByID: function (key) {
              return this._typeDefinitions.get_za3rmp$(key);
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_packages) {
                  return this.findPackagesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                  return this.findTypeDefinitionsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_packages, _.org.kevoree.util.Constants.org_kevoree_Package)) {
                  {
                    var tmp$0 = this._packages.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._packages.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_packages);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_packages);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$1 = this._typeDefinitions.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._typeDefinitions.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$2 = this._deployUnits.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Package;
            }
          }),
          DeployUnitImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DeployUnit, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_35i8a8$ = null;
            this.$internal_containmentRefName_23r6e8$ = null;
            this.$internal_unsetCmd_mr8vnp$ = null;
            this.$internal_readOnlyElem_3o8n45$ = false;
            this.$internal_recursive_readOnlyElem_dl0du6$ = false;
            this.$internal_inboundReferences_45iopf$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_lg6sgf$ = false;
            this.$internal_is_deleted_5y905k$ = false;
            this.$is_root_5d0ruf$ = false;
            this.$internal_modelElementListeners_9n22k8$ = null;
            this.$internal_modelTreeListeners_6i8p8$ = null;
            this.$path_cache_airkay$ = null;
            this.$key_cache_ctbw44$ = null;
            this.$name_8nxs2v$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_xzdcl2$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$hashcode_nqkelz$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$url_6lejz5$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._requiredLibs = new _.java.util.concurrent.ConcurrentHashMap();
            this._filters = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFiltersCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_35i8a8$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_35i8a8$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_23r6e8$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_23r6e8$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_mr8vnp$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_mr8vnp$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_3o8n45$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_3o8n45$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_dl0du6$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_dl0du6$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_45iopf$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_45iopf$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_lg6sgf$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_lg6sgf$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_5y905k$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_5y905k$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_5d0ruf$;
              },
              set: function (tmp$0) {
                this.$is_root_5d0ruf$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_9n22k8$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_9n22k8$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_6i8p8$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_6i8p8$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_airkay$;
              },
              set: function (tmp$0) {
                this.$path_cache_airkay$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ctbw44$;
              },
              set: function (tmp$0) {
                this.$key_cache_ctbw44$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.filters.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.removeAllRequiredLibs();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_8nxs2v$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_8nxs2v$;
                this.$name_8nxs2v$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_xzdcl2$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_xzdcl2$;
                this.$version_xzdcl2$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withHashcode: function (p) {
              this.hashcode = p;
              return this;
            },
            hashcode: {
              get: function () {
                return this.$hashcode_nqkelz$;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$hashcode_nqkelz$;
                this.$hashcode_nqkelz$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withUrl: function (p) {
              this.url = p;
              return this;
            },
            url: {
              get: function () {
                return this.$url_6lejz5$;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$url_6lejz5$;
                this.$url_6lejz5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal, this, oldPath));
                }
              }
            },
            requiredLibs: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                var kmf_previousVal = this._requiredLibs;
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequiredLibs: function (requiredLibsP) {
              var _key_ = requiredLibsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey_za3rmp$(_key_)) {
                this._requiredLibs.put_wn2jw4$(_key_, requiredLibsP);
                requiredLibsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
              }
            },
            addRequiredLibs: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            addAllRequiredLibs: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            internal_addRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null, this, this.path()));
              }
            },
            internal_addAllRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null, this, this.path()));
              }
            },
            removeRequiredLibs: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            removeAllRequiredLibs: function () {
              this.internal_removeAllRequiredLibs(true, true);
              return this;
            },
            internal_removeRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey_za3rmp$(requiredLibsP.internalGetKey())) {
                var previousPathToBeRemoved = requiredLibsP.path();
                this._requiredLibs.remove_za3rmp$(requiredLibsP.internalGetKey());
                requiredLibsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequiredLibs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.requiredLibs;
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els, null, this, this.path()));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                var kmf_previousVal = this._filters;
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_filters, el), _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = filtersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey_za3rmp$(_key_)) {
                this._filters.put_wn2jw4$(_key_, filtersP);
                filtersP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_filters, filtersP), _.org.kevoree.util.Constants.Ref_filters);
                filtersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
              return this;
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
              return this;
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
              return this;
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
              return this;
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(filtersP.internalGetKey())) {
                var previousPathToBeRemoved = filtersP.path();
                this._filters.remove_za3rmp$(filtersP.internalGetKey());
                filtersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                filtersP.setEContainer(null, null, null);
                if (!this.removeAllFiltersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFiltersCurrentlyProcessing = true;
              }
              var temp_els = this.filters;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, temp_els, null, this, this.path()));
                this.removeAllFiltersCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                  this.internal_hashcode(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_url) {
                  this.internal_url(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFilters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(value)) {
                        var obj = this._filters.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._filters.remove_za3rmp$(value);
                        this._filters.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequiredLibs();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey_za3rmp$(value)) {
                        var obj_0 = this._requiredLibs.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._requiredLibs.remove_za3rmp$(value);
                        this._requiredLibs.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'hashcode=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.hashcode)) + ',name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findFiltersByID: function (key) {
              return this._filters.get_za3rmp$(key);
            },
            findRequiredLibsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findRequiredLibsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findRequiredLibsByID: function (key) {
              return this._requiredLibs.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                  return this.findFiltersByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                  return this.findRequiredLibsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._filters.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._filters.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._requiredLibs.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._requiredLibs.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }
          }),
          DictionaryAttributeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DictionaryAttribute, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_lvd97j$ = null;
            this.$internal_containmentRefName_433nap$ = null;
            this.$internal_unsetCmd_d4moly$ = null;
            this.$internal_readOnlyElem_dvh67e$ = false;
            this.$internal_recursive_readOnlyElem_7db20z$ = false;
            this.$internal_inboundReferences_nemrp8$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_dt4myq$ = false;
            this.$internal_is_deleted_oo412v$ = false;
            this.$is_root_1tbtp6$ = false;
            this.$internal_modelElementListeners_o2bcqv$ = null;
            this.$internal_modelTreeListeners_25uplp$ = null;
            this.$path_cache_ls8h8b$ = null;
            this.$key_cache_jbpo9x$ = null;
            this.$name_1llm1k$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional_i4lpqb$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$state_likxw4$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$datatype_cs6br5$ = null;
            this.$fragmentDependant_mjin7y$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$defaultValue_irkhbn$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new _.java.util.concurrent.ConcurrentHashMap();
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_lvd97j$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_lvd97j$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_433nap$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_433nap$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_d4moly$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_d4moly$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_dvh67e$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_dvh67e$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7db20z$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7db20z$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_nemrp8$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_nemrp8$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_dt4myq$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_dt4myq$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_oo412v$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_oo412v$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_1tbtp6$;
              },
              set: function (tmp$0) {
                this.$is_root_1tbtp6$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_o2bcqv$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_o2bcqv$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_25uplp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_25uplp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ls8h8b$;
              },
              set: function (tmp$0) {
                this.$path_cache_ls8h8b$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_jbpo9x$;
              },
              set: function (tmp$0) {
                this.$key_cache_jbpo9x$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllGenericTypes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_1llm1k$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_1llm1k$;
                this.$name_1llm1k$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOptional: function (p) {
              this.optional = p;
              return this;
            },
            optional: {
              get: function () {
                return this.$optional_i4lpqb$;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional_i4lpqb$;
                this.$optional_i4lpqb$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal, this, oldPath));
                }
              }
            },
            withState: function (p) {
              this.state = p;
              return this;
            },
            state: {
              get: function () {
                return this.$state_likxw4$;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$state_likxw4$;
                this.$state_likxw4$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state, kmf_previousVal, this, oldPath));
                }
              }
            },
            withDatatype: function (p) {
              this.datatype = p;
              return this;
            },
            datatype: {
              get: function () {
                return this.$datatype_cs6br5$;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$datatype_cs6br5$;
                this.$datatype_cs6br5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype, kmf_previousVal, this, oldPath));
                }
              }
            },
            withFragmentDependant: function (p) {
              this.fragmentDependant = p;
              return this;
            },
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant_mjin7y$;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$fragmentDependant_mjin7y$;
                this.$fragmentDependant_mjin7y$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant, kmf_previousVal, this, oldPath));
                }
              }
            },
            withDefaultValue: function (p) {
              this.defaultValue = p;
              return this;
            },
            defaultValue: {
              get: function () {
                return this.$defaultValue_irkhbn$;
              },
              set: function (iP) {
                this.internal_defaultValue(iP, true);
              }
            },
            internal_defaultValue: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.defaultValue)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$defaultValue_irkhbn$;
                this.$defaultValue_irkhbn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_defaultValue, this.defaultValue, kmf_previousVal, this, oldPath));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = genericTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey_za3rmp$(_key_)) {
                this._genericTypes.put_wn2jw4$(_key_, genericTypesP);
                genericTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
              return this;
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
              return this;
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
              return this;
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
              return this;
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(genericTypesP.internalGetKey())) {
                var previousPathToBeRemoved = genericTypesP.path();
                this._genericTypes.remove_za3rmp$(genericTypesP.internalGetKey());
                genericTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.genericTypes;
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null, this, this.path()));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                  this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_state) {
                  this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                  var convValue;
                  if (Kotlin.isType(value, _.org.kevoree.DataType) || value == null) {
                    convValue = value;
                  }
                   else {
                    convValue = _.org.kevoree.DataType.object.valueOf(value.toString());
                  }
                  this.internal_datatype(convValue, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                  this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_defaultValue) {
                  this.internal_defaultValue(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGenericTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(value)) {
                        var obj = this._genericTypes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._genericTypes.remove_za3rmp$(value);
                        this._genericTypes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  return this.findGenericTypesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$0 = this._genericTypes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._genericTypes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
              visitor.visit(this.defaultValue, _.org.kevoree.util.Constants.Att_defaultValue, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }
          }),
          InstanceImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Instance, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_atfnfe$ = null;
            this.$internal_containmentRefName_y35zoq$ = null;
            this.$internal_unsetCmd_vhr633$ = null;
            this.$internal_readOnlyElem_4kdsgf$ = false;
            this.$internal_recursive_readOnlyElem_219qv8$ = false;
            this.$internal_inboundReferences_wwppr1$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_s155ff$ = false;
            this.$internal_is_deleted_80ovk2$ = false;
            this.$is_root_g1sn9v$ = false;
            this.$internal_modelElementListeners_q1vpta$ = null;
            this.$internal_modelTreeListeners_w5x1zq$ = null;
            this.$path_cache_4llyek$ = null;
            this.$key_cache_9lzfj6$ = null;
            this.$name_89emlt$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_l9ool9$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_18at2p$ = null;
            this.$dictionary_792vae$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_atfnfe$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_atfnfe$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_y35zoq$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_y35zoq$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_vhr633$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_vhr633$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_4kdsgf$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_4kdsgf$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_219qv8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_219qv8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_wwppr1$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_wwppr1$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_s155ff$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_s155ff$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_80ovk2$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_80ovk2$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_g1sn9v$;
              },
              set: function (tmp$0) {
                this.$is_root_g1sn9v$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_q1vpta$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_q1vpta$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_w5x1zq$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_w5x1zq$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_4llyek$;
              },
              set: function (tmp$0) {
                this.$path_cache_4llyek$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_9lzfj6$;
              },
              set: function (tmp$0) {
                this.$key_cache_9lzfj6$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_89emlt$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_89emlt$;
                this.$name_89emlt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_l9ool9$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_l9ool9$;
                this.$started_l9ool9$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_18at2p$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_18at2p$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_18at2p$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_18at2p$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_18at2p$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_18at2p$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_792vae$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_792vae$, dictionaryP)) {
                if (this.$dictionary_792vae$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_792vae$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_792vae$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_792vae$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_792vae$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_792vae$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }
          }),
          RepositoryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Repository, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_a6cpb$ = null;
            this.$internal_containmentRefName_bv5tnj$ = null;
            this.$internal_unsetCmd_y7t9hg$ = null;
            this.$internal_readOnlyElem_x4tpbw$ = false;
            this.$internal_recursive_readOnlyElem_7f0bld$ = false;
            this.$internal_inboundReferences_t1jnhu$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_c47wxc$ = false;
            this.$internal_is_deleted_2ikf61$ = false;
            this.$is_root_ypc8o$ = false;
            this.$internal_modelElementListeners_80yh95$ = null;
            this.$internal_modelTreeListeners_9xwvyj$ = null;
            this.$path_cache_kp14yf$ = null;
            this.$key_cache_mu7ust$ = null;
            this.$url_yffns0$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_a6cpb$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_a6cpb$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_bv5tnj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_bv5tnj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_y7t9hg$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_y7t9hg$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_x4tpbw$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_x4tpbw$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7f0bld$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7f0bld$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_t1jnhu$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_t1jnhu$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_c47wxc$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_c47wxc$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_2ikf61$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_2ikf61$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ypc8o$;
              },
              set: function (tmp$0) {
                this.$is_root_ypc8o$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_80yh95$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_80yh95$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9xwvyj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9xwvyj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_kp14yf$;
              },
              set: function (tmp$0) {
                this.$path_cache_kp14yf$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mu7ust$;
              },
              set: function (tmp$0) {
                this.$key_cache_mu7ust$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withUrl: function (p) {
              this.url = p;
              return this;
            },
            url: {
              get: function () {
                return this.$url_yffns0$;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$url_yffns0$;
                this.$url_yffns0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_url) {
                  this.internal_url(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.url));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }
          }),
          DictionaryTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DictionaryType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_abqpl7$ = null;
            this.$internal_containmentRefName_th108r$ = null;
            this.$internal_unsetCmd_evew46$ = null;
            this.$internal_readOnlyElem_7s0tm$ = false;
            this.$internal_recursive_readOnlyElem_8w37s9$ = false;
            this.$internal_inboundReferences_6a8xgo$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_tanora$ = false;
            this.$internal_is_deleted_d4hhgj$ = false;
            this.$is_root_fnbw2a$ = false;
            this.$internal_modelElementListeners_njfjeb$ = null;
            this.$internal_modelTreeListeners_ve9xxr$ = null;
            this.$path_cache_o0mo3z$ = null;
            this.$key_cache_x7wu1$ = null;
            this.$generated_KMF_ID_v48n7z$ = '' + Math.random() + (new Date()).getTime();
            this._attributes = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllAttributesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_abqpl7$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_abqpl7$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_th108r$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_th108r$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_evew46$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_evew46$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_7s0tm$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_7s0tm$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_8w37s9$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_8w37s9$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_6a8xgo$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_6a8xgo$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_tanora$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_tanora$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_d4hhgj$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_d4hhgj$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_fnbw2a$;
              },
              set: function (tmp$0) {
                this.$is_root_fnbw2a$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_njfjeb$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_njfjeb$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ve9xxr$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ve9xxr$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_o0mo3z$;
              },
              set: function (tmp$0) {
                this.$path_cache_o0mo3z$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_x7wu1$;
              },
              set: function (tmp$0) {
                this.$key_cache_x7wu1$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.attributes.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_v48n7z$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_v48n7z$;
                this.$generated_KMF_ID_v48n7z$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            attributes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                var kmf_previousVal = this._attributes;
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddAttributes: function (attributesP) {
              var _key_ = attributesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey_za3rmp$(_key_)) {
                this._attributes.put_wn2jw4$(_key_, attributesP);
                attributesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
                attributesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
              }
            },
            addAttributes: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
              return this;
            },
            addAllAttributes: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
              return this;
            },
            internal_addAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null, this, this.path()));
              }
            },
            internal_addAllAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null, this, this.path()));
              }
            },
            removeAttributes: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
              return this;
            },
            removeAllAttributes: function () {
              this.internal_removeAllAttributes(true, true);
              return this;
            },
            internal_removeAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey_za3rmp$(attributesP.internalGetKey())) {
                var previousPathToBeRemoved = attributesP.path();
                this._attributes.remove_za3rmp$(attributesP.internalGetKey());
                attributesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
                attributesP.setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllAttributes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var temp_els = this.attributes;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els, null, this, this.path()));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllAttributes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._attributes.size() !== 0 && this._attributes.containsKey_za3rmp$(value)) {
                        var obj = this._attributes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._attributes.remove_za3rmp$(value);
                        this._attributes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findAttributesByID: function (key) {
              return this._attributes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                  return this.findAttributesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute)) {
                  {
                    var tmp$0 = this._attributes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._attributes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }
          }),
          PortImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Port, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_bvc152$ = null;
            this.$internal_containmentRefName_137kiy$ = null;
            this.$internal_unsetCmd_sgp4aj$ = null;
            this.$internal_readOnlyElem_lu72yj$ = false;
            this.$internal_recursive_readOnlyElem_ggi4h4$ = false;
            this.$internal_inboundReferences_ml4lft$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_em7dbb$ = false;
            this.$internal_is_deleted_92l99q$ = false;
            this.$is_root_virmtb$ = false;
            this.$internal_modelElementListeners_gvwku6$ = null;
            this.$internal_modelTreeListeners_30gi7y$ = null;
            this.$path_cache_59dnk0$ = null;
            this.$key_cache_czftoq$ = null;
            this.$name_hp1bz1$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._bindings = new _.java.util.concurrent.ConcurrentHashMap();
            this.$portTypeRef_or8u3k$ = null;
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_bvc152$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_bvc152$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_137kiy$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_137kiy$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_sgp4aj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_sgp4aj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_lu72yj$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_lu72yj$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ggi4h4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ggi4h4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ml4lft$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ml4lft$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_em7dbb$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_em7dbb$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_92l99q$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_92l99q$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_virmtb$;
              },
              set: function (tmp$0) {
                this.$is_root_virmtb$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_gvwku6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_gvwku6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_30gi7y$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_30gi7y$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_59dnk0$;
              },
              set: function (tmp$0) {
                this.$path_cache_59dnk0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_czftoq$;
              },
              set: function (tmp$0) {
                this.$key_cache_czftoq$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllBindings();
              if (this.portTypeRef != null) {
                var tmp$0;
                ((tmp$0 = this.portTypeRef) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                this.portTypeRef = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_hp1bz1$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_hp1bz1$;
                this.$name_hp1bz1$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = bindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey_za3rmp$(_key_)) {
                this._bindings.put_wn2jw4$(_key_, bindingsP);
                bindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
              return this;
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
              return this;
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
              return this;
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
              return this;
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(bindingsP.internalGetKey())) {
                var previousPathToBeRemoved = bindingsP.path();
                this._bindings.remove_za3rmp$(bindingsP.internalGetKey());
                bindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.bindings;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null, this, this.path()));
              }
            },
            portTypeRef: {
              get: function () {
                return this.$portTypeRef_or8u3k$;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef_or8u3k$, portTypeRefP)) {
                var kmf_previousVal = this.$portTypeRef_or8u3k$;
                if (portTypeRefP != null) {
                  (portTypeRefP != null ? portTypeRefP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                }
                 else {
                  if (this.$portTypeRef_or8u3k$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$portTypeRef_or8u3k$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                  }
                }
                this.$portTypeRef_or8u3k$ = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withPortTypeRef: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllBindings(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(value)) {
                        var obj = this._bindings.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._bindings.remove_za3rmp$(value);
                        this._bindings.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_portTypeRef(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_portTypeRef(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_portTypeRef(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findBindingsByID: function (key) {
              return this._bindings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                  return this.findBindingsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                  var objFound = this.portTypeRef;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$0 = this._bindings.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._bindings.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }
          }),
          TypeDefinitionImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.TypeDefinition, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_iaeiwi$ = null;
            this.$internal_containmentRefName_b6ecla$ = null;
            this.$internal_unsetCmd_ghvhbb$ = null;
            this.$internal_readOnlyElem_aeygpz$ = false;
            this.$internal_recursive_readOnlyElem_2rbk30$ = false;
            this.$internal_inboundReferences_4kxylx$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_5f9unh$ = false;
            this.$internal_is_deleted_fhnr16$ = false;
            this.$is_root_c0gd3p$ = false;
            this.$internal_modelElementListeners_xjmu7e$ = null;
            this.$internal_modelTreeListeners_d3naaa$ = null;
            this.$path_cache_s6x66s$ = null;
            this.$key_cache_e2ad86$ = null;
            this.$name_vqbc21$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_ueb44s$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_9dkeku$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_yjvpuk$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.TypeDefinitionImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_iaeiwi$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_iaeiwi$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_b6ecla$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_b6ecla$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ghvhbb$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ghvhbb$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_aeygpz$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_aeygpz$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_2rbk30$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_2rbk30$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_4kxylx$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_4kxylx$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_5f9unh$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_5f9unh$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_fhnr16$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_fhnr16$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_c0gd3p$;
              },
              set: function (tmp$0) {
                this.$is_root_c0gd3p$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_xjmu7e$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_xjmu7e$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_d3naaa$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_d3naaa$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_s6x66s$;
              },
              set: function (tmp$0) {
                this.$path_cache_s6x66s$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_e2ad86$;
              },
              set: function (tmp$0) {
                this.$key_cache_e2ad86$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_vqbc21$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_vqbc21$;
                this.$name_vqbc21$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_ueb44s$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_ueb44s$;
                this.$version_ueb44s$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_9dkeku$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_9dkeku$;
                this.$abstract_9dkeku$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_yjvpuk$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_yjvpuk$, dictionaryTypeP)) {
                if (this.$dictionaryType_yjvpuk$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_yjvpuk$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_yjvpuk$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_yjvpuk$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_yjvpuk$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_yjvpuk$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeDefinition;
            }
          }),
          TypedElementImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.TypedElement, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_2p9ea1$ = null;
            this.$internal_containmentRefName_ogoop$ = null;
            this.$internal_unsetCmd_8v0lpo$ = null;
            this.$internal_readOnlyElem_b5dagc$ = false;
            this.$internal_recursive_readOnlyElem_al615l$ = false;
            this.$internal_inboundReferences_8tq63e$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_h0n10o$ = false;
            this.$internal_is_deleted_5i065d$ = false;
            this.$is_root_r50igg$ = false;
            this.$internal_modelElementListeners_utnavj$ = null;
            this.$internal_modelTreeListeners_2lpmdp$ = null;
            this.$path_cache_498g4v$ = null;
            this.$key_cache_7bw939$ = null;
            this.$name_2bmn4i$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new _.java.util.concurrent.ConcurrentHashMap();
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_2p9ea1$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_2p9ea1$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ogoop$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ogoop$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_8v0lpo$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_8v0lpo$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_b5dagc$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_b5dagc$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_al615l$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_al615l$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_8tq63e$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_8tq63e$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_h0n10o$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_h0n10o$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_5i065d$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_5i065d$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_r50igg$;
              },
              set: function (tmp$0) {
                this.$is_root_r50igg$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_utnavj$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_utnavj$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_2lpmdp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_2lpmdp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_498g4v$;
              },
              set: function (tmp$0) {
                this.$path_cache_498g4v$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_7bw939$;
              },
              set: function (tmp$0) {
                this.$key_cache_7bw939$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllGenericTypes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_2bmn4i$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_2bmn4i$;
                this.$name_2bmn4i$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = genericTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey_za3rmp$(_key_)) {
                this._genericTypes.put_wn2jw4$(_key_, genericTypesP);
                genericTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
              return this;
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
              return this;
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
              return this;
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
              return this;
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(genericTypesP.internalGetKey())) {
                var previousPathToBeRemoved = genericTypesP.path();
                this._genericTypes.remove_za3rmp$(genericTypesP.internalGetKey());
                genericTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.genericTypes;
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null, this, this.path()));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGenericTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(value)) {
                        var obj = this._genericTypes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._genericTypes.remove_za3rmp$(value);
                        this._genericTypes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  return this.findGenericTypesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$0 = this._genericTypes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._genericTypes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }
          }),
          ContainerNodeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ContainerNode, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_ff71em$ = null;
            this.$internal_containmentRefName_5lz5gu$ = null;
            this.$internal_unsetCmd_537mr1$ = null;
            this.$internal_readOnlyElem_pjij83$ = false;
            this.$internal_recursive_readOnlyElem_mlmdhc$ = false;
            this.$internal_inboundReferences_ywu8v3$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_50jgan$ = false;
            this.$internal_is_deleted_cmg9ja$ = false;
            this.$is_root_ets2fr$ = false;
            this.$internal_modelElementListeners_p0q5cm$ = null;
            this.$internal_modelTreeListeners_3oq7ru$ = null;
            this.$path_cache_ixfdyg$ = null;
            this.$key_cache_mxha8y$ = null;
            this.$name_fcvh8r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_k1o3r5$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$host_fcrxuw$ = null;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._hosts = new _.java.util.concurrent.ConcurrentHashMap();
            this.$typeDefinition_ydov9v$ = null;
            this._components = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllComponentsCurrentlyProcessing = false;
            this.$dictionary_72qk9i$ = null;
            this._networkInformation = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllNetworkInformationCurrentlyProcessing = false;
            this._groups = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_ff71em$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_ff71em$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_5lz5gu$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_5lz5gu$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_537mr1$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_537mr1$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_pjij83$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_pjij83$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_mlmdhc$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_mlmdhc$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ywu8v3$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ywu8v3$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_50jgan$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_50jgan$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_cmg9ja$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_cmg9ja$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ets2fr$;
              },
              set: function (tmp$0) {
                this.$is_root_ets2fr$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_p0q5cm$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_p0q5cm$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_3oq7ru$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_3oq7ru$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ixfdyg$;
              },
              set: function (tmp$0) {
                this.$path_cache_ixfdyg$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mxha8y$;
              },
              set: function (tmp$0) {
                this.$key_cache_mxha8y$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              {
                var tmp$4 = this.components.iterator();
                while (tmp$4.hasNext()) {
                  var el_1 = tmp$4.next();
                  el_1.delete();
                }
              }
              this.removeAllHosts();
              if (this.host != null) {
                var tmp$5;
                ((tmp$5 = this.host) != null ? tmp$5 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                this.host = null;
              }
              this.removeAllGroups();
              {
                var tmp$6 = this.networkInformation.iterator();
                while (tmp$6.hasNext()) {
                  var el_2 = tmp$6.next();
                  el_2.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$7;
                ((tmp$7 = this.internal_unsetCmd) != null ? tmp$7 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_fcvh8r$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_fcvh8r$;
                this.$name_fcvh8r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_k1o3r5$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_k1o3r5$;
                this.$started_k1o3r5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            host: {
              get: function () {
                return this.$host_fcrxuw$;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host_fcrxuw$, hostP)) {
                if (setOpposite) {
                  if (this.$host_fcrxuw$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host_fcrxuw$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$host_fcrxuw$;
                if (hostP != null) {
                  (hostP != null ? hostP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                }
                 else {
                  if (this.$host_fcrxuw$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$host_fcrxuw$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                  }
                }
                this.$host_fcrxuw$ = hostP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withHost: function (ref) {
              return this;
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            hosts: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                var kmf_previousVal = this._hosts;
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddHosts: function (hostsP) {
              var _key_ = hostsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey_za3rmp$(_key_)) {
                this._hosts.put_wn2jw4$(_key_, hostsP);
                hostsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
              }
            },
            addHosts: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
              return this;
            },
            addAllHosts: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
              return this;
            },
            internal_addHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                hostsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null, this, this.path()));
              }
            },
            internal_addAllHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null, this, this.path()));
              }
            },
            removeHosts: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
              return this;
            },
            removeAllHosts: function () {
              this.internal_removeAllHosts(true, true);
              return this;
            },
            internal_removeHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey_za3rmp$(hostsP.internalGetKey())) {
                var previousPathToBeRemoved = hostsP.path();
                this._hosts.remove_za3rmp$(hostsP.internalGetKey());
                hostsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  hostsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            },
            internal_removeAllHosts: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.hosts;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els, null, this, this.path()));
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_ydov9v$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_ydov9v$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_ydov9v$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_ydov9v$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_ydov9v$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_ydov9v$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            components: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                var kmf_previousVal = this._components;
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddComponents: function (componentsP) {
              var _key_ = componentsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey_za3rmp$(_key_)) {
                this._components.put_wn2jw4$(_key_, componentsP);
                componentsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
                componentsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
              }
            },
            addComponents: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
              return this;
            },
            addAllComponents: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
              return this;
            },
            internal_addComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null, this, this.path()));
              }
            },
            internal_addAllComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null, this, this.path()));
              }
            },
            removeComponents: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
              return this;
            },
            removeAllComponents: function () {
              this.internal_removeAllComponents(true, true);
              return this;
            },
            internal_removeComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey_za3rmp$(componentsP.internalGetKey())) {
                var previousPathToBeRemoved = componentsP.path();
                this._components.remove_za3rmp$(componentsP.internalGetKey());
                componentsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
                componentsP.setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllComponents: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var temp_els = this.components;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els, null, this, this.path()));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary_72qk9i$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_72qk9i$, dictionaryP)) {
                if (this.$dictionary_72qk9i$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_72qk9i$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_72qk9i$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_72qk9i$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_72qk9i$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_72qk9i$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            networkInformation: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._networkInformation.values());
              },
              set: function (networkInformationP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkInformationP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkInformation(networkInformationP, true, true);
              }
            },
            internal_networkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkInformation.values(), networkInformationP)) {
                var kmf_previousVal = this._networkInformation;
                this._networkInformation.clear();
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkInformation.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, el), _.org.kevoree.util.Constants.Ref_networkInformation);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddNetworkInformation: function (networkInformationP) {
              var _key_ = networkInformationP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkInformation.containsKey_za3rmp$(_key_)) {
                this._networkInformation.put_wn2jw4$(_key_, networkInformationP);
                networkInformationP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP), _.org.kevoree.util.Constants.Ref_networkInformation);
                networkInformationP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
              }
            },
            addNetworkInformation: function (networkInformationP) {
              this.internal_addNetworkInformation(networkInformationP, true, true);
              return this;
            },
            addAllNetworkInformation: function (networkInformationP) {
              this.internal_addAllNetworkInformation(networkInformationP, true, true);
              return this;
            },
            internal_addNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkInformation(networkInformationP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null, this, this.path()));
              }
            },
            internal_addAllNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkInformation(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkInformationP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkInformation(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null, this, this.path()));
              }
            },
            removeNetworkInformation: function (networkInformationP) {
              this.internal_removeNetworkInformation(networkInformationP, true, true);
              return this;
            },
            removeAllNetworkInformation: function () {
              this.internal_removeAllNetworkInformation(true, true);
              return this;
            },
            internal_removeNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey_za3rmp$(networkInformationP.internalGetKey())) {
                var previousPathToBeRemoved = networkInformationP.path();
                this._networkInformation.remove_za3rmp$(networkInformationP.internalGetKey());
                networkInformationP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
                networkInformationP.setEContainer(null, null, null);
                if (!this.removeAllNetworkInformationCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllNetworkInformation: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkInformationCurrentlyProcessing = true;
              }
              var temp_els = this.networkInformation;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._networkInformation.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, temp_els, null, this, this.path()));
                this.removeAllNetworkInformationCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this.internal_removeAllGroups(true, false);
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = groupsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey_za3rmp$(_key_)) {
                this._groups.put_wn2jw4$(_key_, groupsP);
                groupsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
              return this;
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
              return this;
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (setOpposite) {
                groupsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
              return this;
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
              return this;
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(groupsP.internalGetKey())) {
                var previousPathToBeRemoved = groupsP.path();
                this._groups.remove_za3rmp$(groupsP.internalGetKey());
                groupsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  groupsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.groups;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllComponents();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._components.size() !== 0 && this._components.containsKey_za3rmp$(value)) {
                        var obj_1 = this._components.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._components.remove_za3rmp$(value);
                        this._components.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllHosts(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._hosts.size() !== 0 && this._hosts.containsKey_za3rmp$(value)) {
                        var obj_2 = this._hosts.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._hosts.remove_za3rmp$(value);
                        this._hosts.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_host(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_host(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_host(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllGroups(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(value)) {
                        var obj_3 = this._groups.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._groups.remove_za3rmp$(value);
                        this._groups.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllNetworkInformation();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey_za3rmp$(value)) {
                        var obj_4 = this._networkInformation.get_za3rmp$(value);
                        var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_4 == null) {
                          throw new Error('Key newed to null ' + obj_4);
                        }
                        this._networkInformation.remove_za3rmp$(value);
                        this._networkInformation.put_wn2jw4$(objNewKey_4, obj_4);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findComponentsByID: function (key) {
              return this._components.get_za3rmp$(key);
            },
            findHostsByID: function (key) {
              return this._hosts.get_za3rmp$(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get_za3rmp$(key);
            },
            findNetworkInformationByID: function (key) {
              return this._networkInformation.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                  return this.findComponentsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                  return this.findHostsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                  var objFound_1 = this.host;
                  if (objFound_1 != null && Kotlin.equals(objFound_1.internalGetKey(), idP)) {
                    return objFound_1;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                  return this.findGroupsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                  return this.findNetworkInformationByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance)) {
                  {
                    var tmp$2 = this._components.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._components.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation, _.org.kevoree.util.Constants.org_kevoree_NetworkInfo)) {
                  {
                    var tmp$3 = this._networkInformation.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._networkInformation.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkInformation);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$4 = this._hosts.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._hosts.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group)) {
                  {
                    var tmp$5 = this._groups.keySet().iterator();
                    while (tmp$5.hasNext()) {
                      var KMFLoopEntryKey_4 = tmp$5.next();
                      this.internal_visit(visitor, this._groups.get_za3rmp$(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }
          }),
          OperationImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Operation, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_pqk4f2$ = null;
            this.$internal_containmentRefName_27os7i$ = null;
            this.$internal_unsetCmd_5vpuxj$ = null;
            this.$internal_readOnlyElem_z56mjb$ = false;
            this.$internal_recursive_readOnlyElem_gorlz8$ = false;
            this.$internal_inboundReferences_201nfp$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_czmfib$ = false;
            this.$internal_is_deleted_sjawae$ = false;
            this.$is_root_2hwzyz$ = false;
            this.$internal_modelElementListeners_cwp63q$ = null;
            this.$internal_modelTreeListeners_44xpwi$ = null;
            this.$path_cache_arte78$ = null;
            this.$key_cache_ym6fq2$ = null;
            this.$name_p49yk9$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._parameters = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllParametersCurrentlyProcessing = false;
            this.$returnType_dn3q2u$ = null;
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_pqk4f2$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_pqk4f2$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_27os7i$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_27os7i$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_5vpuxj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_5vpuxj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_z56mjb$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_z56mjb$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_gorlz8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_gorlz8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_201nfp$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_201nfp$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_czmfib$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_czmfib$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_sjawae$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_sjawae$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_2hwzyz$;
              },
              set: function (tmp$0) {
                this.$is_root_2hwzyz$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_cwp63q$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_cwp63q$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_44xpwi$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_44xpwi$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_arte78$;
              },
              set: function (tmp$0) {
                this.$path_cache_arte78$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ym6fq2$;
              },
              set: function (tmp$0) {
                this.$key_cache_ym6fq2$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.parameters.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              if (this.returnType != null) {
                var tmp$1;
                ((tmp$1 = this.returnType) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                this.returnType = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_p49yk9$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_p49yk9$;
                this.$name_p49yk9$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            parameters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                var kmf_previousVal = this._parameters;
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddParameters: function (parametersP) {
              var _key_ = parametersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey_za3rmp$(_key_)) {
                this._parameters.put_wn2jw4$(_key_, parametersP);
                parametersP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
                parametersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
              }
            },
            addParameters: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
              return this;
            },
            addAllParameters: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
              return this;
            },
            internal_addParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null, this, this.path()));
              }
            },
            internal_addAllParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null, this, this.path()));
              }
            },
            removeParameters: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
              return this;
            },
            removeAllParameters: function () {
              this.internal_removeAllParameters(true, true);
              return this;
            },
            internal_removeParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey_za3rmp$(parametersP.internalGetKey())) {
                var previousPathToBeRemoved = parametersP.path();
                this._parameters.remove_za3rmp$(parametersP.internalGetKey());
                parametersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
                parametersP.setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllParameters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var temp_els = this.parameters;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els, null, this, this.path()));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            },
            returnType: {
              get: function () {
                return this.$returnType_dn3q2u$;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType_dn3q2u$, returnTypeP)) {
                var kmf_previousVal = this.$returnType_dn3q2u$;
                if (returnTypeP != null) {
                  (returnTypeP != null ? returnTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                }
                 else {
                  if (this.$returnType_dn3q2u$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$returnType_dn3q2u$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                  }
                }
                this.$returnType_dn3q2u$ = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withReturnType: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllParameters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._parameters.size() !== 0 && this._parameters.containsKey_za3rmp$(value)) {
                        var obj = this._parameters.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._parameters.remove_za3rmp$(value);
                        this._parameters.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_returnType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_returnType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_returnType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findParametersByID: function (key) {
              return this._parameters.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                  return this.findParametersByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                  var objFound = this.returnType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter)) {
                  {
                    var tmp$0 = this._parameters.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._parameters.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }
          }),
          ComponentTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ComponentType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_16ip9q$ = null;
            this.$internal_containmentRefName_u5b5cu$ = null;
            this.$internal_unsetCmd_3rxrnd$ = null;
            this.$internal_readOnlyElem_j7e9vd$ = false;
            this.$internal_recursive_readOnlyElem_ocbfg4$ = false;
            this.$internal_inboundReferences_c2fo45$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_12zpjh$ = false;
            this.$internal_is_deleted_3z9h52$ = false;
            this.$is_root_jjvnxx$ = false;
            this.$internal_modelElementListeners_vhhkc6$ = null;
            this.$internal_modelTreeListeners_w2k31u$ = null;
            this.$path_cache_g5zodw$ = null;
            this.$key_cache_doblxy$ = null;
            this.$name_kd67dj$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_muvtak$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_b99riq$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_n08r3w$ = null;
            this._provided = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllProvidedCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._required = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRequiredCurrentlyProcessing = false;
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_16ip9q$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_16ip9q$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_u5b5cu$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_u5b5cu$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_3rxrnd$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_3rxrnd$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_j7e9vd$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_j7e9vd$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ocbfg4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ocbfg4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_c2fo45$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_c2fo45$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_12zpjh$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_12zpjh$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3z9h52$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3z9h52$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_jjvnxx$;
              },
              set: function (tmp$0) {
                this.$is_root_jjvnxx$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_vhhkc6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_vhhkc6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_w2k31u$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_w2k31u$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_g5zodw$;
              },
              set: function (tmp$0) {
                this.$path_cache_g5zodw$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_doblxy$;
              },
              set: function (tmp$0) {
                this.$key_cache_doblxy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              {
                var tmp$2 = this.required.iterator();
                while (tmp$2.hasNext()) {
                  var el_0 = tmp$2.next();
                  el_0.delete();
                }
              }
              {
                var tmp$3 = this.provided.iterator();
                while (tmp$3.hasNext()) {
                  var el_1 = tmp$3.next();
                  el_1.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_kd67dj$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_kd67dj$;
                this.$name_kd67dj$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_muvtak$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_muvtak$;
                this.$version_muvtak$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_b99riq$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_b99riq$;
                this.$abstract_b99riq$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_n08r3w$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_n08r3w$, dictionaryTypeP)) {
                if (this.$dictionaryType_n08r3w$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_n08r3w$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_n08r3w$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_n08r3w$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_n08r3w$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_n08r3w$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            provided: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = providedP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey_za3rmp$(_key_)) {
                this._provided.put_wn2jw4$(_key_, providedP);
                providedP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
                providedP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
              return this;
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
              return this;
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
              return this;
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
              return this;
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(providedP.internalGetKey())) {
                var previousPathToBeRemoved = providedP.path();
                this._provided.remove_za3rmp$(providedP.internalGetKey());
                providedP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                providedP.setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var temp_els = this.provided;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null, this, this.path()));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = requiredP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey_za3rmp$(_key_)) {
                this._required.put_wn2jw4$(_key_, requiredP);
                requiredP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
                requiredP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
              return this;
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
              return this;
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
              return this;
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
              return this;
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(requiredP.internalGetKey())) {
                var previousPathToBeRemoved = requiredP.path();
                this._required.remove_za3rmp$(requiredP.internalGetKey());
                requiredP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                requiredP.setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var temp_els = this.required;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null, this, this.path()));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequired();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(value)) {
                        var obj_2 = this._required.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._required.remove_za3rmp$(value);
                        this._required.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllProvided();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(value)) {
                        var obj_3 = this._provided.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._provided.remove_za3rmp$(value);
                        this._provided.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findRequiredByID: function (key) {
              return this._required.get_za3rmp$(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                  return this.findRequiredByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                  return this.findProvidedByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  {
                    var tmp$1 = this._required.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._required.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  {
                    var tmp$2 = this._provided.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._provided.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$3 = this._deployUnits.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$4 = this._superTypes.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }
          }),
          DictionaryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Dictionary, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_k4mdcr$ = null;
            this.$internal_containmentRefName_g7blud$ = null;
            this.$internal_unsetCmd_eeb2i8$ = null;
            this.$internal_readOnlyElem_2akz4g$ = false;
            this.$internal_recursive_readOnlyElem_4zk8hv$ = false;
            this.$internal_inboundReferences_bams8y$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_weooqs$ = false;
            this.$internal_is_deleted_hbvlhf$ = false;
            this.$is_root_6jhz4k$ = false;
            this.$internal_modelElementListeners_jvapyr$ = null;
            this.$internal_modelTreeListeners_i4kjjd$ = null;
            this.$path_cache_g2g5fv$ = null;
            this.$key_cache_fyp1nj$ = null;
            this.$generated_KMF_ID_gzg1jr$ = '' + Math.random() + (new Date()).getTime();
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_k4mdcr$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_k4mdcr$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_g7blud$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_g7blud$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_eeb2i8$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_eeb2i8$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_2akz4g$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_2akz4g$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_4zk8hv$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_4zk8hv$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_bams8y$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_bams8y$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_weooqs$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_weooqs$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_hbvlhf$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_hbvlhf$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_6jhz4k$;
              },
              set: function (tmp$0) {
                this.$is_root_6jhz4k$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_jvapyr$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_jvapyr$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_i4kjjd$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_i4kjjd$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_g2g5fv$;
              },
              set: function (tmp$0) {
                this.$path_cache_g2g5fv$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_fyp1nj$;
              },
              set: function (tmp$0) {
                this.$key_cache_fyp1nj$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_gzg1jr$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_gzg1jr$;
                this.$generated_KMF_ID_gzg1jr$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }
          }),
          NamedElementImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NamedElement, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_8krigo$ = null;
            this.$internal_containmentRefName_b6nctk$ = null;
            this.$internal_unsetCmd_l75xml$ = null;
            this.$internal_readOnlyElem_ndc2pv$ = false;
            this.$internal_recursive_readOnlyElem_rvab4m$ = false;
            this.$internal_inboundReferences_bgglkl$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_r66dux$ = false;
            this.$internal_is_deleted_bdiac0$ = false;
            this.$is_root_4096f3$ = false;
            this.$internal_modelElementListeners_rhbydc$ = null;
            this.$internal_modelTreeListeners_d3waik$ = null;
            this.$path_cache_ez6iq$ = null;
            this.$key_cache_yz673o$ = null;
            this.$name_rkp09r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.NamedElementImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_8krigo$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_8krigo$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_b6nctk$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_b6nctk$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_l75xml$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_l75xml$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ndc2pv$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ndc2pv$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_rvab4m$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_rvab4m$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_bgglkl$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_bgglkl$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_r66dux$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_r66dux$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_bdiac0$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_bdiac0$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_4096f3$;
              },
              set: function (tmp$0) {
                this.$is_root_4096f3$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_rhbydc$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_rhbydc$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_d3waik$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_d3waik$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ez6iq$;
              },
              set: function (tmp$0) {
                this.$path_cache_ez6iq$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_yz673o$;
              },
              set: function (tmp$0) {
                this.$key_cache_yz673o$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_rkp09r$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_rkp09r$;
                this.$name_rkp09r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NamedElement;
            }
          }),
          ValueImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Value, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_uv178$ = null;
            this.$internal_containmentRefName_qtk5h8$ = null;
            this.$internal_unsetCmd_47w2zj$ = null;
            this.$internal_readOnlyElem_7uz0yp$ = false;
            this.$internal_recursive_readOnlyElem_km7vxu$ = false;
            this.$internal_inboundReferences_3ctd4f$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_3s3le5$ = false;
            this.$internal_is_deleted_3nlt2k$ = false;
            this.$is_root_dw4jvp$ = false;
            this.$internal_modelElementListeners_tjebvo$ = null;
            this.$internal_modelTreeListeners_owb7s8$ = null;
            this.$path_cache_e2vdqy$ = null;
            this.$key_cache_n1wff4$ = null;
            this.$name_drlocj$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$value_glagx$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.ValueImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_uv178$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_uv178$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_qtk5h8$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_qtk5h8$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_47w2zj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_47w2zj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_7uz0yp$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_7uz0yp$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_km7vxu$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_km7vxu$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_3ctd4f$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_3ctd4f$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_3s3le5$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_3s3le5$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3nlt2k$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3nlt2k$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_dw4jvp$;
              },
              set: function (tmp$0) {
                this.$is_root_dw4jvp$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_tjebvo$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_tjebvo$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_owb7s8$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_owb7s8$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_e2vdqy$;
              },
              set: function (tmp$0) {
                this.$path_cache_e2vdqy$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_n1wff4$;
              },
              set: function (tmp$0) {
                this.$key_cache_n1wff4$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_drlocj$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_drlocj$;
                this.$name_drlocj$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withValue: function (p) {
              this.value = p;
              return this;
            },
            value: {
              get: function () {
                return this.$value_glagx$;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$value_glagx$;
                this.$value_glagx$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value, kmf_previousVal, this, oldPath));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_value) {
                  this.internal_value(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Value;
            }
          }),
          ContainerRootImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ContainerRoot, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_dv9q2q$ = null;
            this.$internal_containmentRefName_7fk4aa$ = null;
            this.$internal_unsetCmd_9fvvn7$ = null;
            this.$internal_readOnlyElem_5emnqr$ = false;
            this.$internal_recursive_readOnlyElem_qqvtb4$ = false;
            this.$internal_inboundReferences_yhoz9b$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_7ajevz$ = false;
            this.$internal_is_deleted_go0hy2$ = false;
            this.$is_root_te1ulz$ = false;
            this.$internal_modelElementListeners_vka3d6$ = null;
            this.$internal_modelTreeListeners_9ct1za$ = null;
            this.$path_cache_bkt1u0$ = null;
            this.$key_cache_ozfj7m$ = null;
            this.$generated_KMF_ID_vwh4di$ = '' + Math.random() + (new Date()).getTime();
            this._mBindings = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMBindingsCurrentlyProcessing = false;
            this._packages = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllPackagesCurrentlyProcessing = false;
            this._repositories = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRepositoriesCurrentlyProcessing = false;
            this._nodes = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllNodesCurrentlyProcessing = false;
            this._groups = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllGroupsCurrentlyProcessing = false;
            this._hubs = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllHubsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_dv9q2q$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_dv9q2q$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_7fk4aa$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_7fk4aa$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_9fvvn7$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_9fvvn7$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_5emnqr$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_5emnqr$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_qqvtb4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_qqvtb4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_yhoz9b$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_yhoz9b$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_7ajevz$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_7ajevz$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_go0hy2$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_go0hy2$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_te1ulz$;
              },
              set: function (tmp$0) {
                this.$is_root_te1ulz$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_vka3d6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_vka3d6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9ct1za$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9ct1za$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_bkt1u0$;
              },
              set: function (tmp$0) {
                this.$path_cache_bkt1u0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ozfj7m$;
              },
              set: function (tmp$0) {
                this.$key_cache_ozfj7m$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.nodes.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              {
                var tmp$1 = this.repositories.iterator();
                while (tmp$1.hasNext()) {
                  var el_0 = tmp$1.next();
                  el_0.delete();
                }
              }
              {
                var tmp$2 = this.hubs.iterator();
                while (tmp$2.hasNext()) {
                  var el_1 = tmp$2.next();
                  el_1.delete();
                }
              }
              {
                var tmp$3 = this.mBindings.iterator();
                while (tmp$3.hasNext()) {
                  var el_2 = tmp$3.next();
                  el_2.delete();
                }
              }
              {
                var tmp$4 = this.groups.iterator();
                while (tmp$4.hasNext()) {
                  var el_3 = tmp$4.next();
                  el_3.delete();
                }
              }
              {
                var tmp$5 = this.packages.iterator();
                while (tmp$5.hasNext()) {
                  var el_4 = tmp$5.next();
                  el_4.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$6;
                ((tmp$6 = this.internal_unsetCmd) != null ? tmp$6 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_vwh4di$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_vwh4di$;
                this.$generated_KMF_ID_vwh4di$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            mBindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                var kmf_previousVal = this._mBindings;
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMBindings: function (mBindingsP) {
              var _key_ = mBindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey_za3rmp$(_key_)) {
                this._mBindings.put_wn2jw4$(_key_, mBindingsP);
                mBindingsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
                mBindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
              }
            },
            addMBindings: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
              return this;
            },
            addAllMBindings: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
              return this;
            },
            internal_addMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null, this, this.path()));
              }
            },
            internal_addAllMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null, this, this.path()));
              }
            },
            removeMBindings: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
              return this;
            },
            removeAllMBindings: function () {
              this.internal_removeAllMBindings(true, true);
              return this;
            },
            internal_removeMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey_za3rmp$(mBindingsP.internalGetKey())) {
                var previousPathToBeRemoved = mBindingsP.path();
                this._mBindings.remove_za3rmp$(mBindingsP.internalGetKey());
                mBindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
                mBindingsP.setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var temp_els = this.mBindings;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els, null, this, this.path()));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            },
            packages: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._packages.values());
              },
              set: function (packagesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (packagesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_packages(packagesP, true, true);
              }
            },
            internal_packages: function (packagesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._packages.values(), packagesP)) {
                var kmf_previousVal = this._packages;
                this._packages.clear();
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._packages.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, el), _.org.kevoree.util.Constants.Ref_packages);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddPackages: function (packagesP) {
              var _key_ = packagesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._packages.containsKey_za3rmp$(_key_)) {
                this._packages.put_wn2jw4$(_key_, packagesP);
                packagesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, packagesP), _.org.kevoree.util.Constants.Ref_packages);
                packagesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
              }
            },
            addPackages: function (packagesP) {
              this.internal_addPackages(packagesP, true, true);
              return this;
            },
            addAllPackages: function (packagesP) {
              this.internal_addAllPackages(packagesP, true, true);
              return this;
            },
            internal_addPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPackages(packagesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            internal_addAllPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPackages(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = packagesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPackages(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            removePackages: function (packagesP) {
              this.internal_removePackages(packagesP, true, true);
              return this;
            },
            removeAllPackages: function () {
              this.internal_removeAllPackages(true, true);
              return this;
            },
            internal_removePackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(packagesP.internalGetKey())) {
                var previousPathToBeRemoved = packagesP.path();
                this._packages.remove_za3rmp$(packagesP.internalGetKey());
                packagesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                packagesP.setEContainer(null, null, null);
                if (!this.removeAllPackagesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllPackages: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllPackagesCurrentlyProcessing = true;
              }
              var temp_els = this.packages;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._packages.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, temp_els, null, this, this.path()));
                this.removeAllPackagesCurrentlyProcessing = false;
              }
            },
            repositories: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                var kmf_previousVal = this._repositories;
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRepositories: function (repositoriesP) {
              var _key_ = repositoriesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey_za3rmp$(_key_)) {
                this._repositories.put_wn2jw4$(_key_, repositoriesP);
                repositoriesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
                repositoriesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
              }
            },
            addRepositories: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
              return this;
            },
            addAllRepositories: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
              return this;
            },
            internal_addRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null, this, this.path()));
              }
            },
            internal_addAllRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null, this, this.path()));
              }
            },
            removeRepositories: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
              return this;
            },
            removeAllRepositories: function () {
              this.internal_removeAllRepositories(true, true);
              return this;
            },
            internal_removeRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey_za3rmp$(repositoriesP.internalGetKey())) {
                var previousPathToBeRemoved = repositoriesP.path();
                this._repositories.remove_za3rmp$(repositoriesP.internalGetKey());
                repositoriesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
                repositoriesP.setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRepositories: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var temp_els = this.repositories;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els, null, this, this.path()));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            },
            nodes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                var kmf_previousVal = this._nodes;
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddNodes: function (nodesP) {
              var _key_ = nodesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey_za3rmp$(_key_)) {
                this._nodes.put_wn2jw4$(_key_, nodesP);
                nodesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
                nodesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
              }
            },
            addNodes: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
              return this;
            },
            addAllNodes: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
              return this;
            },
            internal_addNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null, this, this.path()));
              }
            },
            internal_addAllNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null, this, this.path()));
              }
            },
            removeNodes: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
              return this;
            },
            removeAllNodes: function () {
              this.internal_removeAllNodes(true, true);
              return this;
            },
            internal_removeNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey_za3rmp$(nodesP.internalGetKey())) {
                var previousPathToBeRemoved = nodesP.path();
                this._nodes.remove_za3rmp$(nodesP.internalGetKey());
                nodesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
                nodesP.setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var temp_els = this.nodes;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els, null, this, this.path()));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = groupsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey_za3rmp$(_key_)) {
                this._groups.put_wn2jw4$(_key_, groupsP);
                groupsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
                groupsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
              return this;
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
              return this;
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
              return this;
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
              return this;
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(groupsP.internalGetKey())) {
                var previousPathToBeRemoved = groupsP.path();
                this._groups.remove_za3rmp$(groupsP.internalGetKey());
                groupsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                groupsP.setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var temp_els = this.groups;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els, null, this, this.path()));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            },
            hubs: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                var kmf_previousVal = this._hubs;
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddHubs: function (hubsP) {
              var _key_ = hubsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey_za3rmp$(_key_)) {
                this._hubs.put_wn2jw4$(_key_, hubsP);
                hubsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
                hubsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
              }
            },
            addHubs: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
              return this;
            },
            addAllHubs: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
              return this;
            },
            internal_addHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null, this, this.path()));
              }
            },
            internal_addAllHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null, this, this.path()));
              }
            },
            removeHubs: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
              return this;
            },
            removeAllHubs: function () {
              this.internal_removeAllHubs(true, true);
              return this;
            },
            internal_removeHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey_za3rmp$(hubsP.internalGetKey())) {
                var previousPathToBeRemoved = hubsP.path();
                this._hubs.remove_za3rmp$(hubsP.internalGetKey());
                hubsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
                hubsP.setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllHubs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var temp_els = this.hubs;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els, null, this, this.path()));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllNodes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._nodes.size() !== 0 && this._nodes.containsKey_za3rmp$(value)) {
                        var obj = this._nodes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._nodes.remove_za3rmp$(value);
                        this._nodes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRepositories();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._repositories.size() !== 0 && this._repositories.containsKey_za3rmp$(value)) {
                        var obj_0 = this._repositories.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._repositories.remove_za3rmp$(value);
                        this._repositories.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllHubs();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._hubs.size() !== 0 && this._hubs.containsKey_za3rmp$(value)) {
                        var obj_1 = this._hubs.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._hubs.remove_za3rmp$(value);
                        this._hubs.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMBindings();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._mBindings.size() !== 0 && this._mBindings.containsKey_za3rmp$(value)) {
                        var obj_2 = this._mBindings.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._mBindings.remove_za3rmp$(value);
                        this._mBindings.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGroups();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(value)) {
                        var obj_3 = this._groups.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._groups.remove_za3rmp$(value);
                        this._groups.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_packages) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removePackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllPackages();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(value)) {
                        var obj_4 = this._packages.get_za3rmp$(value);
                        var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_4 == null) {
                          throw new Error('Key newed to null ' + obj_4);
                        }
                        this._packages.remove_za3rmp$(value);
                        this._packages.put_wn2jw4$(objNewKey_4, obj_4);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findNodesByID: function (key) {
              return this._nodes.get_za3rmp$(key);
            },
            findRepositoriesByID: function (key) {
              return this._repositories.get_za3rmp$(key);
            },
            findHubsByID: function (key) {
              return this._hubs.get_za3rmp$(key);
            },
            findMBindingsByID: function (key) {
              return this._mBindings.get_za3rmp$(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get_za3rmp$(key);
            },
            findPackagesByID: function (key) {
              return this._packages.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                  return this.findNodesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                  return this.findRepositoriesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                  return this.findHubsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                  return this.findMBindingsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                  return this.findGroupsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_packages) {
                  return this.findPackagesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$0 = this._nodes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._nodes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository)) {
                  {
                    var tmp$1 = this._repositories.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._repositories.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel)) {
                  {
                    var tmp$2 = this._hubs.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._hubs.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$3 = this._mBindings.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._mBindings.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group)) {
                  {
                    var tmp$4 = this._groups.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._groups.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_packages, _.org.kevoree.util.Constants.org_kevoree_Package)) {
                  {
                    var tmp$5 = this._packages.keySet().iterator();
                    while (tmp$5.hasNext()) {
                      var KMFLoopEntryKey_4 = tmp$5.next();
                      this.internal_visit(visitor, this._packages.get_za3rmp$(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_packages);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_packages);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }
          }),
          ChannelTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ChannelType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_p3y5rc$ = null;
            this.$internal_containmentRefName_yewt20$ = null;
            this.$internal_unsetCmd_ybs3xv$ = null;
            this.$internal_readOnlyElem_kjnzn$ = false;
            this.$internal_recursive_readOnlyElem_4yqmva$ = false;
            this.$internal_inboundReferences_9wwhuj$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_jce2mf$ = false;
            this.$internal_is_deleted_rwoxmo$ = false;
            this.$is_root_rpf5xt$ = false;
            this.$internal_modelElementListeners_3tuwy8$ = null;
            this.$internal_modelTreeListeners_yoyb84$ = null;
            this.$path_cache_dqee6q$ = null;
            this.$key_cache_utnug4$ = null;
            this.$name_2jcrtd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_wxesu$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_x4svag$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$lowerBindings_2eifxl$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperBindings_qtzjre$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$lowerFragments_p02ne0$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperFragments_zkcbr$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$dictionaryType_v1n452$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_p3y5rc$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_p3y5rc$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_yewt20$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_yewt20$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ybs3xv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ybs3xv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_kjnzn$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_kjnzn$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_4yqmva$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_4yqmva$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_9wwhuj$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_9wwhuj$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_jce2mf$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_jce2mf$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_rwoxmo$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_rwoxmo$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_rpf5xt$;
              },
              set: function (tmp$0) {
                this.$is_root_rpf5xt$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_3tuwy8$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_3tuwy8$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_yoyb84$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_yoyb84$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_dqee6q$;
              },
              set: function (tmp$0) {
                this.$path_cache_dqee6q$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_utnug4$;
              },
              set: function (tmp$0) {
                this.$key_cache_utnug4$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_2jcrtd$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_2jcrtd$;
                this.$name_2jcrtd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_wxesu$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_wxesu$;
                this.$version_wxesu$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_x4svag$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_x4svag$;
                this.$abstract_x4svag$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withLowerBindings: function (p) {
              this.lowerBindings = p;
              return this;
            },
            lowerBindings: {
              get: function () {
                return this.$lowerBindings_2eifxl$;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerBindings_2eifxl$;
                this.$lowerBindings_2eifxl$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings, kmf_previousVal, this, oldPath));
                }
              }
            },
            withUpperBindings: function (p) {
              this.upperBindings = p;
              return this;
            },
            upperBindings: {
              get: function () {
                return this.$upperBindings_qtzjre$;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperBindings_qtzjre$;
                this.$upperBindings_qtzjre$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings, kmf_previousVal, this, oldPath));
                }
              }
            },
            withLowerFragments: function (p) {
              this.lowerFragments = p;
              return this;
            },
            lowerFragments: {
              get: function () {
                return this.$lowerFragments_p02ne0$;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerFragments_p02ne0$;
                this.$lowerFragments_p02ne0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments, kmf_previousVal, this, oldPath));
                }
              }
            },
            withUpperFragments: function (p) {
              this.upperFragments = p;
              return this;
            },
            upperFragments: {
              get: function () {
                return this.$upperFragments_zkcbr$;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperFragments_zkcbr$;
                this.$upperFragments_zkcbr$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_v1n452$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_v1n452$, dictionaryTypeP)) {
                if (this.$dictionaryType_v1n452$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_v1n452$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_v1n452$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_v1n452$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_v1n452$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_v1n452$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                  this.internal_lowerBindings(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                  this.internal_upperBindings(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                  this.internal_lowerFragments(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                  this.internal_upperFragments(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }
          }),
          PortTypeMappingImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortTypeMapping, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_hxvi0e$ = null;
            this.$internal_containmentRefName_8oqxdq$ = null;
            this.$internal_unsetCmd_ftwvtv$ = null;
            this.$internal_readOnlyElem_v4nxer$ = false;
            this.$internal_recursive_readOnlyElem_mrxc4w$ = false;
            this.$internal_inboundReferences_atc4a9$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_7wzzjl$ = false;
            this.$internal_is_deleted_f54q52$ = false;
            this.$is_root_jgjmah$ = false;
            this.$internal_modelElementListeners_bmvbyy$ = null;
            this.$internal_modelTreeListeners_6rhzoq$ = null;
            this.$path_cache_5fvza0$ = null;
            this.$key_cache_vnrmsy$ = null;
            this.$beanMethodName_ostbqs$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$serviceMethodName_uert8v$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$paramTypes_6h3gkk$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$generated_KMF_ID_yedsty$ = '' + Math.random() + (new Date()).getTime();
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_hxvi0e$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_hxvi0e$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_8oqxdq$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_8oqxdq$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ftwvtv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ftwvtv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_v4nxer$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_v4nxer$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_mrxc4w$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_mrxc4w$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_atc4a9$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_atc4a9$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_7wzzjl$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_7wzzjl$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_f54q52$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_f54q52$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_jgjmah$;
              },
              set: function (tmp$0) {
                this.$is_root_jgjmah$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_bmvbyy$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_bmvbyy$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_6rhzoq$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_6rhzoq$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_5fvza0$;
              },
              set: function (tmp$0) {
                this.$path_cache_5fvza0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_vnrmsy$;
              },
              set: function (tmp$0) {
                this.$key_cache_vnrmsy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withBeanMethodName: function (p) {
              this.beanMethodName = p;
              return this;
            },
            beanMethodName: {
              get: function () {
                return this.$beanMethodName_ostbqs$;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$beanMethodName_ostbqs$;
                this.$beanMethodName_ostbqs$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName, kmf_previousVal, this, oldPath));
                }
              }
            },
            withServiceMethodName: function (p) {
              this.serviceMethodName = p;
              return this;
            },
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName_uert8v$;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$serviceMethodName_uert8v$;
                this.$serviceMethodName_uert8v$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName, kmf_previousVal, this, oldPath));
                }
              }
            },
            withParamTypes: function (p) {
              this.paramTypes = p;
              return this;
            },
            paramTypes: {
              get: function () {
                return this.$paramTypes_6h3gkk$;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$paramTypes_6h3gkk$;
                this.$paramTypes_6h3gkk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes, kmf_previousVal, this, oldPath));
                }
              }
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_yedsty$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_yedsty$;
                this.$generated_KMF_ID_yedsty$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                  this.internal_beanMethodName(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                  this.internal_serviceMethodName(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                  this.internal_paramTypes(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }
          }),
          GroupTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.GroupType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_abyt0s$ = null;
            this.$internal_containmentRefName_7uf86c$ = null;
            this.$internal_unsetCmd_pvvwdz$ = null;
            this.$internal_readOnlyElem_5sbm5z$ = false;
            this.$internal_recursive_readOnlyElem_ukepe2$ = false;
            this.$internal_inboundReferences_nizx0p$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_be3cej$ = false;
            this.$internal_is_deleted_d4pkw4$ = false;
            this.$is_root_uo75sd$ = false;
            this.$internal_modelElementListeners_98kc98$ = null;
            this.$internal_modelTreeListeners_5x6ahc$ = null;
            this.$path_cache_ep7swe$ = null;
            this.$key_cache_lou2so$ = null;
            this.$name_7marjf$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_21ul1q$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_gzbdck$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_2y33ei$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_abyt0s$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_abyt0s$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_7uf86c$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_7uf86c$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_pvvwdz$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_pvvwdz$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_5sbm5z$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_5sbm5z$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ukepe2$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ukepe2$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_nizx0p$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_nizx0p$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_be3cej$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_be3cej$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_d4pkw4$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_d4pkw4$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_uo75sd$;
              },
              set: function (tmp$0) {
                this.$is_root_uo75sd$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_98kc98$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_98kc98$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_5x6ahc$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_5x6ahc$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ep7swe$;
              },
              set: function (tmp$0) {
                this.$path_cache_ep7swe$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_lou2so$;
              },
              set: function (tmp$0) {
                this.$key_cache_lou2so$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_7marjf$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_7marjf$;
                this.$name_7marjf$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_21ul1q$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_21ul1q$;
                this.$version_21ul1q$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_gzbdck$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_gzbdck$;
                this.$abstract_gzbdck$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_2y33ei$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_2y33ei$, dictionaryTypeP)) {
                if (this.$dictionaryType_2y33ei$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_2y33ei$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_2y33ei$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_2y33ei$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_2y33ei$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_2y33ei$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }
          })
        }),
        util: Kotlin.definePackage(function () {
          this.Constants = Kotlin.createObject(null, function () {
            this.UNKNOWN_MUTATION_TYPE_EXCEPTION = 'Unknown mutation type: ';
            this.READ_ONLY_EXCEPTION = 'This model is ReadOnly. Elements are not modifiable.';
            this.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION = 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.';
            this.ELEMENT_HAS_NO_KEY_IN_COLLECTION = 'Cannot set the collection, because at least one element of it has no key!';
            this.EMPTY_KEY = 'Key empty : please set the attribute key before adding the object.';
            this.KMFQL_CONTAINED = 'contained';
            this.STRING_DEFAULTVAL = '';
            this.INT_DEFAULTVAL = 0;
            this.BOOLEAN_DEFAULTVAL = false;
            this.CHAR_DEFAULTVAL = 'a';
            this.SHORT_DEFAULTVAL = 0;
            this.LONG_DEFAULTVAL = 0.0;
            this.DOUBLE_DEFAULTVAL = 0.0;
            this.FLOAT_DEFAULTVAL = 0;
            this.BYTE_DEFAULTVAL = 0;
            this.Ref_superTypes = 'superTypes';
            this.org_kevoree_Instance = 'org.kevoree.Instance';
            this.Att_defaultValue = 'defaultValue';
            this.Ref_provided = 'provided';
            this.Att_started = 'started';
            this.org_kevoree_TypedElement = 'org.kevoree.TypedElement';
            this.org_kevoree_PortTypeMapping = 'org.kevoree.PortTypeMapping';
            this.Ref_hub = 'hub';
            this.java_lang_Boolean = 'java.lang.Boolean';
            this.Ref_dictionaryType = 'dictionaryType';
            this.Att_upperBindings = 'upperBindings';
            this.Ref_host = 'host';
            this.Ref_returnType = 'returnType';
            this.Ref_port = 'port';
            this.Att_url = 'url';
            this.Ref_portTypeRef = 'portTypeRef';
            this.org_kevoree_NodeType = 'org.kevoree.NodeType';
            this.Ref_values = 'values';
            this.org_kevoree_Package = 'org.kevoree.Package';
            this.org_kevoree_ContainerRoot = 'org.kevoree.ContainerRoot';
            this.Att_fragmentDependant = 'fragmentDependant';
            this.Att_state = 'state';
            this.org_kevoree_ServicePortType = 'org.kevoree.ServicePortType';
            this.Att_interface = 'interface';
            this.org_kevoree_PortType = 'org.kevoree.PortType';
            this.Ref_hosts = 'hosts';
            this.org_kevoree_MBinding = 'org.kevoree.MBinding';
            this.Ref_operations = 'operations';
            this.org_kevoree_Value = 'org.kevoree.Value';
            this.java_lang_Integer = 'java.lang.Integer';
            this.Ref_groups = 'groups';
            this.org_kevoree_Group = 'org.kevoree.Group';
            this.Ref_metaData = 'metaData';
            this.Att_generated_KMF_ID = 'generated_KMF_ID';
            this.org_kevoree_NamedElement = 'org.kevoree.NamedElement';
            this.Ref_dictionary = 'dictionary';
            this.Ref_packages = 'packages';
            this.org_kevoree_ComponentType = 'org.kevoree.ComponentType';
            this.org_kevoree_DeployUnit = 'org.kevoree.DeployUnit';
            this.Ref_mBindings = 'mBindings';
            this.Ref_subNodes = 'subNodes';
            this.Ref_fragmentDictionary = 'fragmentDictionary';
            this.Ref_nodes = 'nodes';
            this.org_kevoree_DataType = 'org.kevoree.DataType';
            this.Ref_hubs = 'hubs';
            this.Ref_mappings = 'mappings';
            this.org_kevoree_ChannelType = 'org.kevoree.ChannelType';
            this.Ref_attributes = 'attributes';
            this.Att_hashcode = 'hashcode';
            this.Att_lowerFragments = 'lowerFragments';
            this.Ref_parameters = 'parameters';
            this.Ref_type = 'type';
            this.Att_datatype = 'datatype';
            this.Ref_networkInformation = 'networkInformation';
            this.Att_value = 'value';
            this.org_kevoree_Port = 'org.kevoree.Port';
            this.Att_abstract = 'abstract';
            this.org_kevoree_ComponentInstance = 'org.kevoree.ComponentInstance';
            this.Att_version = 'version';
            this.org_kevoree_ContainerNode = 'org.kevoree.ContainerNode';
            this.Ref_components = 'components';
            this.org_kevoree_DictionaryAttribute = 'org.kevoree.DictionaryAttribute';
            this.Ref_typeDefinitions = 'typeDefinitions';
            this.Ref_genericTypes = 'genericTypes';
            this.org_kevoree_FragmentDictionary = 'org.kevoree.FragmentDictionary';
            this.Ref_requiredLibs = 'requiredLibs';
            this.Ref_typeDefinition = 'typeDefinition';
            this.org_kevoree_Channel = 'org.kevoree.Channel';
            this.Ref_deployUnits = 'deployUnits';
            this.org_kevoree_Parameter = 'org.kevoree.Parameter';
            this.org_kevoree_Dictionary = 'org.kevoree.Dictionary';
            this.Att_synchrone = 'synchrone';
            this.org_kevoree_Repository = 'org.kevoree.Repository';
            this.Att_serviceMethodName = 'serviceMethodName';
            this.Ref_repositories = 'repositories';
            this.Ref_required = 'required';
            this.Att_name = 'name';
            this.Att_order = 'order';
            this.java_lang_String = 'java.lang.String';
            this.Att_upperFragments = 'upperFragments';
            this.Att_lowerBindings = 'lowerBindings';
            this.org_kevoree_NetworkInfo = 'org.kevoree.NetworkInfo';
            this.org_kevoree_GroupType = 'org.kevoree.GroupType';
            this.org_kevoree_Operation = 'org.kevoree.Operation';
            this.Ref_filters = 'filters';
            this.org_kevoree_PortTypeRef = 'org.kevoree.PortTypeRef';
            this.Att_optional = 'optional';
            this.org_kevoree_DictionaryType = 'org.kevoree.DictionaryType';
            this.Att_beanMethodName = 'beanMethodName';
            this.Ref_ref = 'ref';
            this.Ref_bindings = 'bindings';
            this.org_kevoree_MessagePortType = 'org.kevoree.MessagePortType';
            this.org_kevoree_TypeDefinition = 'org.kevoree.TypeDefinition';
            this.Att_paramTypes = 'paramTypes';
            this.Att_noDependency = 'noDependency';
          });
        }, /** @lends _.org.kevoree.util */ {
        }),
        factory: Kotlin.definePackage(null, /** @lends _.org.kevoree.factory */ {
          DefaultKevoreeFactory: Kotlin.createClass(function () {
            return [_.org.kevoree.factory.KevoreeFactory];
          }, null, /** @lends _.org.kevoree.factory.DefaultKevoreeFactory.prototype */ {
            getVersion: function () {
              return '5.0.1-SNAPSHOT';
            },
            lookup: function (path) {
              return null;
            },
            createComponentInstance: function () {
              var tempElem = new _.org.kevoree.impl.ComponentInstanceImpl();
              return tempElem;
            },
            createInstance: function () {
              var tempElem = new _.org.kevoree.impl.InstanceImpl();
              return tempElem;
            },
            createPort: function () {
              var tempElem = new _.org.kevoree.impl.PortImpl();
              return tempElem;
            },
            createComponentType: function () {
              var tempElem = new _.org.kevoree.impl.ComponentTypeImpl();
              return tempElem;
            },
            createTypeDefinition: function () {
              var tempElem = new _.org.kevoree.impl.TypeDefinitionImpl();
              return tempElem;
            },
            createPortTypeRef: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeRefImpl();
              return tempElem;
            },
            createContainerNode: function () {
              var tempElem = new _.org.kevoree.impl.ContainerNodeImpl();
              return tempElem;
            },
            createGroup: function () {
              var tempElem = new _.org.kevoree.impl.GroupImpl();
              return tempElem;
            },
            createNetworkInfo: function () {
              var tempElem = new _.org.kevoree.impl.NetworkInfoImpl();
              return tempElem;
            },
            createContainerRoot: function () {
              var tempElem = new _.org.kevoree.impl.ContainerRootImpl();
              return tempElem;
            },
            createRepository: function () {
              var tempElem = new _.org.kevoree.impl.RepositoryImpl();
              return tempElem;
            },
            createChannel: function () {
              var tempElem = new _.org.kevoree.impl.ChannelImpl();
              return tempElem;
            },
            createMBinding: function () {
              var tempElem = new _.org.kevoree.impl.MBindingImpl();
              return tempElem;
            },
            createPackage: function () {
              var tempElem = new _.org.kevoree.impl.PackageImpl();
              return tempElem;
            },
            createNamedElement: function () {
              var tempElem = new _.org.kevoree.impl.NamedElementImpl();
              return tempElem;
            },
            createDeployUnit: function () {
              var tempElem = new _.org.kevoree.impl.DeployUnitImpl();
              return tempElem;
            },
            createPortType: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeImpl();
              return tempElem;
            },
            createDictionary: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryImpl();
              return tempElem;
            },
            createValue: function () {
              var tempElem = new _.org.kevoree.impl.ValueImpl();
              return tempElem;
            },
            createFragmentDictionary: function () {
              var tempElem = new _.org.kevoree.impl.FragmentDictionaryImpl();
              return tempElem;
            },
            createDictionaryType: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryTypeImpl();
              return tempElem;
            },
            createDictionaryAttribute: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryAttributeImpl();
              return tempElem;
            },
            createTypedElement: function () {
              var tempElem = new _.org.kevoree.impl.TypedElementImpl();
              return tempElem;
            },
            createPortTypeMapping: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeMappingImpl();
              return tempElem;
            },
            createServicePortType: function () {
              var tempElem = new _.org.kevoree.impl.ServicePortTypeImpl();
              return tempElem;
            },
            createOperation: function () {
              var tempElem = new _.org.kevoree.impl.OperationImpl();
              return tempElem;
            },
            createParameter: function () {
              var tempElem = new _.org.kevoree.impl.ParameterImpl();
              return tempElem;
            },
            createMessagePortType: function () {
              var tempElem = new _.org.kevoree.impl.MessagePortTypeImpl();
              return tempElem;
            },
            createChannelType: function () {
              var tempElem = new _.org.kevoree.impl.ChannelTypeImpl();
              return tempElem;
            },
            createGroupType: function () {
              var tempElem = new _.org.kevoree.impl.GroupTypeImpl();
              return tempElem;
            },
            createNodeType: function () {
              var tempElem = new _.org.kevoree.impl.NodeTypeImpl();
              return tempElem;
            },
            create: function (metaClassName) {
              {
                if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                  return this.createComponentInstance();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                  return this.createInstance();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                  return this.createPort();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                  return this.createComponentType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeDefinition) {
                  return this.createTypeDefinition();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                  return this.createPortTypeRef();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                  return this.createContainerNode();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                  return this.createGroup();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkInfo) {
                  return this.createNetworkInfo();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                  return this.createContainerRoot();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                  return this.createRepository();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                  return this.createChannel();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                  return this.createMBinding();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Package) {
                  return this.createPackage();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NamedElement) {
                  return this.createNamedElement();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                  return this.createDeployUnit();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortType) {
                  return this.createPortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                  return this.createDictionary();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Value) {
                  return this.createValue();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary) {
                  return this.createFragmentDictionary();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                  return this.createDictionaryType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                  return this.createDictionaryAttribute();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                  return this.createTypedElement();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                  return this.createPortTypeMapping();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                  return this.createServicePortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                  return this.createOperation();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                  return this.createParameter();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                  return this.createMessagePortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                  return this.createChannelType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                  return this.createGroupType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                  return this.createNodeType();
                }
                 else {
                  return null;
                }
              }
            },
            select: function (query) {
              return new Kotlin.ArrayList();
            },
            root: function (elem) {
              elem.is_root = true;
              elem.path_cache = '/';
            },
            createJSONSerializer: function () {
              return new _.org.kevoree.modeling.api.json.JSONModelSerializer();
            },
            createJSONLoader: function () {
              return new _.org.kevoree.modeling.api.json.JSONModelLoader(this);
            },
            createXMISerializer: function () {
              return new _.org.kevoree.modeling.api.xmi.XMIModelSerializer();
            },
            createXMILoader: function () {
              return new _.org.kevoree.modeling.api.xmi.XMIModelLoader(this);
            },
            createModelCompare: function () {
              return new _.org.kevoree.modeling.api.compare.ModelCompare(this);
            },
            createModelCloner: function () {
              return new _.org.kevoree.modeling.api.ModelCloner(this);
            },
            createModelPruner: function () {
              return new _.org.kevoree.modeling.api.ModelPruner(this);
            }
          }),
          KevoreeFactory: Kotlin.createTrait(function () {
            return [_.org.kevoree.modeling.api.KMFFactory];
          })
        }),
        modeling: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling */ {
          api: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api */ {
            time: Kotlin.definePackage(function () {
              this.TimeComparator = Kotlin.createObject(null, null, {
                compare: function (a, b) {
                  if (a === b) {
                    return 0;
                  }
                   else {
                    if (a < b) {
                      return -1;
                    }
                     else {
                      return 1;
                    }
                  }
                }
              });
              this.TimeSegmentConst = Kotlin.createObject(null, function () {
                this.GLOBAL_TIMEMETA = '#global';
              });
            }, /** @lends _.org.kevoree.modeling.api.time */ {
              TimeAwareKMFContainer: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.TimedContainer, _.org.kevoree.modeling.api.persistence.KMFContainerProxy];
              }, /** @lends _.org.kevoree.modeling.api.time.TimeAwareKMFContainer.prototype */ {
                meta: {
                  get: function () {
                    return this.$meta_e0ta8m$;
                  },
                  set: function (tmp$0) {
                    this.$meta_e0ta8m$ = tmp$0;
                  }
                },
                getOriginTransaction: function () {
                  var tmp$0;
                  return ((tmp$0 = this.originFactory) != null ? tmp$0 : Kotlin.throwNPE()).originTransaction;
                },
                previous: function () {
                  var previousTime = this.timeTree().previous(this.now);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                next: function () {
                  var previousTime = this.timeTree().next(this.now);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                last: function () {
                  var tmp$0;
                  var previousTime = (tmp$0 = this.timeTree().versionTree.lastWhileNot(this.now, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) != null ? tmp$0.key : null;
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                first: function () {
                  var tmp$0;
                  var previousTime = (tmp$0 = this.timeTree().versionTree.firstWhileNot(this.now, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) != null ? tmp$0.key : null;
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                jump: function (time) {
                  var previousTime = this.timeTree().previous(time);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                timeTree: function () {
                  var tmp$0;
                  return ((tmp$0 = this.originFactory) != null ? tmp$0 : Kotlin.throwNPE()).getTimeTree(this.path());
                }
              }),
              TimeAwareKMFFactory: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.time.TimeView, _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory];
              }, /** @lends _.org.kevoree.modeling.api.time.TimeAwareKMFFactory.prototype */ {
                relativeTime: {
                  get: function () {
                    return this.$relativeTime_53j5cx$;
                  }
                },
                sharedCache: {
                  get: function () {
                    return this.$sharedCache_s3os97$;
                  }
                },
                entitiesCache: {
                  get: function () {
                    return this.$entitiesCache_hk1jbt$;
                  },
                  set: function (tmp$0) {
                    this.$entitiesCache_hk1jbt$ = tmp$0;
                  }
                },
                originTransaction: {
                  get: function () {
                    return this.$originTransaction_8vjs1c$;
                  },
                  set: function (tmp$0) {
                    this.$originTransaction_8vjs1c$ = tmp$0;
                  }
                },
                getEntitiesMeta: function () {
                  if (this.entitiesCache != null) {
                    var tmp$0;
                    return (tmp$0 = this.entitiesCache) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                   else {
                    var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITIES.name(), this.relativeTime.toString());
                    var blob = new _.org.kevoree.modeling.api.time.blob.EntitiesMeta();
                    if (payload != null) {
                      blob.load(payload);
                    }
                    this.entitiesCache = blob;
                    return blob;
                  }
                },
                endCommit: function () {
                  var entitiesMeta = this.getEntitiesMeta();
                  {
                    var tmp$0 = entitiesMeta.list.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var path = tmp$0.next();
                      var timeTree = this.getTimeTree(path);
                      if (timeTree.dirty) {
                        this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), path, timeTree.toString());
                        timeTree.dirty = false;
                      }
                    }
                  }
                  if (entitiesMeta.isDirty) {
                    this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITIES.name(), this.relativeTime.toString(), entitiesMeta.toString());
                    entitiesMeta.isDirty = false;
                  }
                  var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                  if (globalTime.dirty) {
                    this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), _.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA, globalTime.toString());
                    globalTime.dirty = false;
                  }
                  {
                    var tmp$1 = this.elementsToBeRemoved.iterator();
                    while (tmp$1.hasNext()) {
                      var e = tmp$1.next();
                      this.cleanUnusedPaths(e);
                    }
                  }
                  this.elementsToBeRemoved.clear();
                  this.datastore.commit();
                },
                clear: function () {
                  var tmp$0;
                  if (this.entitiesCache != null && ((tmp$0 = this.entitiesCache) != null ? tmp$0 : Kotlin.throwNPE()).isDirty) {
                    Kotlin.println('WARNING :: CLOSED TimeView in dirty mode ! ' + this.relativeTime);
                  }
                  _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory.prototype.clear.call(this);
                  this.entitiesCache = null;
                },
                monitor: function (elem) {
                  if (!this.dirty) {
                    this.dirty = true;
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  elem.addModelElementListener(this);
                },
                commit: function () {
                  var keys = _.kotlin.toList_h3panj$(this.modified_elements.keySet());
                  {
                    var tmp$0 = keys.iterator();
                    while (tmp$0.hasNext()) {
                      var elem = tmp$0.next();
                      var resolved = this.modified_elements.get_za3rmp$(elem);
                      if (resolved != null) {
                        if (Kotlin.equals(resolved.path(), '')) {
                          if (!resolved.isDeleted()) {
                            resolved.delete();
                          }
                           else {
                            this.modified_elements.remove_za3rmp$(elem);
                          }
                        }
                      }
                    }
                  }
                  {
                    var tmp$1 = this.modified_elements.values().iterator();
                    while (tmp$1.hasNext()) {
                      var elem_0 = tmp$1.next();
                      this.persist(elem_0);
                      this.elementsToBeRemoved.remove_za3rmp$(elem_0.path());
                    }
                  }
                },
                persist: function (elem) {
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    return;
                  }
                  var currentPath = elem.path();
                  if (Kotlin.equals(currentPath, '')) {
                    throw new Error('Internal error, empty path found during persist method ' + elem);
                  }
                  if (!currentPath.startsWith('/')) {
                    throw new Error('Cannot persist, because the path of the element do not refer to a root: ' + currentPath + ' -> ' + elem);
                  }
                  var casted = elem;
                  var traces = elem.toTraces(true, true);
                  var traceSeq = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  traceSeq.populate(traces);
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.put_wn2jw4$(currentPath, true);
                  entitiesMeta.isDirty = true;
                  var key = this.relativeTime.toString() + '/' + currentPath;
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key, traceSeq.exportToString());
                  var castedInBounds = elem;
                  var saved = _.org.kevoree.modeling.api.time.blob.MetaHelper.serialize(castedInBounds.internal_inboundReferences);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key + '#', saved);
                  var tmp$0;
                  ((tmp$0 = casted.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted = this.relativeTime;
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), key, Kotlin.toString(casted.meta));
                  var timeTree = this.getTimeTree(currentPath);
                  if (timeTree.versionTree.lookup(this.relativeTime) == null) {
                    timeTree.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                    timeTree.dirty = true;
                  }
                },
                remove: function (elem) {
                  if (elem.isDeleted()) {
                    return;
                  }
                  var path = elem.path();
                  if (Kotlin.equals(path, '')) {
                    this.modified_elements.remove_za3rmp$(elem);
                    Kotlin.println("WARNING :: Can't process dangling element! type:" + elem.metaClassName() + ',id=' + elem.internalGetKey() + ' ignored');
                    return;
                  }
                  this.elem_cache.remove_za3rmp$(path);
                  var currentCachedTimeTree = this.getTimeTree(path);
                  currentCachedTimeTree.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED);
                  currentCachedTimeTree.dirty = true;
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.put_wn2jw4$(path, true);
                  entitiesMeta.isDirty = true;
                  if (!this.dirty) {
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  this.modified_elements.remove_za3rmp$(Kotlin.hashCode(elem).toString());
                },
                cleanUnusedPaths: function (path) {
                  var key = this.relativeTime.toString() + '/' + path;
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), key);
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key);
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key + '#');
                },
                getTimeTree: function (path) {
                  var alreadyCached = this.sharedCache.timeCache.get_za3rmp$(path);
                  if (alreadyCached != null) {
                    return alreadyCached;
                  }
                   else {
                    var timeMetaPayLoad = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), path);
                    var blob = new _.org.kevoree.modeling.api.time.blob.TimeMeta();
                    if (timeMetaPayLoad != null) {
                      blob.load(timeMetaPayLoad);
                    }
                    this.sharedCache.timeCache.put_wn2jw4$(path, blob);
                    return blob;
                  }
                },
                lookup: function (path) {
                  var timeTree = this.getTimeTree(path);
                  var askedTimeResult = timeTree.versionTree.previousOrEqual(this.relativeTime);
                  var askedTime = askedTimeResult != null ? askedTimeResult.key : null;
                  if (askedTime == null || Kotlin.equals((askedTimeResult != null ? askedTimeResult : Kotlin.throwNPE()).value, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) {
                    return null;
                  }
                  var composedKey = Kotlin.toString(askedTime) + '/' + path;
                  if (this.elem_cache.containsKey_za3rmp$(composedKey)) {
                    return this.elem_cache.get_za3rmp$(composedKey);
                  }
                  var metaPayload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), composedKey);
                  if (metaPayload == null) {
                    return null;
                  }
                  var meta = new _.org.kevoree.modeling.api.time.blob.EntityMeta();
                  meta.load(metaPayload);
                  if (meta.metatype != null) {
                    var tmp$0, tmp$1;
                    var elem = (tmp$1 = this.create((tmp$0 = meta.metatype) != null ? tmp$0 : Kotlin.throwNPE())) != null ? tmp$1 : Kotlin.throwNPE();
                    elem.meta = meta;
                    this.elem_cache.put_wn2jw4$(composedKey, elem);
                    elem.isResolved = false;
                    elem.now = askedTime;
                    elem.setOriginPath(path);
                    this.monitor(elem);
                    return elem;
                  }
                   else {
                    throw new Error('Empty Type Name for ' + path);
                  }
                },
                getTraces: function (origin) {
                  var currentPath = origin.path();
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var castedOrigin = origin;
                  var tmp$0, tmp$1;
                  if (((tmp$0 = castedOrigin.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted == null) {
                    return null;
                  }
                  var traces = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), Kotlin.toString(((tmp$1 = castedOrigin.meta) != null ? tmp$1 : Kotlin.throwNPE()).latestPersisted) + '/' + currentPath);
                  if (traces != null) {
                    sequence.populateFromString(traces != null ? traces : Kotlin.throwNPE());
                    return sequence;
                  }
                  return null;
                },
                now: function () {
                  return this.relativeTime;
                },
                modified: function () {
                  return this.getEntitiesMeta().list.keySet();
                },
                loadInbounds: function (elem) {
                  var castedInBounds = elem;
                  var casted2 = elem;
                  var tmp$0;
                  var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), Kotlin.toString(((tmp$0 = casted2.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted) + '/' + elem.path() + '#');
                  if (payload != null) {
                    castedInBounds.internal_inboundReferences = _.org.kevoree.modeling.api.time.blob.MetaHelper.unserialize(payload, this);
                  }
                },
                delete: function () {
                  {
                    var tmp$0 = this.getEntitiesMeta().list.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var path = tmp$0.next();
                      var timeMeta = this.getTimeTree(path);
                      timeMeta.versionTree.delete(this.relativeTime);
                      timeMeta.dirty = true;
                      this.elementsToBeRemoved.add_za3rmp$(path);
                    }
                  }
                  this.getEntitiesMeta().list.clear();
                  this.getEntitiesMeta().isDirty = true;
                  if (!this.dirty) {
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.clear();
                  entitiesMeta.isDirty = true;
                },
                diff: function (other) {
                  var casted = other;
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                  var tmp$0, tmp$1;
                  var resolved1 = (tmp$0 = globalTime.versionTree.previousOrEqual(this.relativeTime)) != null ? tmp$0.key : null;
                  var resolved2 = (tmp$1 = globalTime.versionTree.previousOrEqual(casted.relativeTime)) != null ? tmp$1.key : null;
                  if (resolved1 == null || resolved2 == null) {
                    return sequence;
                  }
                   else {
                    if (_.org.kevoree.modeling.api.time.TimeComparator.compare(resolved1 != null ? resolved1 : Kotlin.throwNPE(), resolved2 != null ? resolved2 : Kotlin.throwNPE()) > 1) {
                      var temp = resolved1;
                      resolved1 = resolved2;
                      resolved2 = temp;
                    }
                  }
                  var currentTP = resolved1 != null ? resolved1 : Kotlin.throwNPE();
                  while (!Kotlin.equals(currentTP, resolved2 != null ? resolved2 : Kotlin.throwNPE())) {
                    var otherEntities = casted.getEntitiesMeta();
                    {
                      var tmp$2 = otherEntities.list.keySet().iterator();
                      while (tmp$2.hasNext()) {
                        var path = tmp$2.next();
                        var key = currentTP.toString() + '/' + path;
                        var raw = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key);
                        if (raw != null) {
                          sequence.populateFromString(raw);
                        }
                      }
                    }
                    var tmp$3, tmp$4;
                    currentTP = (tmp$4 = (tmp$3 = globalTime.versionTree.next(currentTP)) != null ? tmp$3.key : null) != null ? tmp$4 : Kotlin.throwNPE();
                  }
                  return sequence;
                }
              }),
              TimeTree: Kotlin.createTrait(null),
              TimeView: Kotlin.createTrait(null),
              TimeSegment: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.time.TimeSegment */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    RAW: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    ENTITYMETA: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    TIMEMETA: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    ENTITIES: new _.org.kevoree.modeling.api.time.TimeSegment()
                  });
                }
              }),
              TimeWalker: Kotlin.createTrait(null),
              blob: Kotlin.definePackage(function () {
                this.RBCONST = Kotlin.createObject(null, function () {
                  this.BLACK_DELETE = '0';
                  this.BLACK_EXISTS = '1';
                  this.RED_DELETE = '2';
                  this.RED_EXISTS = '3';
                });
                this.MetaHelper = Kotlin.createObject(null, function () {
                  this.sep = '#';
                  this.sep2 = '%';
                }, {
                  serialize: function (p) {
                    var buffer = new Kotlin.StringBuilder();
                    var isFirst = true;
                    {
                      var tmp$0 = p.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var key = tmp$0.next();
                        var tmp$1;
                        var v = (tmp$1 = p.get_za3rmp$(key)) != null ? tmp$1 : Kotlin.throwNPE();
                        if (!isFirst) {
                          buffer.append(this.sep);
                        }
                        buffer.append(key.path());
                        if (v.size() !== 0) {
                          {
                            var tmp$2 = v.iterator();
                            while (tmp$2.hasNext()) {
                              var v2 = tmp$2.next();
                              buffer.append(this.sep2);
                              buffer.append(v2);
                            }
                          }
                        }
                        isFirst = false;
                      }
                    }
                    return buffer.toString();
                  },
                  unserialize: function (p, factory) {
                    var result = new Kotlin.ComplexHashMap();
                    var lines = Kotlin.splitString(p, this.sep);
                    var tmp$0, tmp$1, tmp$2;
                    {
                      tmp$0 = lines, tmp$1 = tmp$0.length;
                      for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
                        var l = tmp$0[tmp$2];
                        var elems = Kotlin.splitString(l, this.sep2);
                        if (elems.length > 1) {
                          var payload = new Kotlin.PrimitiveHashSet();
                          var tmp$3, tmp$4;
                          {
                            tmp$3 = elems.length - 1 + 1;
                            for (var i = 1; i !== tmp$3; i++) {
                              payload.add_za3rmp$(elems[i]);
                            }
                          }
                          result.put_wn2jw4$((tmp$4 = factory.lookup(elems[0])) != null ? tmp$4 : Kotlin.throwNPE(), payload);
                        }
                      }
                    }
                    return result;
                  }
                });
              }, /** @lends _.org.kevoree.modeling.api.time.blob */ {
                TimeMeta: Kotlin.createClass(function () {
                  return [_.org.kevoree.modeling.api.time.TimeTree];
                }, function () {
                  this.dirty = true;
                  this.versionTree = new _.org.kevoree.modeling.api.time.blob.RBTree();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.TimeMeta.prototype */ {
                  first: function () {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.first()) != null ? tmp$0.key : null;
                  },
                  last: function () {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.last()) != null ? tmp$0.key : null;
                  },
                  next: function (from) {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.next(from)) != null ? tmp$0.key : null;
                  },
                  previous: function (from) {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.previous(from)) != null ? tmp$0.key : null;
                  },
                  walk: function (walker) {
                    return this.walkAsc(walker);
                  },
                  toString: function () {
                    return this.versionTree.serialize();
                  },
                  load: function (payload) {
                    this.versionTree.unserialize(payload);
                    this.dirty = false;
                  },
                  walkAsc: function (walker) {
                    var elem = this.versionTree.first();
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).next();
                    }
                  },
                  walkDesc: function (walker) {
                    var elem = this.versionTree.last();
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).previous();
                    }
                  },
                  walkRangeAsc: function (walker, from, to) {
                    var from2 = from;
                    var to2 = to;
                    if (from > to) {
                      from2 = to;
                      to2 = from;
                    }
                    var elem;
                    elem = this.versionTree.previousOrEqual(from2);
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).next();
                      if (elem != null) {
                        if ((elem != null ? elem : Kotlin.throwNPE()).key >= to2) {
                          return;
                        }
                      }
                    }
                  },
                  walkRangeDesc: function (walker, from, to) {
                    var from2 = from;
                    var to2 = to;
                    if (from > to) {
                      from2 = to;
                      to2 = from;
                    }
                    var elem;
                    elem = this.versionTree.previousOrEqual(to2);
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).previous();
                      if (elem != null) {
                        if ((elem != null ? elem : Kotlin.throwNPE()).key <= from2) {
                          walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                          return;
                        }
                      }
                    }
                  }
                }, /** @lends _.org.kevoree.modeling.api.time.blob.TimeMeta */ {
                  object_initializer$: function () {
                    return Kotlin.createObject(null, function () {
                      this.GO_DOWN_LEFT = 0;
                      this.GO_DOWN_RIGHT = 1;
                      this.PROCESS_PREFIX = 2;
                      this.PROCESS_INFIX = 3;
                      this.PROCESS_POSTFIX = 4;
                    });
                  }
                }),
                Color: Kotlin.createClass(function () {
                  return [Kotlin.Enum];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, null, /** @lends _.org.kevoree.modeling.api.time.blob.Color */ {
                  object_initializer$: function () {
                    return Kotlin.createEnumEntries({
                      RED: new _.org.kevoree.modeling.api.time.blob.Color(),
                      BLACK: new _.org.kevoree.modeling.api.time.blob.Color()
                    });
                  }
                }),
                STATE: Kotlin.createClass(function () {
                  return [Kotlin.Enum];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, null, /** @lends _.org.kevoree.modeling.api.time.blob.STATE */ {
                  object_initializer$: function () {
                    return Kotlin.createEnumEntries({
                      EXISTS: new _.org.kevoree.modeling.api.time.blob.STATE(),
                      DELETED: new _.org.kevoree.modeling.api.time.blob.STATE()
                    });
                  }
                }),
                Node: Kotlin.createClass(null, function (key, value, color, left, right) {
                  this.key = key;
                  this.value = value;
                  this.color = color;
                  this.left = left;
                  this.right = right;
                  this.parent = null;
                  if (this.left != null) {
                    var tmp$0;
                    ((tmp$0 = this.left) != null ? tmp$0 : Kotlin.throwNPE()).parent = this;
                  }
                  if (this.right != null) {
                    var tmp$1;
                    ((tmp$1 = this.right) != null ? tmp$1 : Kotlin.throwNPE()).parent = this;
                  }
                  this.parent = null;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.Node.prototype */ {
                  grandparent: function () {
                    var tmp$0;
                    return (tmp$0 = this.parent) != null ? tmp$0.parent : null;
                  },
                  sibling: function () {
                    var tmp$0;
                    if (Kotlin.equals(this, (tmp$0 = this.parent) != null ? tmp$0.left : null)) {
                      var tmp$1;
                      return (tmp$1 = this.parent) != null ? tmp$1.right : null;
                    }
                     else {
                      var tmp$2;
                      return (tmp$2 = this.parent) != null ? tmp$2.left : null;
                    }
                  },
                  uncle: function () {
                    var tmp$0;
                    return (tmp$0 = this.parent) != null ? tmp$0.sibling() : null;
                  },
                  serialize: function (builder) {
                    builder.append('|');
                    if (Kotlin.equals(this.value, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) {
                      if (Kotlin.equals(this.color, _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_DELETE);
                      }
                       else {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.RED_DELETE);
                      }
                    }
                     else {
                      if (Kotlin.equals(this.color, _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_EXISTS);
                      }
                       else {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.RED_EXISTS);
                      }
                    }
                    builder.append(this.key);
                    if (this.left == null && this.right == null) {
                      builder.append('%');
                    }
                     else {
                      if (this.left != null) {
                        var tmp$0;
                        (tmp$0 = this.left) != null ? tmp$0.serialize(builder) : null;
                      }
                       else {
                        builder.append('#');
                      }
                      if (this.right != null) {
                        var tmp$1;
                        (tmp$1 = this.right) != null ? tmp$1.serialize(builder) : null;
                      }
                       else {
                        builder.append('#');
                      }
                    }
                  },
                  next: function () {
                    var p = this;
                    if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                      var tmp$0;
                      p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$0 : Kotlin.throwNPE();
                      while ((p != null ? p : Kotlin.throwNPE()).left != null) {
                        var tmp$1;
                        p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$1 : Kotlin.throwNPE();
                      }
                      return p;
                    }
                     else {
                      if ((p != null ? p : Kotlin.throwNPE()).parent != null) {
                        var tmp$2;
                        if (Kotlin.equals(p, ((tmp$2 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                          var tmp$3;
                          return (tmp$3 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$3 : Kotlin.throwNPE();
                        }
                         else {
                          var tmp$4;
                          while ((p != null ? p : Kotlin.throwNPE()).parent != null && Kotlin.equals(p, ((tmp$4 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$4 : Kotlin.throwNPE()).right)) {
                            var tmp$5;
                            p = (tmp$5 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                          return (p != null ? p : Kotlin.throwNPE()).parent;
                        }
                      }
                       else {
                        return null;
                      }
                    }
                  },
                  previous: function () {
                    var p = this;
                    if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                      var tmp$0;
                      p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                      while ((p != null ? p : Kotlin.throwNPE()).right != null) {
                        var tmp$1;
                        p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                      }
                      return p;
                    }
                     else {
                      if ((p != null ? p : Kotlin.throwNPE()).parent != null) {
                        var tmp$2;
                        if (Kotlin.equals(p, ((tmp$2 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$2 : Kotlin.throwNPE()).right)) {
                          var tmp$3;
                          return (tmp$3 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$3 : Kotlin.throwNPE();
                        }
                         else {
                          var tmp$4;
                          while ((p != null ? p : Kotlin.throwNPE()).parent != null && Kotlin.equals(p, ((tmp$4 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$4 : Kotlin.throwNPE()).left)) {
                            var tmp$5;
                            p = (tmp$5 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                          return (p != null ? p : Kotlin.throwNPE()).parent;
                        }
                      }
                       else {
                        return null;
                      }
                    }
                  }
                }),
                ReaderContext: Kotlin.createClass(null, function (payload, offset) {
                  this.payload = payload;
                  this.offset = offset;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.ReaderContext.prototype */ {
                  unserialize: function (rightBranch) {
                    if (this.offset >= this.payload.length) {
                      return null;
                    }
                    var tokenBuild = new Kotlin.StringBuilder();
                    var ch = this.payload.charAt(this.offset);
                    if (ch === '%') {
                      if (rightBranch) {
                        this.offset = this.offset + 1;
                      }
                      return null;
                    }
                    if (ch === '#') {
                      this.offset = this.offset + 1;
                      return null;
                    }
                    if (ch !== '|') {
                      throw new Error('Error while loading BTree');
                    }
                    this.offset = this.offset + 1;
                    ch = this.payload.charAt(this.offset);
                    var color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    var state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                    {
                      if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_DELETE) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_EXISTS) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.RED_DELETE) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.RED_EXISTS) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                      }
                    }
                    this.offset = this.offset + 1;
                    ch = this.payload.charAt(this.offset);
                    while (this.offset + 1 < this.payload.length && ch !== '|' && ch !== '#' && ch !== '%') {
                      tokenBuild.append(ch);
                      this.offset = this.offset + 1;
                      ch = this.payload.charAt(this.offset);
                    }
                    if (ch !== '|' && ch !== '#' && ch !== '%') {
                      tokenBuild.append(ch);
                    }
                    var p = new _.org.kevoree.modeling.api.time.blob.Node(_.java.lang.Long.parseLong(tokenBuild.toString()), state, color, null, null);
                    var left = this.unserialize(false);
                    if (left != null) {
                      left.parent = p;
                    }
                    var right = this.unserialize(true);
                    if (right != null) {
                      right.parent = p;
                    }
                    p.left = left;
                    p.right = right;
                    return p;
                  }
                }),
                RBTree: Kotlin.createClass(null, function () {
                  this.root = null;
                  this.size_pjslhb$ = 0;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.RBTree.prototype */ {
                  size: function () {
                    return this.size_pjslhb$;
                  },
                  serialize: function () {
                    var builder = new Kotlin.StringBuilder();
                    builder.append(this.size_pjslhb$);
                    var tmp$0;
                    (tmp$0 = this.root) != null ? tmp$0.serialize(builder) : null;
                    return builder.toString();
                  },
                  unserialize: function (payload) {
                    if (_.kotlin.get_size_0(payload) === 0) {
                      return;
                    }
                    var i = 0;
                    var buffer = new Kotlin.StringBuilder();
                    var ch = payload.charAt(i);
                    while (i < payload.length && ch !== '|') {
                      buffer.append(ch);
                      i = i + 1;
                      ch = payload.charAt(i);
                    }
                    this.size_pjslhb$ = _.java.lang.Integer.parseInt(buffer.toString());
                    this.root = (new _.org.kevoree.modeling.api.time.blob.ReaderContext(payload, i)).unserialize(true);
                  },
                  previousOrEqual: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key === (p != null ? p : Kotlin.throwNPE()).key) {
                        return p;
                      }
                      if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).right;
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).left;
                        }
                         else {
                          var parent = (p != null ? p : Kotlin.throwNPE()).parent;
                          var ch = p;
                          while (parent != null && Kotlin.equals(ch, (parent != null ? parent : Kotlin.throwNPE()).left)) {
                            ch = parent;
                            parent = (parent != null ? parent : Kotlin.throwNPE()).parent;
                          }
                          return parent;
                        }
                      }
                    }
                    return null;
                  },
                  nextOrEqual: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key === (p != null ? p : Kotlin.throwNPE()).key) {
                        return p;
                      }
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).left;
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).right;
                        }
                         else {
                          var parent = (p != null ? p : Kotlin.throwNPE()).parent;
                          var ch = p;
                          while (parent != null && Kotlin.equals(ch, (parent != null ? parent : Kotlin.throwNPE()).right)) {
                            ch = parent;
                            parent = (parent != null ? parent : Kotlin.throwNPE()).parent;
                          }
                          return parent;
                        }
                      }
                    }
                    return null;
                  },
                  previous: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          var tmp$0;
                          p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        }
                         else {
                          return (p != null ? p : Kotlin.throwNPE()).previous();
                        }
                      }
                       else if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          var tmp$1;
                          p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        return (p != null ? p : Kotlin.throwNPE()).previous();
                      }
                    }
                    return null;
                  },
                  previousWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      if ((elm != null ? elm : Kotlin.throwNPE()).key === key) {
                        elm = (elm != null ? elm : Kotlin.throwNPE()).previous();
                      }
                    }
                    if (elm == null || Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      return elm;
                    }
                  },
                  next: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          var tmp$0;
                          p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        }
                         else {
                          return p;
                        }
                      }
                       else if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          var tmp$1;
                          p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                         else {
                          return (p != null ? p : Kotlin.throwNPE()).next();
                        }
                      }
                       else {
                        return (p != null ? p : Kotlin.throwNPE()).next();
                      }
                    }
                    return null;
                  },
                  nextWhileNot: function (key, until) {
                    var elm = this.nextOrEqual(key);
                    if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      if ((elm != null ? elm : Kotlin.throwNPE()).key === key) {
                        elm = (elm != null ? elm : Kotlin.throwNPE()).next();
                      }
                    }
                    if (elm == null || Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      return elm;
                    }
                  },
                  first: function () {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                        var tmp$0;
                        p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                      }
                       else {
                        return p;
                      }
                    }
                    return null;
                  },
                  last: function () {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                        var tmp$0;
                        p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$0 : Kotlin.throwNPE();
                      }
                       else {
                        return p;
                      }
                    }
                    return null;
                  },
                  firstWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (elm == null) {
                      return null;
                    }
                     else if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                    var prev;
                    do {
                      prev = (elm != null ? elm : Kotlin.throwNPE()).previous();
                      if (prev == null || Kotlin.equals((prev != null ? prev : Kotlin.throwNPE()).value, until)) {
                        return elm;
                      }
                       else {
                        elm = prev;
                      }
                    }
                     while (elm != null);
                    return prev;
                  },
                  lastWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (elm == null) {
                      return null;
                    }
                     else if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                    var next;
                    do {
                      next = (elm != null ? elm : Kotlin.throwNPE()).next();
                      if (next == null || Kotlin.equals((next != null ? next : Kotlin.throwNPE()).value, until)) {
                        return elm;
                      }
                       else {
                        elm = next;
                      }
                    }
                     while (elm != null);
                    return next;
                  },
                  lookupNode: function (key) {
                    var n = this.root;
                    if (n == null) {
                      return null;
                    }
                    while (n != null) {
                      if (key === (n != null ? n : Kotlin.throwNPE()).key) {
                        return n;
                      }
                       else {
                        if (key < (n != null ? n : Kotlin.throwNPE()).key) {
                          n = (n != null ? n : Kotlin.throwNPE()).left;
                        }
                         else {
                          n = (n != null ? n : Kotlin.throwNPE()).right;
                        }
                      }
                    }
                    return n;
                  },
                  lookup: function (key) {
                    var n = this.lookupNode(key);
                    if (n == null) {
                      return null;
                    }
                     else {
                      return n.value;
                    }
                  },
                  rotateLeft: function (n) {
                    var r = n.right;
                    this.replaceNode(n, r != null ? r : Kotlin.throwNPE());
                    n.right = r.left;
                    if (r.left != null) {
                      var tmp$0;
                      ((tmp$0 = r.left) != null ? tmp$0 : Kotlin.throwNPE()).parent = n;
                    }
                    r.left = n;
                    n.parent = r;
                  },
                  rotateRight: function (n) {
                    var l = n.left;
                    this.replaceNode(n, l != null ? l : Kotlin.throwNPE());
                    n.left = l.right;
                    if (l.right != null) {
                      var tmp$0;
                      ((tmp$0 = l.right) != null ? tmp$0 : Kotlin.throwNPE()).parent = n;
                    }
                    l.right = n;
                    n.parent = l;
                  },
                  replaceNode: function (oldn, newn) {
                    if (oldn.parent == null) {
                      this.root = newn;
                    }
                     else {
                      var tmp$0;
                      if (Kotlin.equals(oldn, ((tmp$0 = oldn.parent) != null ? tmp$0 : Kotlin.throwNPE()).left)) {
                        var tmp$1;
                        ((tmp$1 = oldn.parent) != null ? tmp$1 : Kotlin.throwNPE()).left = newn;
                      }
                       else {
                        var tmp$2;
                        ((tmp$2 = oldn.parent) != null ? tmp$2 : Kotlin.throwNPE()).right = newn;
                      }
                    }
                    if (newn != null) {
                      newn.parent = oldn.parent;
                    }
                  },
                  insert: function (key, value) {
                    var insertedNode = new _.org.kevoree.modeling.api.time.blob.Node(key, value, _.org.kevoree.modeling.api.time.blob.Color.object.RED, null, null);
                    if (this.root == null) {
                      this.size_pjslhb$++;
                      this.root = insertedNode;
                    }
                     else {
                      var n = this.root;
                      while (true) {
                        if (key === (n != null ? n : Kotlin.throwNPE()).key) {
                          (n != null ? n : Kotlin.throwNPE()).value = value;
                          return;
                        }
                         else if (key < (n != null ? n : Kotlin.throwNPE()).key) {
                          if ((n != null ? n : Kotlin.throwNPE()).left == null) {
                            (n != null ? n : Kotlin.throwNPE()).left = insertedNode;
                            this.size_pjslhb$++;
                            break;
                          }
                           else {
                            var tmp$0;
                            n = (tmp$0 = (n != null ? n : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                          }
                        }
                         else {
                          if ((n != null ? n : Kotlin.throwNPE()).right == null) {
                            (n != null ? n : Kotlin.throwNPE()).right = insertedNode;
                            this.size_pjslhb$++;
                            break;
                          }
                           else {
                            n = (n != null ? n : Kotlin.throwNPE()).right;
                          }
                        }
                      }
                      insertedNode.parent = n;
                    }
                    this.insertCase1(insertedNode);
                  },
                  insertCase1: function (n) {
                    if (n.parent == null) {
                      n.color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      this.insertCase2(n);
                    }
                  },
                  insertCase2: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      return;
                    }
                     else {
                      this.insertCase3(n);
                    }
                  },
                  insertCase3: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.uncle()), _.org.kevoree.modeling.api.time.blob.Color.object.RED)) {
                      var tmp$0, tmp$1, tmp$2, tmp$3;
                      ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      ((tmp$1 = n.uncle()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      ((tmp$2 = n.grandparent()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      this.insertCase1((tmp$3 = n.grandparent()) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                     else {
                      this.insertCase4(n);
                    }
                  },
                  insertCase4: function (n_n) {
                    var n = n_n;
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(n, ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).right) && Kotlin.equals(n.parent, ((tmp$1 = n.grandparent()) != null ? tmp$1 : Kotlin.throwNPE()).left)) {
                      var tmp$2, tmp$3;
                      this.rotateLeft((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE());
                      n = (tmp$3 = n.left) != null ? tmp$3 : Kotlin.throwNPE();
                    }
                     else {
                      var tmp$4, tmp$5;
                      if (Kotlin.equals(n, ((tmp$4 = n.parent) != null ? tmp$4 : Kotlin.throwNPE()).left) && Kotlin.equals(n.parent, ((tmp$5 = n.grandparent()) != null ? tmp$5 : Kotlin.throwNPE()).right)) {
                        var tmp$6, tmp$7;
                        this.rotateRight((tmp$6 = n.parent) != null ? tmp$6 : Kotlin.throwNPE());
                        n = (tmp$7 = n.right) != null ? tmp$7 : Kotlin.throwNPE();
                      }
                    }
                    this.insertCase5(n);
                  },
                  insertCase5: function (n) {
                    var tmp$0, tmp$1, tmp$2, tmp$3;
                    ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    ((tmp$1 = n.grandparent()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                    if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left) && Kotlin.equals(n.parent, ((tmp$3 = n.grandparent()) != null ? tmp$3 : Kotlin.throwNPE()).left)) {
                      var tmp$4;
                      this.rotateRight((tmp$4 = n.grandparent()) != null ? tmp$4 : Kotlin.throwNPE());
                    }
                     else {
                      var tmp$5;
                      this.rotateLeft((tmp$5 = n.grandparent()) != null ? tmp$5 : Kotlin.throwNPE());
                    }
                  },
                  delete: function (key) {
                    var n = this.lookupNode(key);
                    if (n == null) {
                      return;
                    }
                     else {
                      this.size_pjslhb$--;
                      if ((n != null ? n : Kotlin.throwNPE()).left != null && (n != null ? n : Kotlin.throwNPE()).right != null) {
                        var tmp$0;
                        var pred = (tmp$0 = (n != null ? n : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        while (pred.right != null) {
                          var tmp$1;
                          pred = (tmp$1 = pred.right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        (n != null ? n : Kotlin.throwNPE()).key = pred.key;
                        (n != null ? n : Kotlin.throwNPE()).value = pred.value;
                        n = pred;
                      }
                      var tmp$2;
                      if ((n != null ? n : Kotlin.throwNPE()).right == null) {
                        tmp$2 = (n != null ? n : Kotlin.throwNPE()).left;
                      }
                       else {
                        tmp$2 = (n != null ? n : Kotlin.throwNPE()).right;
                      }
                      var child = tmp$2;
                      if (Kotlin.equals(this.nodeColor(n), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        (n != null ? n : Kotlin.throwNPE()).color = this.nodeColor(child);
                        this.deleteCase1(n != null ? n : Kotlin.throwNPE());
                      }
                      this.replaceNode(n != null ? n : Kotlin.throwNPE(), child);
                    }
                  },
                  deleteCase1: function (n) {
                    if (n.parent == null) {
                      return;
                    }
                     else {
                      this.deleteCase2(n);
                    }
                  },
                  deleteCase2: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.RED)) {
                      var tmp$0, tmp$1, tmp$2;
                      ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                        var tmp$3;
                        this.rotateLeft((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE());
                      }
                       else {
                        var tmp$4;
                        this.rotateRight((tmp$4 = n.parent) != null ? tmp$4 : Kotlin.throwNPE());
                      }
                    }
                    this.deleteCase3(n);
                  },
                  deleteCase3: function (n) {
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$2, tmp$3;
                      ((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      this.deleteCase1((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                     else {
                      this.deleteCase4(n);
                    }
                  },
                  deleteCase4: function (n) {
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$2, tmp$3;
                      ((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      this.deleteCase5(n);
                    }
                  },
                  deleteCase5: function (n) {
                    var tmp$0, tmp$1, tmp$2, tmp$7, tmp$8, tmp$9;
                    if (Kotlin.equals(n, ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).left) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$3, tmp$4, tmp$5, tmp$6;
                      ((tmp$3 = n.sibling()) != null ? tmp$3 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$5 = ((tmp$4 = n.sibling()) != null ? tmp$4 : Kotlin.throwNPE()).left) != null ? tmp$5 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateRight((tmp$6 = n.sibling()) != null ? tmp$6 : Kotlin.throwNPE());
                    }
                     else if (Kotlin.equals(n, ((tmp$7 = n.parent) != null ? tmp$7 : Kotlin.throwNPE()).right) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$8 = n.sibling()) != null ? tmp$8 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(((tmp$9 = n.sibling()) != null ? tmp$9 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$10, tmp$11, tmp$12, tmp$13;
                      ((tmp$10 = n.sibling()) != null ? tmp$10 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$12 = ((tmp$11 = n.sibling()) != null ? tmp$11 : Kotlin.throwNPE()).right) != null ? tmp$12 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateLeft((tmp$13 = n.sibling()) != null ? tmp$13 : Kotlin.throwNPE());
                    }
                    this.deleteCase6(n);
                  },
                  deleteCase6: function (n) {
                    var tmp$0, tmp$1, tmp$2;
                    ((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).color = this.nodeColor(n.parent);
                    ((tmp$1 = n.parent) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                      var tmp$3, tmp$4, tmp$5;
                      ((tmp$4 = ((tmp$3 = n.sibling()) != null ? tmp$3 : Kotlin.throwNPE()).right) != null ? tmp$4 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateLeft((tmp$5 = n.parent) != null ? tmp$5 : Kotlin.throwNPE());
                    }
                     else {
                      var tmp$6, tmp$7, tmp$8;
                      ((tmp$7 = ((tmp$6 = n.sibling()) != null ? tmp$6 : Kotlin.throwNPE()).left) != null ? tmp$7 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateRight((tmp$8 = n.parent) != null ? tmp$8 : Kotlin.throwNPE());
                    }
                  },
                  nodeColor: function (n) {
                    if (n == null) {
                      return _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      return n.color;
                    }
                  }
                }),
                SharedCache: Kotlin.createClass(null, function () {
                  this.times_ynpjdh$ = new Kotlin.PrimitiveHashMap();
                  this.timeCache = new _.java.util.concurrent.ConcurrentHashMap();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.SharedCache.prototype */ {
                  add: function (tp, tv) {
                    this.times_ynpjdh$.put_wn2jw4$(tp, tv);
                  },
                  get: function (tp) {
                    return this.times_ynpjdh$.get_za3rmp$(tp);
                  },
                  drop: function (tp) {
                    this.times_ynpjdh$.remove_za3rmp$(tp);
                  },
                  keys: function () {
                    return this.times_ynpjdh$.keySet();
                  },
                  flush: function () {
                    this.times_ynpjdh$.clear();
                    this.timeCache.clear();
                  }
                }),
                EntitiesMeta: Kotlin.createClass(null, function () {
                  this.isDirty = false;
                  this.sep = '#';
                  this.list = new Kotlin.PrimitiveHashMap();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.EntitiesMeta.prototype */ {
                  toString: function () {
                    var stringBuilder = new Kotlin.StringBuilder();
                    var isFirst = true;
                    {
                      var tmp$0 = this.list.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var p = tmp$0.next();
                        if (!isFirst) {
                          stringBuilder.append(this.sep);
                        }
                        stringBuilder.append(p);
                        isFirst = false;
                      }
                    }
                    return stringBuilder.toString();
                  },
                  load: function (payload) {
                    if (Kotlin.equals(payload, '')) {
                      return;
                    }
                    var elements = Kotlin.splitString(payload, this.sep);
                    var tmp$0, tmp$1, tmp$2;
                    {
                      tmp$0 = elements, tmp$1 = tmp$0.length;
                      for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
                        var elem = tmp$0[tmp$2];
                        this.list.put_wn2jw4$(elem, true);
                      }
                    }
                    this.isDirty = false;
                  }
                }),
                EntityMeta: Kotlin.createClass(null, function () {
                  this.latestPersisted = null;
                  this.metatype = null;
                  this.sep = '/';
                }, /** @lends _.org.kevoree.modeling.api.time.blob.EntityMeta.prototype */ {
                  toString: function () {
                    var buidler = new Kotlin.StringBuilder();
                    buidler.append(this.latestPersisted);
                    buidler.append(this.sep);
                    buidler.append(this.metatype);
                    return buidler.toString();
                  },
                  load: function (payload) {
                    var elem = Kotlin.splitString(payload, this.sep);
                    if (elem.length === 2) {
                      var originPayload = elem[0];
                      if (!Kotlin.equals(originPayload, '')) {
                        this.latestPersisted = _.java.lang.Long.parseLong(originPayload);
                      }
                      this.metatype = elem[1];
                    }
                     else {
                      throw new Error('Bad EntityTimeMeta format');
                    }
                  }
                })
              })
            }),
            trace: Kotlin.definePackage(function () {
              this.ModelTraceConstants = Kotlin.createObject(null, function () {
                this.traceType = 't';
                this.src = 's';
                this.refname = 'r';
                this.previouspath = 'p';
                this.typename = 'n';
                this.objpath = 'o';
                this.content = 'c';
                this.openJSON = '{';
                this.closeJSON = '}';
                this.bb = '"';
                this.coma = ',';
                this.dp = ':';
              });
            }, /** @lends _.org.kevoree.modeling.api.trace */ {
              Event2Trace: Kotlin.createClass(null, function (compare) {
                this.compare = compare;
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: function (event) {
                  var result = new Kotlin.ArrayList();
                  {
                    var tmp$0 = event.etype;
                    if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      var tmp$1;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.previousPath) != null ? tmp$1 : Kotlin.throwNPE(), event.elementAttributeName, Kotlin.toString(event.previous_value)));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      var tmp$2;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$2 = event.previousPath) != null ? tmp$2 : Kotlin.throwNPE(), event.elementAttributeName));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      var tmp$3, tmp$4;
                      var casted = (tmp$3 = event.value) != null ? tmp$3 : Kotlin.throwNPE();
                      var traces = this.compare.inter(casted, casted);
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = event.previousPath) != null ? tmp$4 : Kotlin.throwNPE(), event.elementAttributeName, casted.path(), casted.metaClassName()));
                      result.addAll_xeylzf$(traces.traces);
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      var tmp$5;
                      var casted_0 = (tmp$5 = event.value) != null ? tmp$5 : Kotlin.throwNPE();
                      {
                        var tmp$6 = casted_0.iterator();
                        while (tmp$6.hasNext()) {
                          var elem = tmp$6.next();
                          var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                          var traces_0 = this.compare.inter(elemCasted, elemCasted);
                          var tmp$7;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$7 = event.previousPath) != null ? tmp$7 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted.path(), elemCasted.metaClassName()));
                          result.addAll_xeylzf$(traces_0.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      if (Kotlin.equals(event.elementAttributeType, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                        var tmp$8;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$8 = event.previousPath) != null ? tmp$8 : Kotlin.throwNPE(), event.elementAttributeName, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.value), null));
                      }
                       else {
                        var tmp$9, tmp$10;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$9 = event.previousPath) != null ? tmp$9 : Kotlin.throwNPE(), event.elementAttributeName, (tmp$10 = event.value) != null ? tmp$10.path() : null, null, null));
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error("Can't convert event : " + event);
                    }
                  }
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory)).populate(result);
                },
                inverse: function (event) {
                  var result = new Kotlin.ArrayList();
                  {
                    var tmp$0 = event.etype;
                    if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      var tmp$1, tmp$2, tmp$3;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$1 = event.previousPath) != null ? tmp$1 : Kotlin.throwNPE(), event.elementAttributeName, ((tmp$2 = event.value) != null ? tmp$2 : Kotlin.throwNPE()).path(), ((tmp$3 = event.value) != null ? tmp$3 : Kotlin.throwNPE()).metaClassName()));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      var tmp$4;
                      var casted = (tmp$4 = event.value) != null ? tmp$4 : Kotlin.throwNPE();
                      {
                        var tmp$5 = casted.iterator();
                        while (tmp$5.hasNext()) {
                          var elem = tmp$5.next();
                          var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                          var traces = this.compare.inter(elemCasted, elemCasted);
                          var tmp$6;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$6 = event.previousPath) != null ? tmp$6 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted.path(), elemCasted.metaClassName()));
                          result.addAll_xeylzf$(traces.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      var tmp$7, tmp$8;
                      var casted_0 = (tmp$7 = event.value) != null ? tmp$7 : Kotlin.throwNPE();
                      var traces_0 = this.compare.inter(casted_0, casted_0);
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$8 = event.previousPath) != null ? tmp$8 : Kotlin.throwNPE(), event.elementAttributeName, casted_0.path()));
                      result.addAll_xeylzf$(traces_0.traces);
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      var tmp$9;
                      var casted_1 = (tmp$9 = event.value) != null ? tmp$9 : Kotlin.throwNPE();
                      {
                        var tmp$10 = casted_1.iterator();
                        while (tmp$10.hasNext()) {
                          var elem_0 = tmp$10.next();
                          var elemCasted_0 = elem_0 != null ? elem_0 : Kotlin.throwNPE();
                          var traces_1 = this.compare.inter(elemCasted_0, elemCasted_0);
                          var tmp$11;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$11 = event.previousPath) != null ? tmp$11 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted_0.path()));
                          result.addAll_xeylzf$(traces_1.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      if (Kotlin.equals(event.elementAttributeType, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                        var tmp$12;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$12 = event.previousPath) != null ? tmp$12 : Kotlin.throwNPE(), event.elementAttributeName, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.previous_value), null));
                      }
                       else {
                        var tmp$13, tmp$14;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$13 = event.previousPath) != null ? tmp$13 : Kotlin.throwNPE(), event.elementAttributeName, (tmp$14 = event.previous_value) != null ? tmp$14.path() : null, null, null));
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error("Can't convert event : " + event);
                    }
                  }
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory)).populate(result);
                }
              }),
              DefaultTraceConverter: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.TraceConverter];
              }, function () {
                this.metaClassNameEquivalence_1_rqkn57$ = new Kotlin.PrimitiveHashMap();
                this.metaClassNameEquivalence_2_rqkn58$ = new Kotlin.PrimitiveHashMap();
                this.attNameEquivalence_1_vwmrr1$ = new Kotlin.PrimitiveHashMap();
                this.attNameEquivalence_2_vwmrr2$ = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: function (name1, name2) {
                  this.metaClassNameEquivalence_1_rqkn57$.put_wn2jw4$(name1, name2);
                  this.metaClassNameEquivalence_2_rqkn58$.put_wn2jw4$(name2, name2);
                },
                addAttEquivalence: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1_vwmrr1$.put_wn2jw4$(name1, name2);
                  this.attNameEquivalence_2_vwmrr2$.put_wn2jw4$(name2, name2);
                },
                convert: function (trace) {
                  {
                    if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                      var addTrace = trace;
                      var newTrace = new _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                      return newTrace;
                    }
                     else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                      var setTrace = trace;
                      var newTrace_0 = new _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                      return newTrace_0;
                    }
                     else {
                      return trace;
                    }
                  }
                },
                tryConvertPath: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                },
                tryConvertClassName: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1_rqkn57$.containsKey_za3rmp$(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1_rqkn57$.get_za3rmp$(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2_rqkn58$.containsKey_za3rmp$(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2_rqkn58$.get_za3rmp$(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                },
                tryConvertAttName: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1_vwmrr1$.containsKey_za3rmp$(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1_vwmrr1$.get_za3rmp$(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2_vwmrr2$.containsKey_za3rmp$(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2_vwmrr2$.get_za3rmp$(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }
              }),
              TraceSequence: Kotlin.createClass(null, function (factory) {
                this.factory = factory;
                this.traces = new Kotlin.ArrayList();
              }, /** @lends _.org.kevoree.modeling.api.trace.TraceSequence.prototype */ {
                populate: function (addtraces) {
                  this.traces.addAll_xeylzf$(addtraces);
                  return this;
                },
                append: function (seq) {
                  this.traces.addAll_xeylzf$(seq.traces);
                },
                populateFromString: function (addtracesTxt) {
                  return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
                },
                populateFromStream: function (inputStream) {
                  var previousControlSrc = null;
                  var previousControlTypeName = null;
                  var lexer = new _.org.kevoree.modeling.api.json.Lexer(inputStream);
                  var currentToken = lexer.nextToken();
                  if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                    throw new Error('Bad Format : expect [');
                  }
                  currentToken = lexer.nextToken();
                  var keys = new Kotlin.PrimitiveHashMap();
                  var previousName = null;
                  while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                      keys.clear();
                    }
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                      if (previousName != null) {
                        keys.put_wn2jw4$(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
                        previousName = null;
                      }
                       else {
                        previousName = Kotlin.toString(currentToken.value);
                      }
                    }
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                      var traceTypeRead = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                      if (traceTypeRead == null) {
                        traceTypeRead = previousControlTypeName;
                      }
                      {
                        if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.CONTROL.code) {
                          var src = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (src != null) {
                            var tmp$0;
                            previousControlSrc = (tmp$0 = _.org.kevoree.modeling.api.json.JSONString.unescape(src)) != null ? tmp$0 : Kotlin.throwNPE();
                          }
                          var globalTypeName = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                          if (globalTypeName != null) {
                            previousControlTypeName = globalTypeName;
                          }
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.SET.code) {
                          var srcFound = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound == null) {
                            srcFound = previousControlSrc;
                          }
                           else {
                            srcFound = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound);
                          }
                          var tmp$1;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(srcFound != null ? srcFound : Kotlin.throwNPE(), (tmp$1 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$1 : Kotlin.throwNPE(), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath)), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content)), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename))));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.ADD.code) {
                          var srcFound_0 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_0 == null) {
                            srcFound_0 = previousControlSrc;
                          }
                           else {
                            srcFound_0 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_0);
                          }
                          var tmp$2, tmp$3;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(srcFound_0 != null ? srcFound_0 : Kotlin.throwNPE(), (tmp$2 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$2 : Kotlin.throwNPE(), _.org.kevoree.modeling.api.json.JSONString.unescape((tmp$3 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath)) != null ? tmp$3 : Kotlin.throwNPE()), keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename)));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL.code) {
                          var srcFound_1 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_1 == null) {
                            srcFound_1 = previousControlSrc;
                          }
                           else {
                            srcFound_1 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_1);
                          }
                          var tmp$4, tmp$5, tmp$6, tmp$7, tmp$8;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddAllTrace(srcFound_1 != null ? srcFound_1 : Kotlin.throwNPE(), (tmp$4 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$6 = (tmp$5 = _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content))) != null ? Kotlin.splitString(tmp$5, ';') : null) != null ? _.kotlin.toList_2hx8bi$(tmp$6) : null, (tmp$8 = (tmp$7 = _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename))) != null ? Kotlin.splitString(tmp$7, ';') : null) != null ? _.kotlin.toList_2hx8bi$(tmp$8) : null));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE.code) {
                          var srcFound_2 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_2 == null) {
                            srcFound_2 = previousControlSrc;
                          }
                           else {
                            srcFound_2 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_2);
                          }
                          var tmp$9, tmp$10, tmp$11;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(srcFound_2 != null ? srcFound_2 : Kotlin.throwNPE(), (tmp$9 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$9 : Kotlin.throwNPE(), (tmp$11 = _.org.kevoree.modeling.api.json.JSONString.unescape((tmp$10 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath)) != null ? tmp$10 : Kotlin.throwNPE())) != null ? tmp$11 : Kotlin.throwNPE()));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL.code) {
                          var srcFound_3 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_3 == null) {
                            srcFound_3 = previousControlSrc;
                          }
                           else {
                            srcFound_3 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_3);
                          }
                          var tmp$12;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace(srcFound_3 != null ? srcFound_3 : Kotlin.throwNPE(), (tmp$12 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$12 : Kotlin.throwNPE()));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX.code) {
                        }
                         else {
                          Kotlin.println('Trace lost !!!');
                        }
                      }
                    }
                    currentToken = lexer.nextToken();
                  }
                  return this;
                },
                exportToString: function () {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append('[');
                  var isFirst = true;
                  var previousSrc = null;
                  var previousType = null;
                  {
                    var tmp$0 = this.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',\n');
                      }
                      if (previousSrc == null || !Kotlin.equals(previousSrc, trace.srcPath)) {
                        buffer.append((new _.org.kevoree.modeling.api.trace.ModelControlTrace(trace.srcPath, null)).toString());
                        buffer.append(',\n');
                        previousSrc = trace.srcPath;
                      }
                      if (previousType == null || !Kotlin.equals(previousType, trace.traceType.code)) {
                        buffer.append((new _.org.kevoree.modeling.api.trace.ModelControlTrace('', trace.traceType.code)).toString());
                        buffer.append(',\n');
                        previousType = trace.traceType.code;
                      }
                      buffer.append(trace.toCString(false, false));
                      isFirst = false;
                    }
                  }
                  buffer.append(']');
                  return buffer.toString();
                },
                toString: function () {
                  return this.exportToString();
                },
                applyOn: function (target) {
                  var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, this.factory);
                  traceApplicator.applyTraceOnModel(this);
                  return true;
                },
                silentlyApplyOn: function (target) {
                  var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, this.factory);
                  traceApplicator.fireEvents = false;
                  traceApplicator.applyTraceOnModel(this);
                  return true;
                },
                reverse: function () {
                  var reversed = new Kotlin.ArrayList();
                  var i = _.kotlin.get_size_1(this.traces);
                  while (i > 0) {
                    i = i - 1;
                    reversed.add_za3rmp$(this.traces.get_za3lpa$(i));
                  }
                  this.traces = reversed;
                }
              }),
              ModelTrace: Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.trace.ModelTrace.prototype */ {
                refName: {
                  get: function () {
                    return this.$refName_eb8jwl$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_cer0bq$;
                  }
                },
                srcPath: {
                  get: function () {
                    return this.$srcPath_z3ltm8$;
                  }
                },
                toString: function () {
                  return this.toCString(true, true);
                }
              }),
              ModelControlTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, traceTypeGlobal) {
                this.$srcPath_5kjq8d$ = srcPath;
                this.traceTypeGlobal = traceTypeGlobal;
                this.$refName_qcwzy0$ = '';
                this.$traceType_5dhonr$ = _.org.kevoree.modeling.api.util.ActionType.object.CONTROL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelControlTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_5kjq8d$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_qcwzy0$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_5dhonr$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.CONTROL.code);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  if (this.traceTypeGlobal == null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                   else {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(this.traceTypeGlobal);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelAddTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, previousPath, typeName) {
                this.$srcPath_uvkbsf$ = srcPath;
                this.$refName_a3722s$ = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
                this.$traceType_2i989x$ = _.org.kevoree.modeling.api.util.ActionType.object.ADD;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_uvkbsf$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_a3722s$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_2i989x$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.ADD.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.previousPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.previousPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.typeName);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelAddAllTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, previousPath, typeName) {
                this.$srcPath_1h16pc$ = srcPath;
                this.$refName_m9egez$ = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
                this.$traceType_pralmu$ = _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_1h16pc$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_m9egez$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_pralmu$;
                  }
                },
                mkString: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = new Kotlin.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.previousPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.mkString(this.previousPath));
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.mkString(this.typeName));
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelRemoveTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, objPath) {
                this.$srcPath_7kbv2k$ = srcPath;
                this.$refName_d81en3$ = refName;
                this.objPath = objPath;
                this.$traceType_po7rum$ = _.org.kevoree.modeling.api.util.ActionType.object.REMOVE;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_7kbv2k$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_d81en3$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_po7rum$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.objPath);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelRemoveAllTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName) {
                this.$srcPath_mobmwd$ = srcPath;
                this.$refName_rkf5d4$ = refName;
                this.$traceType_z0g113$ = _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_mobmwd$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_rkf5d4$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_z0g113$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelSetTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, objPath, content, typeName) {
                this.$srcPath_guqstu$ = srcPath;
                this.$refName_xdzzfn$ = refName;
                this.objPath = objPath;
                this.content = content;
                this.typeName = typeName;
                this.$traceType_j5yedg$ = _.org.kevoree.modeling.api.util.ActionType.object.SET;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_guqstu$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_xdzzfn$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_j5yedg$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.SET.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.objPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.objPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.content != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.content);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.typeName);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              TraceConverter: Kotlin.createTrait(null),
              ModelTraceApplicator: Kotlin.createClass(null, function (targetModel, factory) {
                this.targetModel = targetModel;
                this.factory = factory;
                this.pendingObj = null;
                this.pendingParent = null;
                this.pendingParentRefName = null;
                this.pendingObjPath = null;
                this.fireEvents = true;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, this.fireEvents);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                },
                createOrAdd: function (previousPath, target, refName, potentialTypeName) {
                  var targetElem = null;
                  if (previousPath != null) {
                    targetElem = this.targetModel.findByPath(previousPath);
                  }
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refName, targetElem, true, this.fireEvents);
                  }
                   else {
                    if (potentialTypeName == null) {
                      throw new Error('Unknow typeName for potential path ' + Kotlin.toString(previousPath) + ', to store in ' + refName + ', unconsistency error');
                    }
                    this.pendingObj = this.factory.create(potentialTypeName);
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                },
                applyTraceOnModel: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var resolvedTarget = this.targetModel.findByPath(trace.srcPath);
                          if (resolvedTarget == null) {
                            throw new Error('Add Trace source not found for path : ' + trace.srcPath + ' pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = resolvedTarget != null ? resolvedTarget : Kotlin.throwNPE();
                        }
                        this.createOrAdd(trace.previousPath, target, trace.refName, trace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$1;
                        {
                          var tmp$2 = ((tmp$1 = trace.previousPath) != null ? tmp$1 : Kotlin.throwNPE()).iterator();
                          while (tmp$2.hasNext()) {
                            var path = tmp$2.next();
                            var tmp$3;
                            this.createOrAdd(path, target, trace.refName, ((tmp$3 = trace.typeName) != null ? tmp$3 : Kotlin.throwNPE()).get_za3lpa$(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, trace.refName, this.targetModel.findByPath(trace.objPath), true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, trace.refName, null, true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(trace.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(trace.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + trace.srcPath + ' pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(trace.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$4;
                            target = (tmp$4 = this.pendingObj) != null ? tmp$4 : Kotlin.throwNPE();
                          }
                        }
                        if (trace.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, trace.content, true, this.fireEvents);
                        }
                         else {
                          var tmp$5;
                          if (trace.objPath != null) {
                            tmp$5 = this.targetModel.findByPath(trace.objPath);
                          }
                           else {
                            tmp$5 = null;
                          }
                          var targetContentPath = tmp$5;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                          }
                           else {
                            if (trace.typeName != null && !Kotlin.equals(trace.typeName, '')) {
                              this.createOrAdd(trace.objPath, target, trace.refName, trace.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }
              })
            }),
            compare: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.compare */ {
              ModelCompare: Kotlin.createClass(null, function (factory) {
                this.factory = factory;
              }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare.prototype */ {
                diff: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, false, false));
                },
                merge: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, false, true));
                },
                inter: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, true, false));
                },
                internal_diff: function (origin, target, inter, merge) {
                  var traces = new Kotlin.ArrayList();
                  var tracesRef = new Kotlin.ArrayList();
                  var objectsMap = new Kotlin.PrimitiveHashMap();
                  traces.addAll_xeylzf$(origin.createTraces(target, inter, merge, false, true));
                  tracesRef.addAll_xeylzf$(origin.createTraces(target, inter, merge, true, false));
                  var visitor = _.org.kevoree.modeling.api.compare.ModelCompare.internal_diff$f(objectsMap);
                  origin.visit(visitor, true, true, false);
                  var visitor2 = _.org.kevoree.modeling.api.compare.ModelCompare.internal_diff$f_0(objectsMap, inter, traces, merge, tracesRef);
                  target.visit(visitor2, true, true, false);
                  traces.addAll_xeylzf$(tracesRef);
                  if (!inter) {
                    if (!merge) {
                      {
                        var tmp$0 = objectsMap.keySet().iterator();
                        while (tmp$0.hasNext()) {
                          var diffChildKey = tmp$0.next();
                          var tmp$1, tmp$3, tmp$5;
                          var diffChild = (tmp$1 = objectsMap.get_za3rmp$(diffChildKey)) != null ? tmp$1 : Kotlin.throwNPE();
                          if (diffChild.eContainer() != null) {
                            var tmp$2;
                            tmp$3 = ((tmp$2 = diffChild.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).path();
                          }
                           else {
                            tmp$3 = 'null';
                          }
                          var src = tmp$3;
                          if (diffChild.getRefInParent() != null) {
                            var tmp$4;
                            tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                          }
                           else {
                            tmp$5 = 'null';
                          }
                          var refNameInParent = tmp$5;
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, diffChild.path()));
                        }
                      }
                    }
                  }
                  return traces;
                }
              }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare */ {
                internal_diff$f: function (objectsMap) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                  }, {
                    visit: function (elem, refNameInParent, parent) {
                      var childPath = elem.path();
                      if (childPath != null) {
                        objectsMap.put_wn2jw4$(childPath, elem);
                      }
                       else {
                        throw new Error('Null child path ' + elem);
                      }
                    }
                  });
                },
                internal_diff$f_0: function (objectsMap, inter, traces, merge, tracesRef) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                  }, {
                    visit: function (elem, refNameInParent, parent) {
                      var childPath = elem.path();
                      if (objectsMap.containsKey_za3rmp$(childPath)) {
                        if (inter) {
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(parent.path(), refNameInParent, elem.path(), elem.metaClassName()));
                        }
                        var tmp$0, tmp$1;
                        traces.addAll_xeylzf$(((tmp$0 = objectsMap.get_za3rmp$(childPath)) != null ? tmp$0 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                        tracesRef.addAll_xeylzf$(((tmp$1 = objectsMap.get_za3rmp$(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                        objectsMap.remove_za3rmp$(childPath);
                      }
                       else {
                        if (!inter) {
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(parent.path(), refNameInParent, elem.path(), elem.metaClassName()));
                          traces.addAll_xeylzf$(elem.createTraces(elem, true, merge, false, true));
                          tracesRef.addAll_xeylzf$(elem.createTraces(elem, true, merge, true, false));
                        }
                      }
                    }
                  });
                }
              })
            }),
            events: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.events */ {
              ModelEvent: Kotlin.createClass(null, function (etype, elementAttributeType, elementAttributeName, value, previous_value, source, previousPath) {
                this.etype = etype;
                this.elementAttributeType = elementAttributeType;
                this.elementAttributeName = elementAttributeName;
                this.value = value;
                this.previous_value = previous_value;
                this.source = source;
                this.previousPath = previousPath;
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                toString: function () {
                  if (Kotlin.isType(this.source, _.org.kevoree.modeling.api.time.TimeAwareKMFContainer)) {
                    return 'ModelEvent[src:[' + this.source.now + ']' + this.source.path() + ', type:' + this.etype + ', elementAttributeType:' + this.elementAttributeType + ', elementAttributeName:' + this.elementAttributeName + ', value:' + Kotlin.toString(this.value) + ', previousValue:' + Kotlin.toString(this.previous_value) + ']';
                  }
                   else {
                    var tmp$0;
                    return 'ModelEvent[src:' + Kotlin.toString((tmp$0 = this.source) != null ? tmp$0.path() : null) + ', type:' + this.etype + ', elementAttributeType:' + this.elementAttributeType + ', elementAttributeName:' + this.elementAttributeName + ', value:' + Kotlin.toString(this.value) + ', previousValue:' + Kotlin.toString(this.previous_value) + ']';
                  }
                }
              }),
              ModelElementListener: Kotlin.createTrait(null)
            }),
            ModelPruner: Kotlin.createClass(null, function (factory) {
              this.factory = factory;
            }, /** @lends _.org.kevoree.modeling.api.ModelPruner.prototype */ {
              prune: function (elems) {
                var traces = new Kotlin.ArrayList();
                var tempMap = new Kotlin.PrimitiveHashMap();
                var parentMap = new Kotlin.PrimitiveHashMap();
                {
                  var tmp$0 = elems.iterator();
                  while (tmp$0.hasNext()) {
                    var elem = tmp$0.next();
                    this.internal_prune(elem, traces, tempMap, parentMap);
                  }
                }
                {
                  var tmp$1 = tempMap.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var toLinkKey = tmp$1.next();
                    var tmp$2;
                    var toLink = (tmp$2 = tempMap.get_za3rmp$(toLinkKey)) != null ? tmp$2 : Kotlin.throwNPE();
                    traces.addAll_xeylzf$(toLink.toTraces(false, true));
                  }
                }
                return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(traces);
              },
              internal_prune: function (elem, traces, cache, parentMap) {
                var parents = new Kotlin.ArrayList();
                var currentParent = elem.eContainer();
                while (currentParent != null && parentMap.get_za3rmp$((currentParent != null ? currentParent : Kotlin.throwNPE()).path()) == null && cache.get_za3rmp$((currentParent != null ? currentParent : Kotlin.throwNPE()).path()) == null) {
                  parents.add_za3rmp$(currentParent != null ? currentParent : Kotlin.throwNPE());
                  currentParent = (currentParent != null ? currentParent : Kotlin.throwNPE()).eContainer();
                }
                {
                  var tmp$0 = _.kotlin.reverse_h3panj$(parents).iterator();
                  while (tmp$0.hasNext()) {
                    var parent = tmp$0.next();
                    if (parent.eContainer() != null) {
                      var tmp$1, tmp$2;
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(((tmp$1 = parent.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path(), (tmp$2 = parent.getRefInParent()) != null ? tmp$2 : Kotlin.throwNPE(), parent.path(), parent.metaClassName()));
                    }
                    traces.addAll_xeylzf$(parent.toTraces(true, false));
                    parentMap.put_wn2jw4$(parent.path(), parent);
                  }
                }
                if (cache.get_za3rmp$(elem.path()) == null && parentMap.get_za3rmp$(elem.path()) == null) {
                  if (elem.eContainer() != null) {
                    var tmp$3, tmp$4;
                    traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(((tmp$3 = elem.eContainer()) != null ? tmp$3 : Kotlin.throwNPE()).path(), (tmp$4 = elem.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE(), elem.path(), elem.metaClassName()));
                  }
                  traces.addAll_xeylzf$(elem.toTraces(true, false));
                }
                cache.put_wn2jw4$(elem.path(), elem);
                elem.visitReferences(_.org.kevoree.modeling.api.ModelPruner.internal_prune$f(cache, this, traces, parentMap));
              }
            }, /** @lends _.org.kevoree.modeling.api.ModelPruner */ {
              internal_prune$f: function (cache, this$ModelPruner, traces, parentMap) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (cache.get_za3rmp$(elem.path()) == null) {
                      this$ModelPruner.internal_prune(elem, traces, cache, parentMap);
                    }
                  }
                });
              }
            }),
            ModelLoader: Kotlin.createTrait(null),
            TimedContainer: Kotlin.createTrait(function () {
              return [_.org.kevoree.modeling.api.KMFContainer];
            }, /** @lends _.org.kevoree.modeling.api.TimedContainer.prototype */ {
              now: {
                get: function () {
                  return this.$now_2vpa82$;
                },
                set: function (tmp$0) {
                  this.$now_2vpa82$ = tmp$0;
                }
              }
            }),
            ModelCloner: Kotlin.createClass(null, function (factory) {
              this.factory = factory;
            }, /** @lends _.org.kevoree.modeling.api.ModelCloner.prototype */ {
              createContext: function () {
                return new _.java.util.IdentityHashMap();
              },
              clone: function (o) {
                return this.clone_1(o, false);
              },
              clone_1: function (o, readOnly) {
                return this.clone_2(o, readOnly, false);
              },
              cloneMutableOnly: function (o, readOnly) {
                return this.clone_2(o, readOnly, true);
              },
              cloneModelElem: function (src) {
                var tmp$0;
                var clonedSrc = (tmp$0 = this.factory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
                var attributesCloner = _.org.kevoree.modeling.api.ModelCloner.cloneModelElem$f(clonedSrc);
                src.visitAttributes(attributesCloner);
                return clonedSrc;
              },
              resolveModelElem: function (src, target, context, mutableOnly) {
                var refResolver = _.org.kevoree.modeling.api.ModelCloner.resolveModelElem$f(mutableOnly, target, context);
                src.visit(refResolver, false, true, true);
              },
              clone_2: function (o, readOnly, mutableOnly) {
                var context = this.createContext();
                var clonedObject = this.cloneModelElem(o);
                context.put_wn2jw4$(o, clonedObject);
                var cloneGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.clone_2$f(mutableOnly, context, this);
                o.visit(cloneGraphVisitor, true, true, false);
                var resolveGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.clone_2$f_0(mutableOnly, context, this, readOnly);
                this.resolveModelElem(o, clonedObject, context, mutableOnly);
                o.visit(resolveGraphVisitor, true, true, false);
                if (readOnly) {
                  clonedObject.setInternalReadOnly();
                }
                if (o.isRoot()) {
                  this.factory.root(clonedObject);
                }
                return clonedObject;
              }
            }, /** @lends _.org.kevoree.modeling.api.ModelCloner */ {
              cloneModelElem$f: function (clonedSrc) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                }, null, {
                  visit: function (value, name, parent) {
                    if (value != null) {
                      if (Kotlin.isType(value, Kotlin.ArrayList)) {
                        var clonedList = new Kotlin.ArrayList();
                        clonedList.addAll_xeylzf$(value != null ? value : Kotlin.throwNPE());
                        clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, clonedList, false, false);
                      }
                       else {
                        clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, value, false, false);
                      }
                    }
                  }
                });
              },
              resolveModelElem$f: function (mutableOnly, target, context) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                      target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, elem, false, false);
                    }
                     else {
                      var elemResolved = context.get_za3rmp$(elem);
                      if (elemResolved == null) {
                        throw new Error('Cloner error, not self-contain model, the element ' + elem.path() + ' is contained in the root element');
                      }
                      target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, elemResolved, false, false);
                    }
                  }
                });
              },
              clone_2$f: function (mutableOnly, context, this$ModelCloner) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                      this.noChildrenVisit();
                    }
                     else {
                      context.put_wn2jw4$(elem, this$ModelCloner.cloneModelElem(elem));
                    }
                  }
                });
              },
              clone_2$f_0: function (mutableOnly, context, this$ModelCloner, readOnly) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                    }
                     else {
                      var tmp$0;
                      var clonedObj = (tmp$0 = context.get_za3rmp$(elem)) != null ? tmp$0 : Kotlin.throwNPE();
                      this$ModelCloner.resolveModelElem(elem, clonedObj, context, mutableOnly);
                      if (readOnly) {
                        clonedObj.setInternalReadOnly();
                      }
                    }
                  }
                });
              }
            }),
            TransactionManager: Kotlin.createTrait(null),
            Transaction: Kotlin.createTrait(null),
            TimeTransaction: Kotlin.createTrait(function () {
              return [_.org.kevoree.modeling.api.Transaction];
            }),
            KMFFactory: Kotlin.createTrait(null),
            KMFContainer: Kotlin.createTrait(null),
            ModelSerializer: Kotlin.createTrait(null),
            util: Kotlin.definePackage(function () {
              this.KevURLEncoder = Kotlin.createObject(null, function () {
                this.nonEscaped_rysd1l$ = new Kotlin.PrimitiveHashMap();
                this.escaped_qojrqa$ = new Kotlin.PrimitiveHashMap();
                this.rescaped_9ikhle$ = new Kotlin.PrimitiveHashMap();
                var i = 'a';
                while (i < 'z') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                i = 'A';
                while (i < 'Z') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                i = '0';
                while (i < '9') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                this.escaped_qojrqa$.put_wn2jw4$('!', '%21');
                this.escaped_qojrqa$.put_wn2jw4$('"', '%22');
                this.escaped_qojrqa$.put_wn2jw4$('#', '%23');
                this.escaped_qojrqa$.put_wn2jw4$('$', '%24');
                this.escaped_qojrqa$.put_wn2jw4$('%', '%25');
                this.escaped_qojrqa$.put_wn2jw4$('&', '%26');
                this.escaped_qojrqa$.put_wn2jw4$('*', '%2A');
                this.escaped_qojrqa$.put_wn2jw4$(',', '%2C');
                this.escaped_qojrqa$.put_wn2jw4$('/', '%2F');
                this.escaped_qojrqa$.put_wn2jw4$(']', '%5B');
                this.escaped_qojrqa$.put_wn2jw4$('\\', '%5c');
                this.escaped_qojrqa$.put_wn2jw4$('[', '%5D');
                {
                  var tmp$0 = this.escaped_qojrqa$.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var c = tmp$0.next();
                    var tmp$1;
                    this.rescaped_9ikhle$.put_wn2jw4$((tmp$1 = this.escaped_qojrqa$.get_za3rmp$(c)) != null ? tmp$1 : Kotlin.throwNPE(), c);
                  }
                }
              }, {
                encode: function (chain) {
                  if (chain == null) {
                    return null;
                  }
                  var buffer = null;
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (_.kotlin.contains_6halgi$(this.nonEscaped_rysd1l$, ch)) {
                      if (buffer != null) {
                        (buffer != null ? buffer : Kotlin.throwNPE()).append(ch);
                      }
                    }
                     else {
                      var resolved = this.escaped_qojrqa$.get_za3rmp$(ch);
                      if (resolved != null) {
                        if (buffer == null) {
                          buffer = new Kotlin.StringBuilder();
                          (buffer != null ? buffer : Kotlin.throwNPE()).append(chain.substring(0, i));
                        }
                        (buffer != null ? buffer : Kotlin.throwNPE()).append(resolved);
                      }
                    }
                    i = i + 1;
                  }
                  if (buffer != null) {
                    return Kotlin.toString(buffer);
                  }
                   else {
                    return chain;
                  }
                },
                decode: function (src) {
                  if (src == null) {
                    return null;
                  }
                  if (src.length === 0) {
                    return src;
                  }
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var current = src.charAt(i);
                    if (current === '%') {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        builder != null ? builder.append(src.substring(0, i)) : null;
                      }
                      var key = current.toString() + src.charAt(i + 1) + src.charAt(i + 2);
                      var resolved = this.rescaped_9ikhle$.get_za3rmp$(key);
                      if (resolved == null) {
                        builder = builder != null ? builder.append(key) : null;
                      }
                       else {
                        builder = builder != null ? builder.append(resolved) : null;
                      }
                      i = i + 2;
                    }
                     else {
                      if (builder != null) {
                        builder = builder != null ? builder.append(current) : null;
                      }
                    }
                    i++;
                  }
                  if (builder != null) {
                    return (builder != null ? builder : Kotlin.throwNPE()).toString();
                  }
                   else {
                    return src;
                  }
                }
              });
              this.AttConverter = Kotlin.createObject(null, null, {
                convFlatAtt: function (value) {
                  if (value == null) {
                    return null;
                  }
                  if (Kotlin.isType(value, Kotlin.ArrayList)) {
                    var isF = true;
                    var buffer = new Kotlin.StringBuilder();
                    {
                      var tmp$0 = value.iterator();
                      while (tmp$0.hasNext()) {
                        var v = tmp$0.next();
                        if (!isF) {
                          buffer.append('$');
                        }
                        buffer.append(Kotlin.toString(v));
                        isF = false;
                      }
                    }
                    return buffer.toString();
                  }
                   else {
                    return value.toString();
                  }
                },
                convAttFlat: function (value) {
                  return Kotlin.splitString(value.toString(), '$');
                }
              });
              this.ByteConverter = Kotlin.createObject(null, null, {
                toChar: function (b) {
                  return b;
                },
                fromChar: function (b) {
                  return b;
                },
                byteArrayInputStreamFromString: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    bytes[i] = str.charAt(i);
                    i = i + 1;
                  }
                  return new _.java.io.ByteArrayInputStream(bytes);
                }
              });
              this.Selector = Kotlin.createObject(null, null, {
                select: function (root, query) {
                  var extractedQuery = this.extractFirstQuery(query);
                  var result = new Kotlin.ArrayList();
                  var tempResult = {v: new Kotlin.PrimitiveHashMap()};
                  tempResult.v.put_wn2jw4$(root.path(), root);
                  while (extractedQuery != null) {
                    var staticExtractedQuery = extractedQuery != null ? extractedQuery : Kotlin.throwNPE();
                    var clonedRound = tempResult.v;
                    tempResult.v = new Kotlin.PrimitiveHashMap();
                    {
                      var tmp$0 = clonedRound.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var currentRootKey = tmp$0.next();
                        var tmp$1;
                        var currentRoot = (tmp$1 = clonedRound.get_za3rmp$(currentRootKey)) != null ? tmp$1 : Kotlin.throwNPE();
                        var resolved = null;
                        if (!staticExtractedQuery.oldString.contains('*')) {
                          resolved = currentRoot.findByPath(staticExtractedQuery.oldString);
                        }
                        if (resolved != null) {
                          tempResult.v.put_wn2jw4$((resolved != null ? resolved : Kotlin.throwNPE()).path(), resolved != null ? resolved : Kotlin.throwNPE());
                        }
                         else {
                          var alreadyVisited = {v: new Kotlin.PrimitiveHashMap()};
                          var visitor = _.org.kevoree.modeling.api.util.select$f(staticExtractedQuery, alreadyVisited, tempResult);
                          if (staticExtractedQuery.previousIsDeep) {
                            currentRoot.visit(visitor, false, true, staticExtractedQuery.previousIsRefDeep);
                          }
                           else {
                            currentRoot.visit(visitor, false, true, true);
                          }
                        }
                      }
                    }
                    if (staticExtractedQuery.subQuery == null) {
                      extractedQuery = null;
                    }
                     else {
                      extractedQuery = this.extractFirstQuery(staticExtractedQuery.subQuery);
                    }
                  }
                  {
                    var tmp$2 = tempResult.v.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var v = tmp$2.next();
                      var tmp$3;
                      result.add_za3rmp$((tmp$3 = tempResult.v.get_za3rmp$(v)) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                  }
                  return result;
                },
                extractFirstQuery: function (query) {
                  if (query.charAt(0) === '/') {
                    var subQuery = null;
                    if (query.length > 1) {
                      subQuery = query.substring(1);
                    }
                    var params = new Kotlin.PrimitiveHashMap();
                    return new _.org.kevoree.modeling.api.util.KmfQuery('', params, subQuery, '/', false, false);
                  }
                  if (query.startsWith('**/')) {
                    if (query.length > 3) {
                      var next = this.extractFirstQuery(query.substring(3));
                      if (next != null) {
                        next.previousIsDeep = true;
                        next.previousIsRefDeep = false;
                      }
                      return next;
                    }
                     else {
                      return null;
                    }
                  }
                  if (query.startsWith('***/')) {
                    if (query.length > 4) {
                      var next_0 = this.extractFirstQuery(query.substring(4));
                      if (next_0 != null) {
                        next_0.previousIsDeep = true;
                        next_0.previousIsRefDeep = true;
                      }
                      return next_0;
                    }
                     else {
                      return null;
                    }
                  }
                  var i = 0;
                  var relationNameEnd = 0;
                  var attsEnd = 0;
                  var escaped = false;
                  while (i < query.length && (query.charAt(i) !== '/' || escaped)) {
                    if (escaped) {
                      escaped = false;
                    }
                    if (query.charAt(i) === '[') {
                      relationNameEnd = i;
                    }
                     else {
                      if (query.charAt(i) === ']') {
                        attsEnd = i;
                      }
                       else {
                        if (query.charAt(i) === '\\') {
                          escaped = true;
                        }
                      }
                    }
                    i = i + 1;
                  }
                  if (i > 0 && relationNameEnd > 0) {
                    var oldString = query.substring(0, i);
                    var subQuery_0 = null;
                    if (i + 1 < query.length) {
                      subQuery_0 = query.substring(i + 1);
                    }
                    var relName = query.substring(0, relationNameEnd);
                    var params_0 = new Kotlin.PrimitiveHashMap();
                    relName = relName.replace('\\', '');
                    if (attsEnd !== 0) {
                      var paramString = query.substring(relationNameEnd + 1, attsEnd);
                      var iParam = 0;
                      var lastStart = iParam;
                      escaped = false;
                      while (iParam < paramString.length) {
                        if (paramString.charAt(iParam) === ',' && !escaped) {
                          var p = paramString.substring(lastStart, iParam).trim();
                          if (!Kotlin.equals(p, '') && !Kotlin.equals(p, '*')) {
                            if (p.endsWith('=')) {
                              p = p + '*';
                            }
                            var pArray = Kotlin.splitString(p, '=');
                            var pObject;
                            if (pArray.length > 1) {
                              var paramKey = pArray[0].trim();
                              var negative = paramKey.endsWith('!');
                              pObject = new _.org.kevoree.modeling.api.util.KmfQueryParam(paramKey.replace('!', ''), pArray[1].trim(), _.kotlin.get_size(params_0), negative);
                              var tmp$0;
                              params_0.put_wn2jw4$((tmp$0 = pObject.name) != null ? tmp$0 : Kotlin.throwNPE(), pObject);
                            }
                             else {
                              pObject = new _.org.kevoree.modeling.api.util.KmfQueryParam(null, p, _.kotlin.get_size(params_0), false);
                              params_0.put_wn2jw4$('@id', pObject);
                            }
                          }
                          lastStart = iParam + 1;
                        }
                         else {
                          if (paramString.charAt(iParam) === '\\') {
                            escaped = true;
                          }
                           else {
                            escaped = false;
                          }
                        }
                        iParam = iParam + 1;
                      }
                      var lastParam = paramString.substring(lastStart, iParam).trim();
                      if (!Kotlin.equals(lastParam, '') && !Kotlin.equals(lastParam, '*')) {
                        if (lastParam.endsWith('=')) {
                          lastParam = lastParam + '*';
                        }
                        var pArray_0 = Kotlin.splitString(lastParam, '=');
                        var pObject_0;
                        if (pArray_0.length > 1) {
                          var paramKey_0 = pArray_0[0].trim();
                          var negative_0 = paramKey_0.endsWith('!');
                          pObject_0 = new _.org.kevoree.modeling.api.util.KmfQueryParam(paramKey_0.replace('!', ''), pArray_0[1].trim(), _.kotlin.get_size(params_0), negative_0);
                          var tmp$1;
                          params_0.put_wn2jw4$((tmp$1 = pObject_0.name) != null ? tmp$1 : Kotlin.throwNPE(), pObject_0);
                        }
                         else {
                          pObject_0 = new _.org.kevoree.modeling.api.util.KmfQueryParam(null, lastParam, _.kotlin.get_size(params_0), false);
                          params_0.put_wn2jw4$('@id', pObject_0);
                        }
                      }
                    }
                    return new _.org.kevoree.modeling.api.util.KmfQuery(relName, params_0, subQuery_0, oldString, false, false);
                  }
                  return null;
                }
              });
            }, /** @lends _.org.kevoree.modeling.api.util */ {
              ModelVisitor: Kotlin.createClass(null, function () {
                this.visitStopped = false;
                this.visitChildren = true;
                this.visitReferences = true;
                this.alreadyVisited = null;
              }, /** @lends _.org.kevoree.modeling.api.util.ModelVisitor.prototype */ {
                stopVisit: function () {
                  this.visitStopped = true;
                },
                noChildrenVisit: function () {
                  this.visitChildren = false;
                },
                noReferencesVisit: function () {
                  this.visitReferences = false;
                },
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                  return true;
                },
                endVisitRef: function (refName) {
                }
              }),
              ElementAttributeType: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.util.ElementAttributeType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    ATTRIBUTE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    REFERENCE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    CONTAINMENT: new _.org.kevoree.modeling.api.util.ElementAttributeType()
                  });
                }
              }),
              ActionType: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun(code) {
                $fun.baseInitializer.call(this);
                this.code = code;
              }, null, /** @lends _.org.kevoree.modeling.api.util.ActionType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    SET: new _.org.kevoree.modeling.api.util.ActionType('S'),
                    ADD: new _.org.kevoree.modeling.api.util.ActionType('a'),
                    REMOVE: new _.org.kevoree.modeling.api.util.ActionType('r'),
                    ADD_ALL: new _.org.kevoree.modeling.api.util.ActionType('A'),
                    REMOVE_ALL: new _.org.kevoree.modeling.api.util.ActionType('R'),
                    RENEW_INDEX: new _.org.kevoree.modeling.api.util.ActionType('I'),
                    CONTROL: new _.org.kevoree.modeling.api.util.ActionType('C')
                  });
                }
              }),
              ModelAttributeVisitor: Kotlin.createTrait(null),
              InboundRefAware: Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.util.InboundRefAware.prototype */ {
                internal_inboundReferences: {
                  get: function () {
                    return this.$internal_inboundReferences_geftyz$;
                  },
                  set: function (tmp$0) {
                    this.$internal_inboundReferences_geftyz$ = tmp$0;
                  }
                }
              }),
              ModelTracker: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.events.ModelElementListener];
              }, function (compare) {
                this.compare = compare;
                this.convertor = new _.org.kevoree.modeling.api.trace.Event2Trace(this.compare);
                this.currentModel = null;
                this.invertedTraceSequence = null;
                this.traceSequence = null;
                this.activated = true;
              }, /** @lends _.org.kevoree.modeling.api.util.ModelTracker.prototype */ {
                elementChanged: function (evt) {
                  if (this.activated) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).append(this.convertor.convert(evt));
                    ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).append(this.convertor.inverse(evt));
                  }
                },
                track: function (model) {
                  this.currentModel = model;
                  var tmp$0;
                  ((tmp$0 = this.currentModel) != null ? tmp$0 : Kotlin.throwNPE()).addModelTreeListener(this);
                  this.traceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                  this.invertedTraceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                },
                untrack: function () {
                  var tmp$0;
                  (tmp$0 = this.currentModel) != null ? tmp$0.removeModelTreeListener(this) : null;
                },
                redo: function () {
                  if (this.currentModel != null && this.traceSequence != null) {
                    this.activated = false;
                    try {
                      var tmp$0, tmp$1;
                      ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).applyOn((tmp$1 = this.currentModel) != null ? tmp$1 : Kotlin.throwNPE());
                    }
                    finally {
                      this.activated = true;
                    }
                  }
                },
                undo: function () {
                  if (this.currentModel != null && this.invertedTraceSequence != null) {
                    this.activated = false;
                    var tmp$0;
                    ((tmp$0 = this.invertedTraceSequence) != null ? tmp$0 : Kotlin.throwNPE()).reverse();
                    try {
                      var tmp$1, tmp$2;
                      ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).applyOn((tmp$2 = this.currentModel) != null ? tmp$2 : Kotlin.throwNPE());
                    }
                    finally {
                      var tmp$3;
                      ((tmp$3 = this.invertedTraceSequence) != null ? tmp$3 : Kotlin.throwNPE()).reverse();
                      this.activated = true;
                    }
                  }
                },
                reset: function () {
                  this.traceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                  this.invertedTraceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                }
              }),
              visit$f: function (i) {
                return false;
              },
              visit$f_0: function (staticExtractedQuery, subResult) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                }, null, {
                  visit: function (value, name, parent) {
                    {
                      var tmp$0 = staticExtractedQuery.params.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var att = tmp$0.next();
                        if (Kotlin.equals(att, '@id')) {
                          throw new Error('Malformed KMFQuery, bad selector attribute without attribute name : ' + staticExtractedQuery.params.get_za3rmp$(att));
                        }
                         else {
                          var keySelected = false;
                          if (Kotlin.equals(att, name)) {
                            keySelected = true;
                          }
                           else {
                            if (att.contains('*') && _.js.matches_94jgcu$(name, att.replace('*', '.*'))) {
                              keySelected = true;
                            }
                          }
                          var tmp$1;
                          var attvalue = (tmp$1 = staticExtractedQuery.params.get_za3rmp$(att)) != null ? tmp$1 : Kotlin.throwNPE();
                          if (keySelected) {
                            if (value == null) {
                              if (attvalue.negative) {
                                if (!Kotlin.equals(attvalue.value, 'null')) {
                                  subResult[attvalue.idParam] = true;
                                }
                              }
                               else {
                                if (Kotlin.equals(attvalue.value, 'null')) {
                                  subResult[attvalue.idParam] = true;
                                }
                              }
                            }
                             else {
                              if (attvalue.negative) {
                                if (!attvalue.value.contains('*') && !Kotlin.equals(value, attvalue.value)) {
                                  subResult[attvalue.idParam] = true;
                                }
                                 else {
                                  if (!_.js.matches_94jgcu$(value.toString(), attvalue.value.replace('*', '.*'))) {
                                    subResult[attvalue.idParam] = true;
                                  }
                                }
                              }
                               else {
                                if (Kotlin.equals(value, attvalue.value)) {
                                  subResult[attvalue.idParam] = true;
                                }
                                 else {
                                  if (_.js.matches_94jgcu$(value.toString(), attvalue.value.replace('*', '.*'))) {
                                    subResult[attvalue.idParam] = true;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                });
              },
              select$f: function (staticExtractedQuery, alreadyVisited, tempResult) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  beginVisitRef: function (refName, refType) {
                    if (staticExtractedQuery.previousIsDeep) {
                      return true;
                    }
                     else {
                      if (Kotlin.equals(refName, staticExtractedQuery.relationName)) {
                        return true;
                      }
                       else {
                        if (staticExtractedQuery.relationName.contains('*')) {
                          if (_.js.matches_94jgcu$(refName, staticExtractedQuery.relationName.replace('*', '.*'))) {
                            return true;
                          }
                        }
                      }
                      return false;
                    }
                  },
                  visit: function (elem, refNameInParent, parent) {
                    if (staticExtractedQuery.previousIsRefDeep) {
                      if (alreadyVisited.v.containsKey_za3rmp$(parent.path() + '/' + refNameInParent + '[' + elem.internalGetKey() + ']')) {
                        return;
                      }
                    }
                    if (staticExtractedQuery.previousIsDeep && !staticExtractedQuery.previousIsRefDeep) {
                      if (alreadyVisited.v.containsKey_za3rmp$(elem.path())) {
                        return;
                      }
                    }
                    var selected = true;
                    if (staticExtractedQuery.previousIsDeep) {
                      selected = false;
                      if (Kotlin.equals(refNameInParent, staticExtractedQuery.relationName)) {
                        selected = true;
                      }
                       else {
                        if (staticExtractedQuery.relationName.contains('*')) {
                          if (_.js.matches_94jgcu$(refNameInParent, staticExtractedQuery.relationName.replace('*', '.*'))) {
                            selected = true;
                          }
                        }
                      }
                    }
                    if (selected) {
                      var tmp$0;
                      if (_.kotlin.get_size(staticExtractedQuery.params) === 1 && staticExtractedQuery.params.get_za3rmp$('@id') != null && ((tmp$0 = staticExtractedQuery.params.get_za3rmp$('@id')) != null ? tmp$0 : Kotlin.throwNPE()).name == null) {
                        var tmp$1;
                        if (Kotlin.equals(elem.internalGetKey(), (tmp$1 = staticExtractedQuery.params.get_za3rmp$('@id')) != null ? tmp$1.value : null)) {
                          tempResult.v.put_wn2jw4$(elem.path(), elem);
                        }
                      }
                       else {
                        if (_.kotlin.get_size(staticExtractedQuery.params) > 0) {
                          var subResult = Kotlin.arrayFromFun(_.kotlin.get_size(staticExtractedQuery.params), _.org.kevoree.modeling.api.util.visit$f);
                          elem.visitAttributes(_.org.kevoree.modeling.api.util.visit$f_0(staticExtractedQuery, subResult));
                          var finalRes = true;
                          var tmp$2, tmp$3, tmp$4;
                          {
                            tmp$2 = subResult, tmp$3 = tmp$2.length;
                            for (var tmp$4 = 0; tmp$4 !== tmp$3; ++tmp$4) {
                              var sub = tmp$2[tmp$4];
                              if (!sub) {
                                finalRes = false;
                              }
                            }
                          }
                          if (finalRes) {
                            tempResult.v.put_wn2jw4$(elem.path(), elem);
                          }
                        }
                         else {
                          tempResult.v.put_wn2jw4$(elem.path(), elem);
                        }
                      }
                    }
                    if (staticExtractedQuery.previousIsDeep) {
                      if (staticExtractedQuery.previousIsRefDeep) {
                        alreadyVisited.v.put_wn2jw4$(parent.path() + '/' + refNameInParent + '[' + elem.internalGetKey() + ']', true);
                        elem.visit(this, false, true, true);
                      }
                       else {
                        alreadyVisited.v.put_wn2jw4$(elem.path(), true);
                        elem.visit(this, false, true, false);
                      }
                    }
                  }
                });
              },
              KmfQuery: Kotlin.createClass(null, function (relationName, params, subQuery, oldString, previousIsDeep, previousIsRefDeep) {
                this.relationName = relationName;
                this.params = params;
                this.subQuery = subQuery;
                this.oldString = oldString;
                this.previousIsDeep = previousIsDeep;
                this.previousIsRefDeep = previousIsRefDeep;
              }, /** @lends _.org.kevoree.modeling.api.util.KmfQuery.prototype */ {
                component1: function () {
                  return this.relationName;
                },
                component2: function () {
                  return this.params;
                },
                component3: function () {
                  return this.subQuery;
                },
                component4: function () {
                  return this.oldString;
                },
                component5: function () {
                  return this.previousIsDeep;
                },
                component6: function () {
                  return this.previousIsRefDeep;
                },
                copy: function (relationName, params, subQuery, oldString, previousIsDeep, previousIsRefDeep) {
                  return new _.org.kevoree.modeling.api.util.KmfQuery(relationName === void 0 ? this.relationName : relationName, params === void 0 ? this.params : params, subQuery === void 0 ? this.subQuery : subQuery, oldString === void 0 ? this.oldString : oldString, previousIsDeep === void 0 ? this.previousIsDeep : previousIsDeep, previousIsRefDeep === void 0 ? this.previousIsRefDeep : previousIsRefDeep);
                },
                toString: function () {
                  return 'KmfQuery(relationName=' + Kotlin.toString(this.relationName) + (', params=' + Kotlin.toString(this.params)) + (', subQuery=' + Kotlin.toString(this.subQuery)) + (', oldString=' + Kotlin.toString(this.oldString)) + (', previousIsDeep=' + Kotlin.toString(this.previousIsDeep)) + (', previousIsRefDeep=' + Kotlin.toString(this.previousIsRefDeep)) + ')';
                },
                hashCode: function () {
                  var result = -1987101201;
                  result = result * 31 + Kotlin.hashCode(this.relationName) | 0;
                  result = result * 31 + Kotlin.hashCode(this.params) | 0;
                  result = result * 31 + Kotlin.hashCode(this.subQuery) | 0;
                  result = result * 31 + Kotlin.hashCode(this.oldString) | 0;
                  result = result * 31 + Kotlin.hashCode(this.previousIsDeep) | 0;
                  result = result * 31 + Kotlin.hashCode(this.previousIsRefDeep) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.relationName, other.relationName) && Kotlin.equals(this.params, other.params) && Kotlin.equals(this.subQuery, other.subQuery) && Kotlin.equals(this.oldString, other.oldString) && Kotlin.equals(this.previousIsDeep, other.previousIsDeep) && Kotlin.equals(this.previousIsRefDeep, other.previousIsRefDeep))));
                }
              }),
              KmfQueryParam: Kotlin.createClass(null, function (name, value, idParam, negative) {
                this.name = name;
                this.value = value;
                this.idParam = idParam;
                this.negative = negative;
              }, /** @lends _.org.kevoree.modeling.api.util.KmfQueryParam.prototype */ {
                component1: function () {
                  return this.name;
                },
                component2: function () {
                  return this.value;
                },
                component3: function () {
                  return this.idParam;
                },
                component4: function () {
                  return this.negative;
                },
                copy: function (name, value, idParam, negative) {
                  return new _.org.kevoree.modeling.api.util.KmfQueryParam(name === void 0 ? this.name : name, value === void 0 ? this.value : value, idParam === void 0 ? this.idParam : idParam, negative === void 0 ? this.negative : negative);
                },
                toString: function () {
                  return 'KmfQueryParam(name=' + Kotlin.toString(this.name) + (', value=' + Kotlin.toString(this.value)) + (', idParam=' + Kotlin.toString(this.idParam)) + (', negative=' + Kotlin.toString(this.negative)) + ')';
                },
                hashCode: function () {
                  var result = -874887202;
                  result = result * 31 + Kotlin.hashCode(this.name) | 0;
                  result = result * 31 + Kotlin.hashCode(this.value) | 0;
                  result = result * 31 + Kotlin.hashCode(this.idParam) | 0;
                  result = result * 31 + Kotlin.hashCode(this.negative) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.value, other.value) && Kotlin.equals(this.idParam, other.idParam) && Kotlin.equals(this.negative, other.negative))));
                }
              })
            }),
            persistence: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.persistence */ {
              PersistenceKMFFactory: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.events.ModelElementListener, _.org.kevoree.modeling.api.KMFFactory];
              }, /** @lends _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory.prototype */ {
                datastore: {
                  get: function () {
                    return this.$datastore_xkqfe9$;
                  }
                },
                dirty: {
                  get: function () {
                    return this.$dirty_e66hhy$;
                  },
                  set: function (tmp$0) {
                    this.$dirty_e66hhy$ = tmp$0;
                  }
                },
                originTransaction: {
                  get: function () {
                    return this.$originTransaction_kdsx68$;
                  }
                },
                remove: function (elem) {
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elem.path());
                  this.datastore.remove('type', elem.path());
                  this.elem_cache.remove_za3rmp$(elem.path());
                  this.modified_elements.remove_za3rmp$(Kotlin.hashCode(elem).toString() + elem.internalGetKey());
                },
                elem_cache: {
                  get: function () {
                    return this.$elem_cache_55i3ba$;
                  }
                },
                elementsToBeRemoved: {
                  get: function () {
                    return this.$elementsToBeRemoved_qnzocd$;
                  }
                },
                modified_elements: {
                  get: function () {
                    return this.$modified_elements_qtc91h$;
                  }
                },
                notify: function (elem) {
                  if (elem.internalGetKey() != null) {
                    var key = Kotlin.hashCode(elem).toString() + elem.internalGetKey();
                    if (this.modified_elements.get_za3rmp$(key) == null) {
                      this.modified_elements.put_wn2jw4$(key, elem);
                    }
                    if (elem.path().startsWith('/')) {
                      this.elem_cache.put_wn2jw4$(elem.path(), elem);
                    }
                  }
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    elem.isDirty = true;
                  }
                },
                cleanUnusedPaths: function (path) {
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), path);
                  this.datastore.remove('type', path);
                  this.elem_cache.remove_za3rmp$(path);
                },
                persist: function (elem) {
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    return;
                  }
                  var elemPath = elem.path();
                  if (Kotlin.equals(elemPath, '')) {
                    throw new Error('Internal error, empty path found during persist method ' + elem);
                  }
                  if (!elemPath.startsWith('/')) {
                    throw new Error('Cannot persist, because the path of the element do not refer to a root: ' + elemPath + ' -> ' + elem);
                  }
                  var traces = elem.toTraces(true, true);
                  var traceSeq = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  traceSeq.populate(traces);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elemPath, traceSeq.exportToString());
                  var castedInBounds = elem;
                  var saved = _.org.kevoree.modeling.api.time.blob.MetaHelper.serialize(castedInBounds.internal_inboundReferences);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elemPath + '#', saved);
                  this.datastore.put('type', elemPath, elem.metaClassName());
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy)) {
                    elem.originFactory = this;
                  }
                },
                endCommit: function () {
                  this.datastore.commit();
                },
                commit: function () {
                  if (!this.dirty) {
                    return;
                  }
                  var keys = _.kotlin.toList_h3panj$(this.modified_elements.keySet());
                  {
                    var tmp$0 = keys.iterator();
                    while (tmp$0.hasNext()) {
                      var elem = tmp$0.next();
                      var resolved = this.modified_elements.get_za3rmp$(elem);
                      if (resolved != null) {
                        if (!resolved.path().startsWith('/')) {
                          if (!resolved.isDeleted()) {
                            resolved.delete();
                          }
                          this.modified_elements.remove_za3rmp$(elem);
                        }
                      }
                    }
                  }
                  {
                    var tmp$1 = this.modified_elements.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var elemKey = tmp$1.next();
                      var tmp$2;
                      var elem_0 = (tmp$2 = this.modified_elements.get_za3rmp$(elemKey)) != null ? tmp$2 : Kotlin.throwNPE();
                      this.persist(elem_0);
                      this.elementsToBeRemoved.remove_za3rmp$(elem_0.path());
                    }
                  }
                  {
                    var tmp$3 = this.elementsToBeRemoved.iterator();
                    while (tmp$3.hasNext()) {
                      var e = tmp$3.next();
                      this.cleanUnusedPaths(e);
                    }
                  }
                },
                clear: function () {
                  {
                    var tmp$0 = this.elem_cache.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var elemKey = tmp$0.next();
                      var tmp$1;
                      var elem = (tmp$1 = this.elem_cache.get_za3rmp$(elemKey)) != null ? tmp$1 : Kotlin.throwNPE();
                      elem.removeModelElementListener(this);
                    }
                  }
                  this.elem_cache.clear();
                  this.modified_elements.clear();
                  this.elementsToBeRemoved.clear();
                },
                elementChanged: function (evt) {
                  var tmp$0;
                  ((tmp$0 = evt.source) != null ? tmp$0 : Kotlin.throwNPE()).isDirty = true;
                  this.notify(evt.source);
                },
                monitor: function (elem) {
                  if (!this.dirty) {
                    this.dirty = true;
                  }
                  elem.addModelElementListener(this);
                },
                lookup: function (path) {
                  if (Kotlin.equals(path, '')) {
                    return null;
                  }
                  if (this.elem_cache.containsKey_za3rmp$(path)) {
                    return this.elem_cache.get_za3rmp$(path);
                  }
                  var typeName = this.datastore.get('type', path);
                  if (typeName != null) {
                    var tmp$0;
                    var elem = (tmp$0 = this.create(typeName)) != null ? tmp$0 : Kotlin.throwNPE();
                    this.elem_cache.put_wn2jw4$(path, elem);
                    elem.isResolved = false;
                    elem.setOriginPath(path);
                    this.monitor(elem);
                    return elem;
                  }
                  return null;
                },
                getTraces: function (origin) {
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var traces = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), origin.path());
                  if (traces != null) {
                    sequence.populateFromString(traces);
                    return sequence;
                  }
                  return null;
                },
                loadInbounds: function (elem) {
                  var castedInBounds = elem;
                  var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elem.path() + '#');
                  if (payload != null) {
                    castedInBounds.internal_inboundReferences = _.org.kevoree.modeling.api.time.blob.MetaHelper.unserialize(payload, this);
                  }
                },
                select: function (query) {
                  var localRoot = this.lookup('/');
                  if (localRoot != null && Kotlin.equals(query, '/')) {
                    var result = new Kotlin.ArrayList();
                    result.add_za3rmp$(localRoot);
                    return result;
                  }
                  if (localRoot != null) {
                    return localRoot.select(query);
                  }
                   else {
                    return new Kotlin.ArrayList();
                  }
                }
              }),
              MemoryDataStore: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.persistence.DataStore];
              }, function () {
                this.selector_38kq2e$ = new _.org.kevoree.modeling.api.persistence.EventDispatcher();
                this.maps = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.persistence.MemoryDataStore.prototype */ {
                commit: function () {
                },
                register: function (listener, from, to, path) {
                  this.selector_38kq2e$.register(listener, from, to, path);
                },
                unregister: function (listener) {
                  this.selector_38kq2e$.unregister(listener);
                },
                notify: function (event) {
                  this.selector_38kq2e$.dispatch(event);
                },
                getSegmentKeys: function (segment) {
                  if (this.maps.containsKey_za3rmp$(segment)) {
                    var tmp$0;
                    ((tmp$0 = this.maps.get_za3rmp$(segment)) != null ? tmp$0 : Kotlin.throwNPE()).keySet();
                  }
                  return new Kotlin.PrimitiveHashSet();
                },
                getSegments: function () {
                  return this.maps.keySet();
                },
                close: function () {
                  this.selector_38kq2e$.clear();
                  this.maps.clear();
                },
                getOrCreateSegment: function (segment) {
                  if (!this.maps.containsKey_za3rmp$(segment)) {
                    this.maps.put_wn2jw4$(segment, new Kotlin.PrimitiveHashMap());
                  }
                  var tmp$0;
                  return (tmp$0 = this.maps.get_za3rmp$(segment)) != null ? tmp$0 : Kotlin.throwNPE();
                },
                put: function (segment, key, value) {
                  this.getOrCreateSegment(segment).put_wn2jw4$(key, value);
                },
                get: function (segment, key) {
                  return this.getOrCreateSegment(segment).get_za3rmp$(key);
                },
                remove: function (segment, key) {
                  this.getOrCreateSegment(segment).remove_za3rmp$(key);
                },
                dump: function () {
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(this.maps);
                    while (tmp$0.hasNext()) {
                      var k = tmp$0.next();
                      Kotlin.println('Map ' + _.kotlin.get_key(k));
                      {
                        var tmp$1 = _.kotlin.iterator_s8ckw1$(_.kotlin.get_value(k));
                        while (tmp$1.hasNext()) {
                          var t = tmp$1.next();
                          Kotlin.println(_.kotlin.get_key(t) + '->' + _.kotlin.get_value(t));
                        }
                      }
                    }
                  }
                }
              }),
              EventDispatcher: Kotlin.createClass(null, function () {
                this.listeners_3hhuzx$ = new Kotlin.ComplexHashMap();
              }, /** @lends _.org.kevoree.modeling.api.persistence.EventDispatcher.prototype */ {
                register: function (listener, from, to, pathRegex) {
                  this.listeners_3hhuzx$.put_wn2jw4$(listener, new _.org.kevoree.modeling.api.persistence.TimedRegistration(from, to, pathRegex));
                },
                unregister: function (listener) {
                  this.listeners_3hhuzx$.remove_za3rmp$(listener);
                },
                dispatch: function (event) {
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(this.listeners_3hhuzx$);
                    while (tmp$0.hasNext()) {
                      var l = tmp$0.next();
                      if (_.kotlin.get_value(l).covered(event)) {
                        _.kotlin.get_key(l).elementChanged(event);
                      }
                    }
                  }
                },
                clear: function () {
                  this.listeners_3hhuzx$.clear();
                }
              }),
              TimedRegistration: Kotlin.createClass(null, function (from, to, pathRegex) {
                this.from = from;
                this.to = to;
                this.pathRegex = pathRegex;
              }, /** @lends _.org.kevoree.modeling.api.persistence.TimedRegistration.prototype */ {
                covered: function (event) {
                  if (Kotlin.isType(event.source, _.org.kevoree.modeling.api.time.TimeAwareKMFContainer)) {
                    if (this.from != null) {
                      if (this.from < event.source.now) {
                        return false;
                      }
                    }
                    if (this.to != null) {
                      if (this.to < event.source.now) {
                        return false;
                      }
                    }
                  }
                  if (event.source != null) {
                    if (this.pathRegex.contains('*')) {
                      var regexPath = this.pathRegex.replace('*', '.*');
                      return _.js.matches_94jgcu$(event.source.path(), regexPath);
                    }
                     else {
                      return Kotlin.equals(event.source.path(), this.pathRegex);
                    }
                  }
                   else {
                    return false;
                  }
                },
                component1: function () {
                  return this.from;
                },
                component2: function () {
                  return this.to;
                },
                component3: function () {
                  return this.pathRegex;
                },
                copy: function (from, to, pathRegex) {
                  return new _.org.kevoree.modeling.api.persistence.TimedRegistration(from === void 0 ? this.from : from, to === void 0 ? this.to : to, pathRegex === void 0 ? this.pathRegex : pathRegex);
                },
                toString: function () {
                  return 'TimedRegistration(from=' + Kotlin.toString(this.from) + (', to=' + Kotlin.toString(this.to)) + (', pathRegex=' + Kotlin.toString(this.pathRegex)) + ')';
                },
                hashCode: function () {
                  var result = -551475360;
                  result = result * 31 + Kotlin.hashCode(this.from) | 0;
                  result = result * 31 + Kotlin.hashCode(this.to) | 0;
                  result = result * 31 + Kotlin.hashCode(this.pathRegex) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.from, other.from) && Kotlin.equals(this.to, other.to) && Kotlin.equals(this.pathRegex, other.pathRegex))));
                }
              }),
              DataStore: Kotlin.createTrait(null),
              KMFContainerProxy: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.KMFContainer];
              }, /** @lends _.org.kevoree.modeling.api.persistence.KMFContainerProxy.prototype */ {
                isResolved: {
                  get: function () {
                    return this.$isResolved_q9gcci$;
                  },
                  set: function (tmp$0) {
                    this.$isResolved_q9gcci$ = tmp$0;
                  }
                },
                inResolution: {
                  get: function () {
                    return this.$inResolution_fvhr0z$;
                  },
                  set: function (tmp$0) {
                    this.$inResolution_fvhr0z$ = tmp$0;
                  }
                },
                isDirty: {
                  get: function () {
                    return this.$isDirty_z1d6gk$;
                  },
                  set: function (tmp$0) {
                    this.$isDirty_z1d6gk$ = tmp$0;
                  }
                },
                originFactory: {
                  get: function () {
                    return this.$originFactory_8fzws8$;
                  },
                  set: function (tmp$0) {
                    this.$originFactory_8fzws8$ = tmp$0;
                  }
                },
                relativeLookupFrom: function (base, relationInParent, key) {
                  var currentPath = base.path();
                  if (Kotlin.equals(currentPath, '/')) {
                    var tmp$0;
                    return (tmp$0 = this.originFactory) != null ? tmp$0.lookup('/' + relationInParent + '[' + key + ']') : null;
                  }
                   else {
                    var tmp$1;
                    return (tmp$1 = this.originFactory) != null ? tmp$1.lookup(currentPath + '/' + relationInParent + '[' + key + ']') : null;
                  }
                }
              }),
              AbstractDataStore: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.persistence.DataStore];
              }, function () {
                this.selector_6kse09$ = new _.org.kevoree.modeling.api.persistence.EventDispatcher();
              }, /** @lends _.org.kevoree.modeling.api.persistence.AbstractDataStore.prototype */ {
                register: function (listener, from, to, path) {
                  this.selector_6kse09$.register(listener, from, to, path);
                },
                unregister: function (listener) {
                  this.selector_6kse09$.unregister(listener);
                },
                notify: function (event) {
                  this.selector_6kse09$.dispatch(event);
                }
              })
            }),
            json: Kotlin.definePackage(function () {
              this.JSONString = Kotlin.createObject(null, function () {
                this.escapeChar_iwx5i$ = '\\';
              }, {
                encodeBuffer: function (buffer, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (ch === '"') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('"');
                    }
                     else if (ch === this.escapeChar_iwx5i$) {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append(this.escapeChar_iwx5i$);
                    }
                     else if (ch === '\n') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('n');
                    }
                     else if (ch === '\r') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('r');
                    }
                     else if (ch === '\t') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('t');
                    }
                     else if (ch === '\u2028') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('u');
                      buffer.append('2');
                      buffer.append('0');
                      buffer.append('2');
                      buffer.append('8');
                    }
                     else if (ch === '\u2029') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('u');
                      buffer.append('2');
                      buffer.append('0');
                      buffer.append('2');
                      buffer.append('9');
                    }
                     else {
                      buffer.append(ch);
                    }
                    i = i + 1;
                  }
                },
                encode: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (ch === '"') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('"');
                    }
                     else if (ch === this.escapeChar_iwx5i$) {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1(this.escapeChar_iwx5i$);
                    }
                     else if (ch === '\n') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('n');
                    }
                     else if (ch === '\r') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('r');
                    }
                     else if (ch === '\t') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('t');
                    }
                     else if (ch === '\u2028') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('u');
                      ostream.print_1('2');
                      ostream.print_1('0');
                      ostream.print_1('2');
                      ostream.print_1('8');
                    }
                     else if (ch === '\u2029') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('u');
                      ostream.print_1('2');
                      ostream.print_1('0');
                      ostream.print_1('2');
                      ostream.print_1('9');
                    }
                     else {
                      ostream.print_1(ch);
                    }
                    i = i + 1;
                  }
                },
                unescape: function (src) {
                  if (src == null) {
                    return null;
                  }
                  if (src.length === 0) {
                    return src;
                  }
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var current = src.charAt(i);
                    if (current === this.escapeChar_iwx5i$) {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        builder != null ? builder.append(src.substring(0, i)) : null;
                      }
                      i++;
                      var current2 = src.charAt(i);
                      {
                        if (current2 === '"') {
                          builder != null ? builder.append('"') : null;
                        }
                         else if (current2 === '\\') {
                          builder != null ? builder.append(current2) : null;
                        }
                         else if (current2 === '/') {
                          builder != null ? builder.append(current2) : null;
                        }
                         else if (current2 === 'b') {
                          builder != null ? builder.append('\b') : null;
                        }
                         else if (current2 === 'f') {
                          builder != null ? builder.append((12).toChar()) : null;
                        }
                         else if (current2 === 'n') {
                          builder != null ? builder.append('\n') : null;
                        }
                         else if (current2 === 'r') {
                          builder != null ? builder.append('\r') : null;
                        }
                         else if (current2 === 't') {
                          builder != null ? builder.append('\t') : null;
                        }
                         else if (current2 === 'u') {
                          throw new Error('Bad char to escape ');
                        }
                      }
                    }
                     else {
                      if (builder != null) {
                        builder = builder != null ? builder.append(current) : null;
                      }
                    }
                    i++;
                  }
                  if (builder != null) {
                    return (builder != null ? builder : Kotlin.throwNPE()).toString();
                  }
                   else {
                    return src;
                  }
                }
              });
              this.Type = Kotlin.createObject(null, function () {
                this.VALUE = 0;
                this.LEFT_BRACE = 1;
                this.RIGHT_BRACE = 2;
                this.LEFT_BRACKET = 3;
                this.RIGHT_BRACKET = 4;
                this.COMMA = 5;
                this.COLON = 6;
                this.EOF = 42;
              });
            }, /** @lends _.org.kevoree.modeling.api.json */ {
              JSONModelLoader: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelLoader];
              }, function (factory) {
                this.factory = factory;
              }, /** @lends _.org.kevoree.modeling.api.json.JSONModelLoader.prototype */ {
                loadModelFromString: function (str) {
                  return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
                },
                loadModelFromStream: function (inputStream) {
                  return this.deserialize(inputStream);
                },
                deserialize: function (instream) {
                  if (instream == null) {
                    throw new Error('Null input Stream');
                  }
                  var resolverCommands = new Kotlin.ArrayList();
                  var roots = new Kotlin.ArrayList();
                  var lexer = new _.org.kevoree.modeling.api.json.Lexer(instream);
                  var currentToken = lexer.nextToken();
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                    this.loadObject(lexer, null, null, roots, resolverCommands);
                  }
                   else {
                    throw new Error('Bad Format / {\xA0expected');
                  }
                  {
                    var tmp$0 = resolverCommands.iterator();
                    while (tmp$0.hasNext()) {
                      var resol = tmp$0.next();
                      resol.run();
                    }
                  }
                  return roots;
                },
                loadObject: function (lexer, nameInParent, parent, roots, commands) {
                  var currentToken = lexer.nextToken();
                  var currentObject = null;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    if (Kotlin.equals(currentToken.value, 'class')) {
                      lexer.nextToken();
                      currentToken = lexer.nextToken();
                      var tmp$0, tmp$1;
                      var name = (tmp$1 = (tmp$0 = currentToken.value) != null ? tmp$0.toString() : null) != null ? tmp$1 : Kotlin.throwNPE();
                      var typeName = null;
                      var isRoot = false;
                      if (name.startsWith('root:')) {
                        isRoot = true;
                        name = name.substring('root:'.length);
                      }
                      if (name.contains('@')) {
                        typeName = name.substring(0, name.indexOf('@'));
                        var key = name.substring(name.indexOf('@') + 1);
                        if (parent == null) {
                          if (isRoot) {
                            currentObject = this.factory.lookup('/');
                          }
                        }
                         else {
                          var path = parent.path() + '/' + nameInParent + '[' + key + ']';
                          currentObject = this.factory.lookup(path);
                        }
                      }
                       else {
                        typeName = name;
                      }
                      if (currentObject == null) {
                        currentObject = this.factory.create(typeName != null ? typeName : Kotlin.throwNPE());
                      }
                      if (isRoot) {
                        this.factory.root(currentObject != null ? currentObject : Kotlin.throwNPE());
                      }
                      if (parent == null) {
                        roots.add_za3rmp$(currentObject != null ? currentObject : Kotlin.throwNPE());
                      }
                      var currentNameAttOrRef = null;
                      var refModel = false;
                      currentToken = lexer.nextToken();
                      while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                          this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                          if (currentNameAttOrRef == null) {
                            currentNameAttOrRef = Kotlin.toString(currentToken.value);
                          }
                           else {
                            if (refModel) {
                              var tmp$2;
                              commands.add_za3rmp$(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, ((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()).toString(), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                            }
                             else {
                              var unscaped = _.org.kevoree.modeling.api.json.JSONString.unescape(Kotlin.toString(currentToken.value));
                              (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), unscaped, false, false);
                              currentNameAttOrRef = null;
                            }
                          }
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                          currentToken = lexer.nextToken();
                          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                            this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                          }
                           else {
                            refModel = true;
                            if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                              var tmp$3;
                              commands.add_za3rmp$(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, ((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()).toString(), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                            }
                          }
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                          currentNameAttOrRef = null;
                          refModel = false;
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                          if (parent != null) {
                            parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                          }
                          return;
                        }
                        currentToken = lexer.nextToken();
                      }
                    }
                     else {
                      throw new Error('Bad Format / eClass att must be first');
                    }
                  }
                   else {
                    throw new Error('Bad Format');
                  }
                }
              }),
              ResolveCommand: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                this.roots = roots;
                this.ref = ref;
                this.currentRootElem = currentRootElem;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get_za3lpa$(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }
              }),
              Token: Kotlin.createClass(null, function (tokenType, value) {
                this.tokenType = tokenType;
                this.value = value;
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = this.tokenType.toString() + v;
                  return result;
                }
              }),
              Lexer: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.EOF = new _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null);
                this.index = 0;
                this.BOOLEAN_LETTERS = null;
                this.DIGIT = null;
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                },
                nextChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index++]);
                },
                peekChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                },
                isDone: function () {
                  return this.index >= this.bytes.length;
                },
                isBooleanLetter: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add_za3rmp$('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add_za3rmp$('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add_za3rmp$('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add_za3rmp$('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add_za3rmp$('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add_za3rmp$('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add_za3rmp$('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains_za3rmp$(c);
                },
                isDigit: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add_za3rmp$('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add_za3rmp$('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add_za3rmp$('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add_za3rmp$('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add_za3rmp$('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add_za3rmp$('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add_za3rmp$('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add_za3rmp$('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add_za3rmp$('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains_za3rmp$(c);
                },
                isValueLetter: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                },
                nextToken: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = new Kotlin.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw new Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return new _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }
              }),
              ModelReferenceVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(out) {
                $fun.baseInitializer.call(this);
                this.out = out;
                this.isFirst = true;
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: function (refName, refType) {
                  this.out.print_4(',"' + refName + '":[');
                  this.isFirst = true;
                  return true;
                },
                endVisitRef: function (refName) {
                  this.out.print_4(']');
                },
                visit: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print_4(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print_4('"' + elem.path() + '"');
                }
              }),
              JSONModelSerializer: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelSerializer];
              }, null, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer.prototype */ {
                serialize: function (model) {
                  var outstream = new _.java.io.ByteArrayOutputStream();
                  this.serializeToStream(model, outstream);
                  outstream.close();
                  return outstream.toString();
                },
                serializeToStream: function (model, raw) {
                  var out = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(raw), false);
                  var internalReferenceVisitor = new _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
                  var masterVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.serializeToStream$f(out, this, internalReferenceVisitor);
                  model.visit(masterVisitor, true, true, false);
                  out.flush();
                },
                printAttName: function (elem, out) {
                  var isRoot = '';
                  if (Kotlin.equals(elem.path(), '/')) {
                    isRoot = 'root:';
                  }
                  out.print_4('\n{"class":"' + isRoot + elem.metaClassName() + '@' + elem.internalGetKey() + '"');
                  var attributeVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.printAttName$f(out);
                  elem.visitAttributes(attributeVisitor);
                }
              }, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer */ {
                serializeToStream$f: function (out, this$JSONModelSerializer, internalReferenceVisitor) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                    this.isFirstInRef = true;
                  }, {
                    beginVisitElem: function (elem) {
                      if (!this.isFirstInRef) {
                        out.print_4(',');
                        this.isFirstInRef = false;
                      }
                      this$JSONModelSerializer.printAttName(elem, out);
                      var tmp$0;
                      (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
                      elem.visit(internalReferenceVisitor, false, false, true);
                    },
                    endVisitElem: function (elem) {
                      out.println_2('}');
                      this.isFirstInRef = false;
                    },
                    beginVisitRef: function (refName, refType) {
                      out.print_4(',"' + refName + '":[');
                      this.isFirstInRef = true;
                      return true;
                    },
                    endVisitRef: function (refName) {
                      out.print_4(']');
                      this.isFirstInRef = false;
                    },
                    visit: function (elem, refNameInParent, parent) {
                    }
                  });
                },
                printAttName$f: function (out) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                  }, null, {
                    visit: function (value, name, parent) {
                      if (value != null) {
                        out.print_4(',"' + name + '":"');
                        if (Kotlin.isType(value, Date)) {
                          _.org.kevoree.modeling.api.json.JSONString.encode(out, '' + value.getTime());
                        }
                         else {
                          _.org.kevoree.modeling.api.json.JSONString.encode(out, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                        }
                        out.print_4('"');
                      }
                    }
                  });
                }
              })
            }),
            xmi: Kotlin.definePackage(function () {
              this.Token = Kotlin.createObject(null, function () {
                this.XML_HEADER = 0;
                this.END_DOCUMENT = 1;
                this.START_TAG = 2;
                this.END_TAG = 3;
                this.COMMENT = 4;
                this.SINGLETON_TAG = 5;
              });
            }, /** @lends _.org.kevoree.modeling.api.xmi */ {
              ReferencesVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(ostream, addressTable, elementsCount, resourceSet) {
                $fun.baseInitializer.call(this);
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                this.value = null;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                endVisitRef: function (refName) {
                  if (this.value != null) {
                    this.ostream.print_4(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                },
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0;
                  var adjustedAddress = (tmp$0 = this.resourceSet) != null ? tmp$0.objToAddr(elem) : null;
                  if (adjustedAddress == null) {
                    adjustedAddress = this.addressTable.get_za3rmp$(elem);
                  }
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    var tmp$1, tmp$2;
                    this.value = ((tmp$1 = this.value) != null ? tmp$1 : Kotlin.throwNPE()) + ' ';
                    this.value = ((tmp$2 = this.value) != null ? tmp$2 : Kotlin.throwNPE()) + Kotlin.toString(adjustedAddress);
                  }
                }
              }),
              AttributesVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, function (ostream, ignoreGeneratedID) {
                this.ostream = ostream;
                this.ignoreGeneratedID = ignoreGeneratedID;
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: function (value, name, parent) {
                  if (value != null) {
                    if (this.ignoreGeneratedID && Kotlin.equals(name, 'generated_KMF_ID')) {
                      return;
                    }
                    if (typeof value === 'string' && Kotlin.equals(value, '')) {
                      return;
                    }
                    this.ostream.print_4(' ' + name + '="');
                    if (Kotlin.isType(value, Date)) {
                      this.escapeXml(this.ostream, '' + value.getTime());
                    }
                     else {
                      this.escapeXml(this.ostream, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                    }
                    this.ostream.print_4('"');
                  }
                },
                escapeXml: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print_4('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print_4('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print_4('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print_4('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print_4('&gt;');
                    }
                     else {
                      ostream.print_1(c);
                    }
                    i = i + 1;
                  }
                }
              }),
              ModelSerializationVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(ostream, addressTable, elementsCount, resourceSet, ignoreGeneratedID) {
                $fun.baseInitializer.call(this);
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                this.attributeVisitor = new _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream, ignoreGeneratedID);
                this.referenceVisitor = new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount, this.resourceSet);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                visit: function (elem, refNameInParent, parent) {
                  this.ostream.print_1('<');
                  this.ostream.print_4(refNameInParent);
                  this.ostream.print_4(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_1('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print_4('<\/');
                  this.ostream.print_4(refNameInParent);
                  this.ostream.print_1('>');
                  this.ostream.println();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ModelAddressVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(addressTable, elementsCount, packageList) {
                $fun.baseInitializer.call(this);
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.packageList = packageList;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0, tmp$1;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get_za3rmp$(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = (tmp$1 = this.elementsCount.get_za3rmp$(parentXmiAddress + '/@' + refNameInParent)) != null ? tmp$1 : 0;
                  this.addressTable.put_wn2jw4$(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put_wn2jw4$(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf_960177$(elem.metaClassName(), '.'));
                  if (!this.packageList.contains_za3rmp$(pack))
                    this.packageList.add_za3rmp$(pack);
                }
              }),
              XMIModelSerializer: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelSerializer];
              }, function () {
                this.resourceSet = null;
                this.ignoreGeneratedID = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelSerializer.prototype */ {
                serialize: function (oMS) {
                  var oo = new _.java.io.ByteArrayOutputStream();
                  this.serializeToStream(oMS, oo);
                  oo.flush();
                  return oo.toString();
                },
                serializeToStream: function (oMS, ostream) {
                  var wt = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(ostream), false);
                  var addressTable = new Kotlin.ComplexHashMap();
                  var packageList = new Kotlin.ArrayList();
                  addressTable.put_wn2jw4$(oMS, '/');
                  var elementsCount = new Kotlin.PrimitiveHashMap();
                  var addressBuilderVisitor = new _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
                  oMS.visit(addressBuilderVisitor, true, true, false);
                  var masterVisitor = new _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount, this.resourceSet, this.ignoreGeneratedID);
                  wt.println_2('<?xml version="1.0" encoding="UTF-8"?>');
                  wt.print_4('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
                  wt.print_4(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
                  wt.print_4(' xmi:version="2.0"');
                  wt.print_4(' xmlns:xmi="http://www.omg.org/XMI"');
                  var index = 0;
                  while (index < _.kotlin.get_size_1(packageList)) {
                    wt.print_4(' xmlns:' + packageList.get_za3lpa$(index).replace('.', '_') + '="http://' + packageList.get_za3lpa$(index) + '"');
                    index++;
                  }
                  oMS.visitAttributes(new _.org.kevoree.modeling.api.xmi.AttributesVisitor(wt, this.ignoreGeneratedID));
                  oMS.visit(new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount, this.resourceSet), false, false, true);
                  wt.println_2('>');
                  oMS.visit(masterVisitor, false, true, false);
                  wt.println_2('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
                  wt.flush();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ResourceSet: Kotlin.createClass(null, function () {
                this.resources_twji9r$ = new Kotlin.PrimitiveHashMap();
                this.invertedResources_583d58$ = new Kotlin.ComplexHashMap();
              }, /** @lends _.org.kevoree.modeling.api.xmi.ResourceSet.prototype */ {
                registerXmiAddrMappedObjects: function (nsuri, xmiAddrs) {
                  this.resources_twji9r$.put_wn2jw4$(nsuri, xmiAddrs);
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(xmiAddrs);
                    while (tmp$0.hasNext()) {
                      var ad = tmp$0.next();
                      if (this.invertedResources_583d58$.containsKey_za3rmp$(_.kotlin.get_value(ad))) {
                        var alreadyVal = this.invertedResources_583d58$.get_za3rmp$(_.kotlin.get_value(ad));
                        if ((alreadyVal != null ? alreadyVal : Kotlin.throwNPE()).addr.contains('@')) {
                          this.invertedResources_583d58$.put_wn2jw4$(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                        }
                      }
                       else {
                        this.invertedResources_583d58$.put_wn2jw4$(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                      }
                    }
                  }
                },
                resolveObject: function (xmiAddr) {
                  var typeAndAddr = Kotlin.splitString(xmiAddr, ' ');
                  if (typeAndAddr.length > 1) {
                    var addrs = Kotlin.splitString(typeAndAddr[1], '#');
                    if (addrs.length === 2) {
                      var resolvedAddrs = this.resources_twji9r$.get_za3rmp$(addrs[0]);
                      var addr = addrs[1];
                      addr = '#' + addr;
                      addr = addr.replace('#//', '/0/');
                      return resolvedAddrs != null ? resolvedAddrs.get_za3rmp$(addr) : null;
                    }
                  }
                  return null;
                },
                objToAddr: function (obj) {
                  var resolved = this.invertedResources_583d58$.get_za3rmp$(obj);
                  if (resolved != null) {
                    var packName = this.formatMetaClassName(obj.metaClassName());
                    var nsURI = resolved.nsuri;
                    var addr = resolved.addr;
                    addr = addr.replace('/0/', '#//');
                    return packName + ' ' + nsURI + addr;
                  }
                  return null;
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              XmiObjAddr: Kotlin.createClass(null, function (nsuri, addr) {
                this.nsuri = nsuri;
                this.addr = addr;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmiObjAddr.prototype */ {
                component1: function () {
                  return this.nsuri;
                },
                component2: function () {
                  return this.addr;
                },
                copy: function (nsuri, addr) {
                  return new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri === void 0 ? this.nsuri : nsuri, addr === void 0 ? this.addr : addr);
                },
                toString: function () {
                  return 'XmiObjAddr(nsuri=' + Kotlin.toString(this.nsuri) + (', addr=' + Kotlin.toString(this.addr)) + ')';
                },
                hashCode: function () {
                  var result = 977237871;
                  result = result * 31 + Kotlin.hashCode(this.nsuri) | 0;
                  result = result * 31 + Kotlin.hashCode(this.addr) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.nsuri, other.nsuri) && Kotlin.equals(this.addr, other.addr))));
                }
              }),
              XMIModelLoader: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelLoader];
              }, function (factory) {
                this.factory = factory;
                this.resourceSet = null;
                this.LOADER_XMI_LOCAL_NAME = 'type';
                this.LOADER_XMI_XSI = 'xsi';
                this.LOADER_XMI_NS_URI = 'nsURI';
                this.attributesHashmap_7wijs5$ = new Kotlin.PrimitiveHashMap();
                this.referencesHashmap_cc1kom$ = new Kotlin.PrimitiveHashMap();
                this.namedElementSupportActivated_71goxr$ = false;
                this.attributeVisitor_g67dla$ = _.org.kevoree.modeling.api.xmi.XMIModelLoader.XMIModelLoader$f(this);
                this.referencesVisitor_g5fzti$ = _.org.kevoree.modeling.api.xmi.XMIModelLoader.XMIModelLoader$f_0(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader.prototype */ {
                activateSupportForNamedElements: function (activate) {
                  this.namedElementSupportActivated_71goxr$ = activate;
                },
                unescapeXml: function (src) {
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var c = src.charAt(i);
                    if (c === '&') {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
                      }
                      if (src.charAt(i + 1) === 'a') {
                        if (src.charAt(i + 2) === 'm') {
                          builder != null ? builder.append('&') : null;
                          i = i + 5;
                        }
                         else if (src.charAt(i + 2) === 'p') {
                          builder != null ? builder.append("'") : null;
                          i = i + 6;
                        }
                         else {
                          Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
                        }
                      }
                       else if (src.charAt(i + 1) === 'q') {
                        builder != null ? builder.append('"') : null;
                        i = i + 6;
                      }
                       else if (src.charAt(i + 1) === 'l') {
                        builder != null ? builder.append('<') : null;
                        i = i + 4;
                      }
                       else if (src.charAt(i + 1) === 'g') {
                        builder != null ? builder.append('>') : null;
                        i = i + 4;
                      }
                       else {
                        Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
                      }
                    }
                     else {
                      if (builder != null) {
                        builder != null ? builder.append(c) : null;
                      }
                      i++;
                    }
                  }
                  if (builder != null) {
                    return Kotlin.toString(builder);
                  }
                   else {
                    return src;
                  }
                },
                loadModelFromString: function (str) {
                  var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
                  if (reader.hasNext()) {
                    return this.deserialize(reader);
                  }
                   else {
                    Kotlin.println('Loader::Nothing in the String !');
                    return null;
                  }
                },
                loadModelFromStream: function (inputStream) {
                  var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
                  if (reader.hasNext()) {
                    return this.deserialize(reader);
                  }
                   else {
                    Kotlin.println('Loader::Nothing in the file !');
                    return null;
                  }
                },
                loadObject: function (ctx, xmiAddress, objectType) {
                  if (objectType === void 0)
                    objectType = null;
                  var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
                  var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
                  var modelElem;
                  if (objectType != null) {
                    var tmp$1;
                    modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
                    if (modelElem == null) {
                      var xsiType = null;
                      var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
                      {
                        tmp$3 = new Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.start, tmp$5 = tmp$3.end, tmp$6 = tmp$3.increment;
                        for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                          var tmp$7, tmp$8;
                          var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                          var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                          if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                            var tmp$9;
                            xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                            break;
                          }
                        }
                      }
                      if (xsiType != null) {
                        var realTypeName = xsiType != null ? xsiType.substring(0, (xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':')) : null;
                        var realName = (xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length);
                        var tmp$10;
                        modelElem = (tmp$10 = this.factory) != null ? tmp$10.create(_.kotlin.plus_n7iowf$(realTypeName, '.') + realName) : null;
                      }
                    }
                  }
                   else {
                    var tmp$11;
                    modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName) : null;
                  }
                  if (modelElem == null) {
                    Kotlin.println('Could not create an object for local name ' + elementTagName);
                  }
                  ctx.map.put_wn2jw4$(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
                  if (!this.attributesHashmap_7wijs5$.containsKey_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
                    modelElem != null ? modelElem.visitAttributes(this.attributeVisitor_g67dla$) : null;
                  }
                  var elemAttributesMap = (tmp$12 = this.attributesHashmap_7wijs5$.get_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
                  if (!this.referencesHashmap_cc1kom$.containsKey_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
                    modelElem != null ? modelElem.visit(this.referencesVisitor_g5fzti$, false, true, false) : null;
                  }
                  var elemReferencesMap = (tmp$13 = this.referencesHashmap_cc1kom$.get_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
                  {
                    tmp$15 = new Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.start, tmp$17 = tmp$15.end, tmp$18 = tmp$15.increment;
                    for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
                      var tmp$19;
                      var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
                      if (prefix == null || Kotlin.equals(prefix, '')) {
                        var tmp$20, tmp$21;
                        var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0).trim();
                        var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0).trim();
                        if (valueAtt != null) {
                          if (elemAttributesMap.containsKey_za3rmp$(attrName)) {
                            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, this.unescapeXml(valueAtt), false, false) : null;
                            if (this.namedElementSupportActivated_71goxr$ && Kotlin.equals(attrName, 'name')) {
                              var parent = ctx.map.get_za3rmp$(xmiAddress.substring(0, xmiAddress.lastIndexOf('/')));
                              {
                                var tmp$22 = _.kotlin.toList_h3panj$(ctx.map.entrySet()).iterator();
                                while (tmp$22.hasNext()) {
                                  var entry = tmp$22.next();
                                  if (Kotlin.equals(_.kotlin.get_value(entry), parent)) {
                                    var refT = _.kotlin.get_key(entry) + '/' + this.unescapeXml(valueAtt);
                                    ctx.map.put_wn2jw4$(refT, modelElem != null ? modelElem : Kotlin.throwNPE());
                                  }
                                }
                              }
                            }
                          }
                           else {
                            if (!valueAtt.startsWith('#') && !valueAtt.startsWith('/')) {
                              if (this.resourceSet != null) {
                                var tmp$23;
                                var previousLoadedRef = ((tmp$23 = this.resourceSet) != null ? tmp$23 : Kotlin.throwNPE()).resolveObject(valueAtt);
                                if (previousLoadedRef != null) {
                                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, previousLoadedRef, true, false) : null;
                                }
                                 else {
                                  throw new Error('Unresolve NsURI based XMI reference ' + valueAtt);
                                }
                              }
                               else {
                                throw new Error('Bad XMI reference ' + valueAtt);
                              }
                            }
                             else {
                              var tmp$24, tmp$25, tmp$26;
                              {
                                tmp$24 = Kotlin.splitString(valueAtt, ' '), tmp$25 = tmp$24.length;
                                for (var tmp$26 = 0; tmp$26 !== tmp$25; ++tmp$26) {
                                  var xmiRef = tmp$24[tmp$26];
                                  var tmp$27, tmp$28;
                                  if (xmiRef.startsWith('#')) {
                                    tmp$27 = xmiRef.substring(1);
                                  }
                                   else {
                                    tmp$27 = xmiRef;
                                  }
                                  var adjustedRef = tmp$27;
                                  if (adjustedRef.startsWith('//')) {
                                    tmp$28 = '/0' + adjustedRef.substring(1);
                                  }
                                   else {
                                    tmp$28 = adjustedRef;
                                  }
                                  adjustedRef = tmp$28;
                                  adjustedRef = adjustedRef.replace('.0', '');
                                  var ref = ctx.map.get_za3rmp$(adjustedRef);
                                  if (ref != null) {
                                    modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, ref, true, false) : null;
                                  }
                                   else {
                                    ctx.resolvers.add_za3rmp$(new _.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, adjustedRef, this.resourceSet));
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var done = false;
                  while (!done) {
                    var tmp$29;
                    {
                      var tmp$30 = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).next();
                      if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
                        var tmp$31, tmp$32, tmp$34;
                        var subElemName = ((tmp$31 = ctx.xmiReader) != null ? tmp$31 : Kotlin.throwNPE()).getLocalName();
                        var i_1 = (tmp$32 = ctx.elementsCount.get_za3rmp$(xmiAddress + '/@' + subElemName)) != null ? tmp$32 : 0;
                        var tmp$33 = xmiAddress + '/@' + subElemName;
                        if (i_1 !== 0) {
                          tmp$34 = '.' + i_1;
                        }
                         else {
                          tmp$34 = '';
                        }
                        var subElementId = tmp$33 + tmp$34;
                        var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get_za3rmp$(subElemName));
                        modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, subElemName, containedElement, true, false) : null;
                        ctx.elementsCount.put_wn2jw4$(xmiAddress + '/@' + subElemName, i_1 + 1);
                      }
                       else if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
                        var tmp$35;
                        if (Kotlin.equals(((tmp$35 = ctx.xmiReader) != null ? tmp$35 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
                          done = true;
                        }
                      }
                       else {
                      }
                    }
                  }
                  return modelElem != null ? modelElem : Kotlin.throwNPE();
                },
                deserialize: function (reader) {
                  var nsURI = null;
                  var context = new _.org.kevoree.modeling.api.xmi.LoadingContext();
                  context.xmiReader = reader;
                  while (reader.hasNext()) {
                    var nextTag = reader.next();
                    {
                      if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
                        var localName = reader.getLocalName();
                        if (localName != null) {
                          var loadedRootsSize = context.loadedRoots.size();
                          var ns = new Kotlin.PrimitiveHashMap();
                          var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
                          {
                            tmp$1 = new Kotlin.NumberRange(0, ((tmp$0 = context.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$2 = tmp$1.start, tmp$3 = tmp$1.end, tmp$4 = tmp$1.increment;
                            for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                              var tmp$5, tmp$6;
                              var localName_0 = ((tmp$5 = context.xmiReader) != null ? tmp$5 : Kotlin.throwNPE()).getAttributeLocalName(i);
                              var localValue = ((tmp$6 = context.xmiReader) != null ? tmp$6 : Kotlin.throwNPE()).getAttributeValue(i);
                              if (Kotlin.equals(localName_0, this.LOADER_XMI_NS_URI)) {
                                nsURI = localValue;
                              }
                              ns.put_wn2jw4$(localName_0, localValue);
                            }
                          }
                          var xsiType = reader.tagPrefix;
                          var realTypeName = ns.get_za3rmp$(xsiType);
                          if (realTypeName == null) {
                            realTypeName = xsiType;
                          }
                          context.loadedRoots.add_za3rmp$(this.loadObject(context, '/' + loadedRootsSize, Kotlin.toString(xsiType) + '.' + localName));
                        }
                         else {
                          Kotlin.println('Tried to read a tag with null tag_name.');
                        }
                      }
                       else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
                        break;
                      }
                       else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
                        break;
                      }
                       else {
                      }
                    }
                  }
                  {
                    var tmp$7 = context.resolvers.iterator();
                    while (tmp$7.hasNext()) {
                      var res = tmp$7.next();
                      res.run();
                    }
                  }
                  if (this.resourceSet != null && nsURI != null) {
                    var tmp$8;
                    ((tmp$8 = this.resourceSet) != null ? tmp$8 : Kotlin.throwNPE()).registerXmiAddrMappedObjects(nsURI != null ? nsURI : Kotlin.throwNPE(), context.map);
                  }
                  return context.loadedRoots;
                }
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader */ {
                visit$f: function () {
                  return new Kotlin.PrimitiveHashMap();
                },
                XMIModelLoader$f: function (this$XMIModelLoader) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                  }, null, {
                    visit: function (value, name, parent) {
                      _.kotlin.getOrPut_ynyybx$(this$XMIModelLoader.attributesHashmap_7wijs5$, parent.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.visit$f).put_wn2jw4$(name, true);
                    }
                  });
                },
                beginVisitElem$f: function () {
                  return new Kotlin.PrimitiveHashMap();
                },
                XMIModelLoader$f_0: function (this$XMIModelLoader) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                    this.refMap = null;
                  }, {
                    beginVisitElem: function (elem) {
                      this.refMap = _.kotlin.getOrPut_ynyybx$(this$XMIModelLoader.referencesHashmap_cc1kom$, elem.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.beginVisitElem$f);
                    },
                    endVisitElem: function (elem) {
                      this.refMap = null;
                    },
                    beginVisitRef: function (refName, refType) {
                      var tmp$0;
                      ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put_wn2jw4$(refName, refType);
                      return true;
                    },
                    visit: function (elem, refNameInParent, parent) {
                    }
                  });
                }
              }),
              LoadingContext: Kotlin.createClass(null, function () {
                this.xmiReader = null;
                this.loadedRoots = new Kotlin.ArrayList();
                this.map = new Kotlin.PrimitiveHashMap();
                this.elementsCount = new Kotlin.PrimitiveHashMap();
                this.resolvers = new Kotlin.ArrayList();
                this.stats = new Kotlin.PrimitiveHashMap();
                this.oppositesAlreadySet = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get_za3rmp$(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get_za3rmp$(localRef + '_' + oppositeRef) != null;
                  return res;
                },
                storeOppositeRelation: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put_wn2jw4$(localRef + '_' + oppositeRef, true);
                }
              }),
              XMIResolveCommand: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref, resourceSet) {
                this.context = context;
                this.target = target;
                this.mutatorType = mutatorType;
                this.refName = refName;
                this.ref = ref;
                this.resourceSet = resourceSet;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = this.context.map.get_za3rmp$(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get_za3rmp$('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  if (this.resourceSet != null) {
                    referencedElement = this.resourceSet.resolveObject(this.ref);
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + this.target.metaClassName() + '(path:' + this.target.path() + ')');
                }
              }),
              XmlParser: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes_gdnk4p$ = this.inputStream.readBytes();
                this.index_gharkg$ = -1;
                this.currentChar_x9b225$ = null;
                this.xmlVersion_ywy43n$ = null;
                this.xmlCharset_tph6x5$ = null;
                this.tagName_b61wcj$ = '';
                this.tagPrefix = null;
                this.attributesNames_b5o00h$ = new Kotlin.ArrayList();
                this.attributesPrefixes_hgbl8n$ = new Kotlin.ArrayList();
                this.attributesValues_d28x97$ = new Kotlin.ArrayList();
                this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                this.attributePrefix_r6drlg$ = null;
                this.attributeValue_npfmfd$ = new Kotlin.StringBuilder();
                this.readSingleton_h1okvh$ = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: function () {
                  return this.bytes_gdnk4p$.length - this.index_gharkg$ > 2;
                },
                getLocalName: function () {
                  return this.tagName_b61wcj$;
                },
                getAttributeCount: function () {
                  return this.attributesNames_b5o00h$.size();
                },
                getAttributeLocalName: function (i) {
                  return this.attributesNames_b5o00h$.get_za3lpa$(i);
                },
                getAttributePrefix: function (i) {
                  return this.attributesPrefixes_hgbl8n$.get_za3lpa$(i);
                },
                getAttributeValue: function (i) {
                  return this.attributesValues_d28x97$.get_za3lpa$(i);
                },
                readChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes_gdnk4p$[++this.index_gharkg$]);
                },
                next: function () {
                  if (this.readSingleton_h1okvh$) {
                    this.readSingleton_h1okvh$ = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames_b5o00h$.clear();
                  this.attributesPrefixes_hgbl8n$.clear();
                  this.attributesValues_d28x97$.clear();
                  this.read_lessThan();
                  this.currentChar_x9b225$ = this.readChar();
                  if (this.currentChar_x9b225$ === '?') {
                    this.currentChar_x9b225$ = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar_x9b225$ === '!') {
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                    }
                     while (this.currentChar_x9b225$ !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar_x9b225$ === '/') {
                    this.currentChar_x9b225$ = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar_x9b225$ === '/') {
                      this.read_upperThan();
                      this.readSingleton_h1okvh$ = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                },
                read_lessThan: function () {
                  do {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                   while (this.currentChar_x9b225$ !== '<');
                },
                read_upperThan: function () {
                  while (this.currentChar_x9b225$ !== '>') {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                },
                read_xmlHeader: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                },
                read_closingTag: function () {
                  this.read_tagName();
                  this.read_upperThan();
                },
                read_openTag: function () {
                  this.read_tagName();
                  if (this.currentChar_x9b225$ !== '>' && this.currentChar_x9b225$ !== '/') {
                    this.read_attributes();
                  }
                },
                read_tagName: function () {
                  this.tagName_b61wcj$ = '' + this.currentChar_x9b225$;
                  this.tagPrefix = null;
                  this.currentChar_x9b225$ = this.readChar();
                  while (this.currentChar_x9b225$ !== ' ' && this.currentChar_x9b225$ !== '>' && this.currentChar_x9b225$ !== '/') {
                    if (this.currentChar_x9b225$ === ':') {
                      this.tagPrefix = this.tagName_b61wcj$;
                      this.tagName_b61wcj$ = '';
                    }
                     else {
                      this.tagName_b61wcj$ += this.currentChar_x9b225$;
                    }
                    this.currentChar_x9b225$ = this.readChar();
                  }
                },
                read_attributes: function () {
                  var end_of_tag = false;
                  while (this.currentChar_x9b225$ === ' ') {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar_x9b225$ !== '=') {
                      if (this.currentChar_x9b225$ === ':') {
                        this.attributePrefix_r6drlg$ = this.attributeName_f9qnph$.toString();
                        this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                      }
                       else {
                        var tmp$0;
                        this.attributeName_f9qnph$.append((tmp$0 = this.currentChar_x9b225$) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar_x9b225$ = this.readChar();
                    }
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                    }
                     while (this.currentChar_x9b225$ !== '"');
                    this.currentChar_x9b225$ = this.readChar();
                    while (this.currentChar_x9b225$ !== '"') {
                      var tmp$1;
                      this.attributeValue_npfmfd$.append((tmp$1 = this.currentChar_x9b225$) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar_x9b225$ = this.readChar();
                    }
                    this.attributesNames_b5o00h$.add_za3rmp$(this.attributeName_f9qnph$.toString());
                    this.attributesPrefixes_hgbl8n$.add_za3rmp$(this.attributePrefix_r6drlg$);
                    this.attributesValues_d28x97$.add_za3rmp$(this.attributeValue_npfmfd$.toString());
                    this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                    this.attributePrefix_r6drlg$ = null;
                    this.attributeValue_npfmfd$ = new Kotlin.StringBuilder();
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                      if (this.currentChar_x9b225$ === '?' || this.currentChar_x9b225$ === '/' || this.currentChar_x9b225$ === '-' || this.currentChar_x9b225$ === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar_x9b225$ === ' ');
                  }
                }
              })
            })
          })
        })
      }),
      w3c: Kotlin.definePackage(null, /** @lends _.org.w3c */ {
        dom: Kotlin.definePackage(null, /** @lends _.org.w3c.dom */ {
          events: Kotlin.definePackage(null, /** @lends _.org.w3c.dom.events */ {
            EventListener: Kotlin.createTrait(null)
          })
        })
      })
    }),
    java: Kotlin.definePackage(null, /** @lends _.java */ {
      util: Kotlin.definePackage(null, /** @lends _.java.util */ {
        concurrent: Kotlin.definePackage(null, /** @lends _.java.util.concurrent */ {
          ConcurrentHashMap: Kotlin.createClass(function () {
            return [Kotlin.HashMap];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          })
        }),
        IdentityHashMap: Kotlin.createClass(function () {
          return [Kotlin.HashMap];
        }, function $fun() {
          $fun.baseInitializer.call(this);
        }),
        HashSet_xeylzf$: function (c) {
          var set = new Kotlin.ComplexHashSet(c.size());
          set.addAll_xeylzf$(c);
          return set;
        },
        LinkedHashSet_xeylzf$: function (c) {
          var set = new Kotlin.LinkedHashSet(c.size());
          set.addAll_xeylzf$(c);
          return set;
        },
        HashMap_za3j1t$: function (m) {
          var map = new Kotlin.ComplexHashMap(m.size());
          map.putAll_za3j1t$(m);
          return map;
        },
        LinkedHashMap_za3j1t$: function (m) {
          var map = new Kotlin.LinkedHashMap(m.size());
          map.putAll_za3j1t$(m);
          return map;
        }
      }),
      lang: Kotlin.definePackage(function () {
        this.Long = Kotlin.createObject(null, null, {
          parseLong: function (s) {
            return s;
          }
        });
        this.Integer = Kotlin.createObject(null, null, {
          parseInt: function (s) {
            return s;
          }
        });
      }, /** @lends _.java.lang */ {
      }),
      io: Kotlin.definePackage(null, /** @lends _.java.io */ {
        InputStream: Kotlin.createTrait(null),
        OutputStream: Kotlin.createTrait(null),
        BufferedOutputStream: Kotlin.createClass(function () {
          return [_.java.io.OutputStream];
        }, function (oo) {
          this.oo = oo;
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: function (s) {
            this.oo.result = s;
          }
        }),
        ByteArrayInputStream: Kotlin.createClass(function () {
          return [_.java.io.InputStream];
        }, function (inputBytes) {
          this.inputBytes = inputBytes;
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: function () {
            return this.inputBytes;
          }
        }),
        ByteArrayOutputStream: Kotlin.createClass(function () {
          return [_.java.io.OutputStream];
        }, function () {
          this.result = '';
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: function () {
          },
          close: function () {
          },
          toString: function () {
            return this.result;
          }
        }),
        PrintStream: Kotlin.createClass(null, function (oo, autoflush) {
          this.oo = oo;
          this.result = '';
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println: function () {
            this.result = this.result + '\n';
          },
          print_4: function (s) {
            this.result = this.result + s;
          },
          println_2: function (s) {
            this.print_4(s);
            this.println();
          },
          print_1: function (s) {
            this.result = this.result + s;
          },
          print_2: function (s) {
            this.result = this.result + s;
          },
          print_3: function (s) {
            this.result = this.result + s;
          },
          print: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          },
          println_1: function (s) {
            this.print_1(s);
            this.println();
          },
          flush: function () {
            this.oo.write(this.result);
          },
          close: function () {
          }
        })
      })
    }),
    js: Kotlin.definePackage(null, /** @lends _.js */ {
      toChar_mz3mef$: function ($receiver) {
        return $receiver;
      },
      lastIndexOf_orzsrp$: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(ch.toString(), fromIndex);
      },
      lastIndexOf_960177$: function ($receiver, ch) {
        return $receiver.lastIndexOf(ch.toString());
      },
      indexOf_960177$: function ($receiver, ch) {
        return $receiver.indexOf(ch.toString());
      },
      indexOf_orzsrp$: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(ch.toString(), fromIndex);
      },
      matches_94jgcu$: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      },
      capitalize_pdl1w0$: function ($receiver) {
        return _.kotlin.isNotEmpty_pdl1w0$($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      },
      decapitalize_pdl1w0$: function ($receiver) {
        return _.kotlin.isNotEmpty_pdl1w0$($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }
    }),
    kotlin: Kotlin.definePackage(function () {
      this.stdlib_emptyList_w9bu57$ = new Kotlin.ArrayList();
      this.stdlib_emptyMap_h2vi7z$ = new Kotlin.ComplexHashMap();
    }, /** @lends _.kotlin */ {
      dom: Kotlin.definePackage(null, /** @lends _.kotlin.dom */ {
        createDocument: function () {
          return document.implementation.createDocument(null, null, null);
        },
        toXmlString_asww5t$: function ($receiver) {
          return $receiver.outerHTML;
        },
        toXmlString_rq0l4m$: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        },
        eventHandler: function (handler) {
          return new _.kotlin.dom.EventListenerHandler(handler);
        },
        EventListenerHandler: Kotlin.createClass(function () {
          return [_.org.w3c.dom.events.EventListener];
        }, function (handler) {
          this.handler = handler;
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }
        }),
        mouseEventHandler$f: function (handler) {
          return function (e) {
            if (Kotlin.isType(e, MouseEvent)) {
              handler(e);
            }
          };
        },
        mouseEventHandler: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.mouseEventHandler$f(handler));
        },
        on_10gtds$: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_edii0a$($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        },
        on_edii0a$: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            $receiver.addEventListener(name, listener, capture);
            tmp$0 = new _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        },
        CloseableEventListener: Kotlin.createClass(function () {
          return [Kotlin.Closeable];
        }, function (target, listener, name, capture) {
          this.target = target;
          this.listener = listener;
          this.name = name;
          this.capture = capture;
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }
        }),
        onClick_alenf6$: function ($receiver, capture, handler) {
          if (capture === void 0)
            capture = false;
          return _.kotlin.dom.on_edii0a$($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        onDoubleClick_alenf6$: function ($receiver, capture, handler) {
          if (capture === void 0)
            capture = false;
          return _.kotlin.dom.on_edii0a$($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        emptyElementList: function () {
          return Kotlin.emptyList();
        },
        emptyNodeList: function () {
          return Kotlin.emptyList();
        },
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = new Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value);
        }},
        get_id: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('id')) != null ? tmp$0 : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('style')) != null ? tmp$0 : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('class')) != null ? tmp$0 : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches_94jgcu$(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        },
        children: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        },
        childElements$f: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        },
        childElements$f_0: function (it) {
          return it;
        },
        childElements: function ($receiver) {
          return _.kotlin.map_vqr6wr$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.children($receiver), _.kotlin.dom.childElements$f), _.kotlin.dom.childElements$f_0);
        },
        childElements_1$f: function (name) {
          return function (it) {
            return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
          };
        },
        childElements_1$f_0: function (it) {
          return it;
        },
        childElements_1: function ($receiver, name) {
          return _.kotlin.map_vqr6wr$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.children($receiver), _.kotlin.dom.childElements_1$f(name)), _.kotlin.dom.childElements_1$f_0);
        },
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements_0: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements_1: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_2: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_3: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        elements_2_0: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        toList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = new _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        },
        toElementList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = new Kotlin.ArrayList();
          }
           else {
            tmp$0 = new _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        },
        get$f: function (selector) {
          return function (it) {
            return _.kotlin.dom.hasClass(it, selector.substring(1));
          };
        },
        get: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList_h3panj$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.get$f(selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayListOf_mzrxf8$([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_2($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        },
        get_1$f: function (selector) {
          return function (it) {
            return _.kotlin.dom.hasClass(it, selector.substring(1));
          };
        },
        get_1: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements_0($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList_h3panj$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.get_elements_0($receiver), _.kotlin.dom.get_1$f(selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayListOf_mzrxf8$([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements_1($receiver, selector);
          }
          return tmp$1;
        },
        NodeListAsList: Kotlin.createClass(function () {
          return [Kotlin.AbstractList];
        }, function $fun(nodeList) {
          $fun.baseInitializer.call(this);
          this.nodeList = nodeList;
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get_za3lpa$: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        ElementListAsList: Kotlin.createClass(function () {
          return [Kotlin.AbstractList];
        }, function $fun(nodeList) {
          $fun.baseInitializer.call(this);
          this.nodeList = nodeList;
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get_za3lpa$: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node;
            }
             else {
              throw new Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node);
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        clear: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        },
        nextSiblings: function ($receiver) {
          return new _.kotlin.dom.NextSiblings($receiver);
        },
        NextSiblings: Kotlin.createClass(null, function (node) {
          this.node = node;
        }, /** @lends _.kotlin.dom.NextSiblings.prototype */ {
          iterator: function () {
            return _.kotlin.dom.NextSiblings.iterator$f(this);
          }
        }, /** @lends _.kotlin.dom.NextSiblings */ {
          iterator$f: function (this$NextSiblings) {
            return Kotlin.createObject(function () {
              return [_.kotlin.support.AbstractIterator];
            }, function $fun() {
              $fun.baseInitializer.call(this);
            }, {
              computeNext: function () {
                var nextValue = this$NextSiblings.node.nextSibling;
                if (nextValue != null) {
                  this.setNext_za3rmp$(nextValue);
                  this$NextSiblings.node = nextValue;
                }
                 else {
                  this.done();
                }
              }
            });
          }
        }),
        previousSiblings: function ($receiver) {
          return new _.kotlin.dom.PreviousSiblings($receiver);
        },
        PreviousSiblings: Kotlin.createClass(null, function (node) {
          this.node = node;
        }, /** @lends _.kotlin.dom.PreviousSiblings.prototype */ {
          iterator: function () {
            return _.kotlin.dom.PreviousSiblings.iterator$f(this);
          }
        }, /** @lends _.kotlin.dom.PreviousSiblings */ {
          iterator$f: function (this$PreviousSiblings) {
            return Kotlin.createObject(function () {
              return [_.kotlin.support.AbstractIterator];
            }, function $fun() {
              $fun.baseInitializer.call(this);
            }, {
              computeNext: function () {
                var nextValue = this$PreviousSiblings.node.previousSibling;
                if (nextValue != null) {
                  this.setNext_za3rmp$(nextValue);
                  this$PreviousSiblings.node = nextValue;
                }
                 else {
                  this.done();
                }
              }
            });
          }
        }),
        isText: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        },
        attribute: function ($receiver, name) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute(name)) != null ? tmp$0 : '';
        },
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: function ($receiver, xmlDeclaration) {
          if (xmlDeclaration === void 0)
            xmlDeclaration = false;
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString_lwhwg8$(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        },
        nodesToXmlString_lwhwg8$: function (nodes, xmlDeclaration) {
          if (xmlDeclaration === void 0)
            xmlDeclaration = false;
          var builder = new Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_rq0l4m$(n, xmlDeclaration));
            }
          }
          return builder.toString();
        },
        plus_1: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        },
        plus: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text);
        },
        plusAssign: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text);
        },
        createElement: function ($receiver, name, init) {
          var elem = $receiver.createElement(name);
          init.call(elem);
          return elem;
        },
        createElement_1: function ($receiver, name, doc, init) {
          if (doc === void 0)
            doc = null;
          var elem = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name);
          init.call(elem);
          return elem;
        },
        ownerDocument: function ($receiver, doc) {
          if (doc === void 0)
            doc = null;
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver;
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw new Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver);
          }
           else {
            return answer;
          }
        },
        addElement: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        },
        addElement_1: function ($receiver, name, doc, init) {
          if (doc === void 0)
            doc = null;
          var child = _.kotlin.dom.createElement_1($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        },
        addText: function ($receiver, text, doc) {
          if (doc === void 0)
            doc = null;
          if (text != null) {
            var child = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text);
            $receiver.appendChild(child);
          }
          return $receiver;
        }
      }),
      test: Kotlin.definePackage(function () {
        this.asserter = new _.kotlin.test.QUnitAsserter();
      }, /** @lends _.kotlin.test */ {
        todo_n8bj3p$: function (block) {
          Kotlin.println('TODO at ' + block);
        },
        QUnitAsserter: Kotlin.createClass(function () {
          return [_.kotlin.test.Asserter];
        }, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue_ivxn3r$: function (message, actual) {
            ok(actual, message);
          },
          assertEquals_a59ba6$: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + Kotlin.toString(expected) + '> actual <' + Kotlin.toString(actual) + '>');
          },
          assertNotNull_bm4g0d$: function (message, actual) {
            ok(actual != null, message);
          },
          assertNull_bm4g0d$: function (message, actual) {
            ok(actual == null, message);
          },
          fail_61zpoe$: function (message) {
            ok(false, message);
          }
        }),
        assertTrue_2xfrrb$: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue_ivxn3r$(message, actual);
        },
        assertTrue_n8bj3p$: function (block) {
          _.kotlin.test.assertTrue_2xfrrb$('expected true', block);
        },
        assertNot_2xfrrb$f: function (block) {
          return function () {
            return !block();
          };
        },
        assertNot_2xfrrb$: function (message, block) {
          _.kotlin.test.assertTrue_2xfrrb$(message, _.kotlin.test.assertNot_2xfrrb$f(block));
        },
        assertNot_n8bj3p$: function (block) {
          _.kotlin.test.assertNot_2xfrrb$('expected false', block);
        },
        assertTrue_8kj6y5$: function (actual, message) {
          if (message === void 0)
            message = '';
          return _.kotlin.test.assertEquals_8vv676$(true, actual, message);
        },
        assertFalse_8kj6y5$: function (actual, message) {
          if (message === void 0)
            message = '';
          return _.kotlin.test.assertEquals_8vv676$(false, actual, message);
        },
        assertEquals_8vv676$: function (expected, actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertEquals_a59ba6$(message, expected, actual);
        },
        assertNotNull_hwpqgh$: function (actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertNotNull_bm4g0d$(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        },
        assertNotNull_74f9dl$: function (actual, block) {
          _.kotlin.test.assertNotNull_ll92s9$(actual, '', block);
        },
        assertNotNull_ll92s9$: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull_bm4g0d$(message, actual);
          if (actual != null) {
            block(actual);
          }
        },
        assertNull_hwpqgh$: function (actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertNull_bm4g0d$(message, actual);
        },
        fail_61zpoe$: function (message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.fail_61zpoe$(message);
        },
        expect_74f9dk$: function (expected, block) {
          _.kotlin.test.expect_ll92sa$(expected, 'expected ' + expected, block);
        },
        expect_ll92sa$: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals_8vv676$(expected, actual, message);
        },
        fails_n8bj3p$: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail_61zpoe$('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        },
        Asserter: Kotlin.createTrait(null)
      }),
      Pair: Kotlin.createClass(null, function (first, second) {
        this.first = first;
        this.second = second;
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ')';
        }
      }),
      Triple: Kotlin.createClass(null, function (first, second, third) {
        this.first = first;
        this.second = second;
        this.third = third;
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        component3: function () {
          return this.third;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ', ' + this.third + ')';
        }
      }),
      toString_h3panj$: function ($receiver) {
        return _.kotlin.makeString_mc2pv1$($receiver, ', ', '[', ']');
      },
      mapValues_lh0hhz$: function ($receiver, transform) {
        return _.kotlin.mapValuesTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(), transform);
      },
      iterator_rscjuh$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [Kotlin.Iterator];
        }, null, {
          hasNext: function () {
            return $receiver.hasMoreElements();
          },
          next: function () {
            return $receiver.nextElement();
          }
        });
      },
      iterator_h40uyb$: function ($receiver) {
        return $receiver;
      },
      EmptyIterableException: Kotlin.createClass(function () {
        return [Kotlin.RuntimeException];
      }, function $fun(it) {
        $fun.baseInitializer.call(this, it + ' is empty');
        this.it = it;
      }),
      DuplicateKeyException: Kotlin.createClass(function () {
        return [Kotlin.RuntimeException];
      }, function $fun(message) {
        if (message === void 0)
          message = 'Duplicate keys detected';
        $fun.baseInitializer.call(this, message);
      }),
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set_f7ra8x$: function ($receiver, key, value) {
        return $receiver.put_wn2jw4$(key, value);
      },
      orEmpty_s8ckw1$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyMap();
      },
      contains_6halgi$: function ($receiver, key) {
        return $receiver.containsKey_za3rmp$(key);
      },
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: function ($receiver) {
        return $receiver.getKey();
      },
      component2: function ($receiver) {
        return $receiver.getValue();
      },
      getOrElse_9bj33b$: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey_za3rmp$(key)) {
          return $receiver.get_za3rmp$(key);
        }
         else {
          return defaultValue();
        }
      },
      getOrPut_ynyybx$: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey_za3rmp$(key)) {
          return $receiver.get_za3rmp$(key);
        }
         else {
          var answer = defaultValue();
          $receiver.put_wn2jw4$(key, answer);
          return answer;
        }
      },
      iterator_s8ckw1$: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      },
      mapValuesTo_7qivbo$: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put_wn2jw4$(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      },
      putAll_nvpytz$: function ($receiver, values) {
        var tmp$1, tmp$2, tmp$3;
        {
          tmp$1 = values, tmp$2 = tmp$1.length;
          for (var tmp$3 = 0; tmp$3 !== tmp$2; ++tmp$3) {
            var tmp$0 = tmp$1[tmp$3]
            , key = tmp$0.component1()
            , value = tmp$0.component2();
            $receiver.put_wn2jw4$(key, value);
          }
        }
      },
      toMap_cj6vvg$: function ($receiver, map) {
        map.putAll_za3j1t$($receiver);
        return map;
      },
      toMap_uxbsj8$: function ($receiver, map) {
        {
          var tmp$1 = $receiver.iterator();
          while (tmp$1.hasNext()) {
            var tmp$0 = tmp$1.next()
            , key = tmp$0.component1()
            , value = tmp$0.component2();
            if (map.containsKey_za3rmp$(key)) {
              throw new _.kotlin.DuplicateKeyException();
            }
            map.put_wn2jw4$(key, value);
          }
        }
        return map;
      },
      toMap_h3panj$: function ($receiver) {
        return _.kotlin.toMap_uxbsj8$($receiver, new Kotlin.ComplexHashMap());
      },
      mapValues_gld13f$: function ($receiver, transform) {
        return _.kotlin.mapValuesTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(_.kotlin.get_size($receiver)), transform);
      },
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_0: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_1: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_2: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_3: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_4: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_5: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_6: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_7: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      Stream: Kotlin.createTrait(null),
      streamOf_mzrxf8$: function (elements) {
        return _.kotlin.stream_2hx8bi$(elements);
      },
      FilteringStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, sendWhen, predicate) {
        if (sendWhen === void 0)
          sendWhen = true;
        this.stream = stream;
        this.sendWhen = sendWhen;
        this.predicate = predicate;
      }, /** @lends _.kotlin.FilteringStream.prototype */ {
        iterator: function () {
          return _.kotlin.FilteringStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FilteringStream */ {
        iterator$f: function (this$FilteringStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$FilteringStream.stream.iterator();
          }, {
            computeNext: function () {
              while (this.iterator.hasNext()) {
                var item = this.iterator.next();
                if (Kotlin.equals(this$FilteringStream.predicate(item), this$FilteringStream.sendWhen)) {
                  this.setNext_za3rmp$(item);
                  return;
                }
              }
              this.done();
            }
          });
        }
      }),
      TransformingStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, transformer) {
        this.stream = stream;
        this.transformer = transformer;
      }, /** @lends _.kotlin.TransformingStream.prototype */ {
        iterator: function () {
          return _.kotlin.TransformingStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.TransformingStream */ {
        iterator$f: function (this$TransformingStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$TransformingStream.stream.iterator();
          }, {
            computeNext: function () {
              if (this.iterator.hasNext()) {
                this.setNext_za3rmp$(this$TransformingStream.transformer(this.iterator.next()));
              }
               else {
                this.done();
              }
            }
          });
        }
      }),
      MergingStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream1, stream2, transform) {
        this.stream1 = stream1;
        this.stream2 = stream2;
        this.transform = transform;
      }, /** @lends _.kotlin.MergingStream.prototype */ {
        iterator: function () {
          return _.kotlin.MergingStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.MergingStream */ {
        iterator$f: function (this$MergingStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator1 = this$MergingStream.stream1.iterator();
            this.iterator2 = this$MergingStream.stream2.iterator();
          }, {
            computeNext: function () {
              if (this.iterator1.hasNext() && this.iterator2.hasNext()) {
                this.setNext_za3rmp$(this$MergingStream.transform(this.iterator1.next(), this.iterator2.next()));
              }
               else {
                this.done();
              }
            }
          });
        }
      }),
      FlatteningStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, transformer) {
        this.stream = stream;
        this.transformer = transformer;
      }, /** @lends _.kotlin.FlatteningStream.prototype */ {
        iterator: function () {
          return _.kotlin.FlatteningStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FlatteningStream */ {
        iterator$f: function (this$FlatteningStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$FlatteningStream.stream.iterator();
            this.itemIterator = null;
          }, {
            computeNext: function () {
              while (this.itemIterator == null) {
                if (!this.iterator.hasNext()) {
                  this.done();
                  break;
                }
                 else {
                  var element = this.iterator.next();
                  var nextItemIterator = this$FlatteningStream.transformer(element).iterator();
                  if (nextItemIterator.hasNext())
                    this.itemIterator = nextItemIterator;
                }
              }
              var currentItemIterator = this.itemIterator;
              if (currentItemIterator == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(currentItemIterator.next());
                if (!currentItemIterator.hasNext())
                  this.itemIterator = null;
              }
            }
          });
        }
      }),
      Multistream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (streams) {
        this.streams = streams;
      }, /** @lends _.kotlin.Multistream.prototype */ {
        iterator: function () {
          return _.kotlin.Multistream.iterator$f(this);
        }
      }, /** @lends _.kotlin.Multistream */ {
        iterator$f: function (this$Multistream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$Multistream.streams.iterator();
            this.streamIterator = null;
          }, {
            computeNext: function () {
              while (this.streamIterator == null) {
                if (!this.iterator.hasNext()) {
                  this.done();
                  break;
                }
                 else {
                  var stream = this.iterator.next();
                  var nextStreamIterator = stream.iterator();
                  if (nextStreamIterator.hasNext())
                    this.streamIterator = nextStreamIterator;
                }
              }
              var currentStreamIterator = this.streamIterator;
              if (currentStreamIterator == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(currentStreamIterator.next());
                if (!currentStreamIterator.hasNext())
                  this.streamIterator = null;
              }
            }
          });
        }
      }),
      LimitedStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, stopWhen, predicate) {
        if (stopWhen === void 0)
          stopWhen = true;
        this.stream = stream;
        this.stopWhen = stopWhen;
        this.predicate = predicate;
      }, /** @lends _.kotlin.LimitedStream.prototype */ {
        iterator: function () {
          return _.kotlin.LimitedStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.LimitedStream */ {
        iterator$f: function (this$LimitedStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$LimitedStream.stream.iterator();
          }, {
            computeNext: function () {
              if (!this.iterator.hasNext()) {
                this.done();
              }
               else {
                var item = this.iterator.next();
                if (Kotlin.equals(this$LimitedStream.predicate(item), this$LimitedStream.stopWhen)) {
                  this.done();
                }
                 else {
                  this.setNext_za3rmp$(item);
                }
              }
            }
          });
        }
      }),
      FunctionStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (producer) {
        this.producer = producer;
      }, /** @lends _.kotlin.FunctionStream.prototype */ {
        iterator: function () {
          return _.kotlin.FunctionStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FunctionStream */ {
        iterator$f: function (this$FunctionStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            computeNext: function () {
              var item = this$FunctionStream.producer();
              if (item == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(item);
              }
            }
          });
        }
      }),
      stream_n8bj3p$: function (nextFunction) {
        return new _.kotlin.FunctionStream(nextFunction);
      },
      stream_74f9dl$: function (initialValue, nextFunction) {
        return _.kotlin.stream_n8bj3p$(_.kotlin.toGenerator_n1mtj3$(nextFunction, initialValue));
      },
      stdlib_emptyListClass: Kotlin.createClass(function () {
        return [_.kotlin.List];
      }, null),
      stdlib_emptyList: function () {
        return _.kotlin.stdlib_emptyList_w9bu57$;
      },
      stdlib_emptyMapClass: Kotlin.createClass(function () {
        return [_.kotlin.Map];
      }, null),
      stdlib_emptyMap: function () {
        return _.kotlin.stdlib_emptyMap_h2vi7z$;
      },
      listOf_mzrxf8$: function (values) {
        return values.length === 0 ? _.kotlin.stdlib_emptyList() : _.kotlin.arrayListOf_mzrxf8$(values);
      },
      listOf: function () {
        return _.kotlin.stdlib_emptyList();
      },
      mapOf_mzrxf8$: function (values) {
        return values.length === 0 ? _.kotlin.stdlib_emptyMap() : _.kotlin.hashMapOf_mzrxf8$(values);
      },
      mapOf: function () {
        return _.kotlin.stdlib_emptyMap();
      },
      arrayListOf_mzrxf8$: function (values) {
        return _.kotlin.toCollection_xpmo5j$(values, new Kotlin.ArrayList(values.length));
      },
      hashSetOf_mzrxf8$: function (values) {
        return _.kotlin.toCollection_xpmo5j$(values, new Kotlin.ComplexHashSet(values.length));
      },
      hashMapOf_mzrxf8$: function (values) {
        var answer = new Kotlin.ComplexHashMap(values.length);
        _.kotlin.putAll_nvpytz$(answer, values);
        return answer;
      },
      get_size_1: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty_0: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, _.kotlin.get_size_1($receiver) - 1);
      }},
      get_indices_0: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_tkvw3h$: function ($receiver) {
        return !$receiver.isEmpty();
      },
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_tkvw3h$($receiver);
      }},
      orEmpty_tkvw3h$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyList();
      },
      orEmpty_mtvwn1$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyList();
      },
      get_first: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size_1($receiver);
        return s > 0 ? $receiver.get_za3lpa$(s - 1) : null;
      }},
      get_lastIndex_8: {value: function ($receiver) {
        return _.kotlin.get_size_1($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_tkvw3h$($receiver) ? $receiver.get_za3lpa$(0) : null;
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop_odt3s5$($receiver, 1);
      }},
      addAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.addAll_xeylzf$(iterable);
          else {
            var tmp$0 = iterable.iterator();
            while (tmp$0.hasNext()) {
              var item = tmp$0.next();
              $receiver.add_za3rmp$(item);
            }
          }
        }
      },
      addAll_ngcqne$: function ($receiver, stream) {
        {
          var tmp$0 = stream.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            $receiver.add_za3rmp$(item);
          }
        }
      },
      addAll_jl7u2r$: function ($receiver, array) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = array, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.add_za3rmp$(item);
          }
        }
      },
      removeAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.removeAll_xeylzf$(iterable);
          else {
            var tmp$0 = iterable.iterator();
            while (tmp$0.hasNext()) {
              var item = tmp$0.next();
              $receiver.remove_za3rmp$(item);
            }
          }
        }
      },
      removeAll_ngcqne$: function ($receiver, stream) {
        {
          var tmp$0 = stream.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            $receiver.remove_za3rmp$(item);
          }
        }
      },
      removeAll_jl7u2r$: function ($receiver, array) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = array, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.remove_za3rmp$(item);
          }
        }
      },
      retainAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.retainAll_xeylzf$(iterable);
          else
            $receiver.retainAll_xeylzf$(_.kotlin.toSet_h3panj$(iterable));
        }
      },
      retainAll_jl7u2r$: function ($receiver, array) {
        $receiver.retainAll_xeylzf$(_.kotlin.toSet_2hx8bi$(array));
      },
      drop_fdw77o$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_rz0vgy$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_ucmip8$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_cwi0e2$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_3qx2rv$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_2e964m$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_tb5gmf$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_x09c4g$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_7naycm$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_odt3s5$: function ($receiver, n) {
        if (n >= _.kotlin.get_size_1($receiver))
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList(_.kotlin.get_size_1($receiver) - n);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_eq3vf5$: function ($receiver, n) {
        var count = 0;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_9ip83h$f: function (count, n) {
        return function (it) {
          return count.v++ >= n;
        };
      },
      drop_9ip83h$: function ($receiver, n) {
        var count = {v: 0};
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.drop_9ip83h$f(count, n));
      },
      drop_n7iutu$: function ($receiver, n) {
        return $receiver.substring(Math.min(n, _.kotlin.get_size_0($receiver)));
      },
      dropWhile_de9h66$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_50zxbw$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_x245au$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_h5ed0c$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_24jijj$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_im8pe8$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_1xntkt$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_3cuuyy$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_p67zio$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_vqr6wr$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_9fpnal$f: function (yielding, predicate) {
        return function (it) {
          if (yielding.v)
            return true;
          else if (!predicate(it)) {
            yielding.v = true;
            return true;
          }
           else
            return false;
        };
      },
      dropWhile_9fpnal$: function ($receiver, predicate) {
        var yielding = {v: false};
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.dropWhile_9fpnal$f(yielding, predicate));
      },
      dropWhile_t73kuc$: function ($receiver, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++)
            if (!predicate($receiver.charAt(index))) {
              return $receiver.substring(index);
            }
        }
        return '';
      },
      filter_de9h66$: function ($receiver, predicate) {
        return _.kotlin.filterTo_1jm7xb$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_50zxbw$: function ($receiver, predicate) {
        return _.kotlin.filterTo_uoz9bj$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_x245au$: function ($receiver, predicate) {
        return _.kotlin.filterTo_o451x3$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_h5ed0c$: function ($receiver, predicate) {
        return _.kotlin.filterTo_xryfpz$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_24jijj$: function ($receiver, predicate) {
        return _.kotlin.filterTo_6s9ff2$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_im8pe8$: function ($receiver, predicate) {
        return _.kotlin.filterTo_lbhsbh$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_1xntkt$: function ($receiver, predicate) {
        return _.kotlin.filterTo_4m2m1i$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_3cuuyy$: function ($receiver, predicate) {
        return _.kotlin.filterTo_ru2r$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_p67zio$: function ($receiver, predicate) {
        return _.kotlin.filterTo_wion7n$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_vqr6wr$: function ($receiver, predicate) {
        return _.kotlin.filterTo_ywx4y6$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_gld13f$: function ($receiver, predicate) {
        return _.kotlin.filterTo_inv7mm$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.FilteringStream($receiver, true, predicate);
      },
      filter_t73kuc$: function ($receiver, predicate) {
        return _.kotlin.filterTo_2ngy80$($receiver, new Kotlin.StringBuilder(), predicate).toString();
      },
      filterNot_de9h66$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1jm7xb$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_50zxbw$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_uoz9bj$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_x245au$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_o451x3$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_h5ed0c$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_xryfpz$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_24jijj$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6s9ff2$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_im8pe8$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_lbhsbh$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_1xntkt$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4m2m1i$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_3cuuyy$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_ru2r$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_p67zio$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_wion7n$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_vqr6wr$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_ywx4y6$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_gld13f$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_inv7mm$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.FilteringStream($receiver, false, predicate);
      },
      filterNot_t73kuc$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2ngy80$($receiver, new Kotlin.StringBuilder(), predicate).toString();
      },
      filterNotNull_2hx8bi$: function ($receiver) {
        return _.kotlin.filterNotNullTo_xpmo5j$($receiver, new Kotlin.ArrayList());
      },
      filterNotNull_h3panj$: function ($receiver) {
        return _.kotlin.filterNotNullTo_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      filterNotNull_pdnvbz$f: function (it) {
        return it == null;
      },
      filterNotNull_pdnvbz$: function ($receiver) {
        return new _.kotlin.FilteringStream($receiver, false, _.kotlin.filterNotNull_pdnvbz$f);
      },
      filterNotNullTo_xpmo5j$: function ($receiver, destination) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotNullTo_4jj70a$: function ($receiver, destination) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotNullTo_791eew$: function ($receiver, destination) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_1jm7xb$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_uoz9bj$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_o451x3$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_xryfpz$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_6s9ff2$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_lbhsbh$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_4m2m1i$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ru2r$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_wion7n$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ywx4y6$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_inv7mm$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ggat1c$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_2ngy80$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.append(element);
          }
        }
        return destination;
      },
      filterTo_1jm7xb$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_uoz9bj$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_o451x3$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_xryfpz$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_6s9ff2$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_lbhsbh$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_4m2m1i$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ru2r$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_wion7n$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ywx4y6$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_inv7mm$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ggat1c$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_2ngy80$: function ($receiver, destination, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++) {
            var element = $receiver.charAt(index);
            if (predicate(element))
              destination.append(element);
          }
        }
        return destination;
      },
      slice_qxrbi5$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_34aosx$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_dto1g5$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_ldb6x3$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_5ya7ho$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_t349z9$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_3cdrzs$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_cc6qan$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_w98n8l$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_h9kosk$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver.get_za3lpa$(index));
          }
        }
        return list;
      },
      slice_n9t38v$: function ($receiver, indices) {
        var result = new Kotlin.StringBuilder();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var i = tmp$0.next();
            result.append($receiver.charAt(i));
          }
        }
        return result.toString();
      },
      take_fdw77o$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_rz0vgy$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_ucmip8$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_cwi0e2$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_3qx2rv$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_2e964m$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_tb5gmf$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_x09c4g$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_7naycm$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_odt3s5$: function ($receiver, n) {
        var count = 0;
        var realN = n > _.kotlin.get_size_1($receiver) ? _.kotlin.get_size_1($receiver) : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_eq3vf5$: function ($receiver, n) {
        var count = 0;
        var list = new Kotlin.ArrayList(n);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === n)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_9ip83h$f: function (count, n) {
        return function (it) {
          return count.v++ === n;
        };
      },
      take_9ip83h$: function ($receiver, n) {
        var count = {v: 0};
        return new _.kotlin.LimitedStream($receiver, void 0, _.kotlin.take_9ip83h$f(count, n));
      },
      take_n7iutu$: function ($receiver, n) {
        return $receiver.substring(0, Math.min(n, _.kotlin.get_size_0($receiver)));
      },
      takeWhile_de9h66$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_50zxbw$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_x245au$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_h5ed0c$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_24jijj$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_im8pe8$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_1xntkt$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_3cuuyy$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_p67zio$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_vqr6wr$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.LimitedStream($receiver, false, predicate);
      },
      takeWhile_t73kuc$: function ($receiver, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++)
            if (!predicate($receiver.charAt(index))) {
              return $receiver.substring(0, index);
            }
        }
        return $receiver;
      },
      stream_2hx8bi$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_l1lu5s$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_964n92$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_355nu0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_bvy38t$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_rjqrz0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_tmsbgp$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_se6h4y$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_i2lc78$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_h3panj$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return $receiver.iterator();
          }
        });
      },
      stream_pdnvbz$: function ($receiver) {
        return $receiver;
      },
      stream_pdl1w0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return _.kotlin.iterator_gw00vq$($receiver);
          }
        });
      },
      requireNoNulls_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_mtvwn1$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_pdnvbz$f: function (this$requireNoNulls) {
        return function (it) {
          if (it == null) {
            throw new Kotlin.IllegalArgumentException('null element found in ' + this$requireNoNulls);
          }
          return true;
        };
      },
      requireNoNulls_pdnvbz$: function ($receiver) {
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.requireNoNulls_pdnvbz$f($receiver));
      },
      flatMap_de9h66$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_50zxbw$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_x245au$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_o451x3$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_h5ed0c$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_xryfpz$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_24jijj$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_im8pe8$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_1xntkt$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_3cuuyy$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_ru2r$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_p67zio$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_wion7n$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_gld13f$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_inv7mm$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_t73kuc$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_caazm9$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.FlatteningStream($receiver, transform);
      },
      flatMapTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_uoz9bj$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_o451x3$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_xryfpz$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_6s9ff2$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_lbhsbh$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_4m2m1i$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ru2r$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_wion7n$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_inv7mm$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_caazm9$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_ngcqne$(destination, list);
          }
        }
        return destination;
      },
      groupBy_de9h66$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_dmnozt$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_50zxbw$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7i5ojf$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_x245au$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_du5x9d$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_h5ed0c$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4mj9lf$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_24jijj$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_yr676w$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_im8pe8$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_fktjsp$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_1xntkt$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8qaat0$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_3cuuyy$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_rnq9xv$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_p67zio$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_yb8vhj$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_vqr6wr$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_cyhgqk$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_gld13f$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_9fpnal$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_fsw8ae$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_t73kuc$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_16syit$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupByTo_dmnozt$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_dmnozt$: function ($receiver, map, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_dmnozt$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_7i5ojf$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_7i5ojf$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_7i5ojf$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_du5x9d$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_du5x9d$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_du5x9d$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_4mj9lf$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_4mj9lf$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_4mj9lf$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_yr676w$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_yr676w$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_yr676w$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_fktjsp$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_fktjsp$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_fktjsp$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_8qaat0$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_8qaat0$: function ($receiver, map, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_8qaat0$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_rnq9xv$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_rnq9xv$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_rnq9xv$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_yb8vhj$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_yb8vhj$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_yb8vhj$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_cyhgqk$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_cyhgqk$: function ($receiver, map, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_cyhgqk$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_7qivbo$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_7qivbo$: function ($receiver, map, toKey) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_7qivbo$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_fsw8ae$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_fsw8ae$: function ($receiver, map, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_fsw8ae$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_16syit$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_16syit$: function ($receiver, map, toKey) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_16syit$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      map_de9h66$: function ($receiver, transform) {
        return _.kotlin.mapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_50zxbw$: function ($receiver, transform) {
        return _.kotlin.mapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_x245au$: function ($receiver, transform) {
        return _.kotlin.mapTo_o451x3$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_h5ed0c$: function ($receiver, transform) {
        return _.kotlin.mapTo_xryfpz$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_24jijj$: function ($receiver, transform) {
        return _.kotlin.mapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_im8pe8$: function ($receiver, transform) {
        return _.kotlin.mapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_1xntkt$: function ($receiver, transform) {
        return _.kotlin.mapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_3cuuyy$: function ($receiver, transform) {
        return _.kotlin.mapTo_ru2r$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_p67zio$: function ($receiver, transform) {
        return _.kotlin.mapTo_wion7n$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.mapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_gld13f$: function ($receiver, transform) {
        return _.kotlin.mapTo_inv7mm$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.TransformingStream($receiver, transform);
      },
      map_t73kuc$: function ($receiver, transform) {
        return _.kotlin.mapTo_caazm9$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_de9h66$: function ($receiver, transform) {
        return _.kotlin.mapNotNullTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.mapNotNullTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_9fpnal$f: function (it) {
        return it == null;
      },
      mapNotNull_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.TransformingStream(new _.kotlin.FilteringStream($receiver, false, _.kotlin.mapNotNull_9fpnal$f), transform);
      },
      mapNotNullTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapNotNullTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapNotNullTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_uoz9bj$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_o451x3$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_xryfpz$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_6s9ff2$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_lbhsbh$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_4m2m1i$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ru2r$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_wion7n$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_inv7mm$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_caazm9$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      withIndices_2hx8bi$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_2hx8bi$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_2hx8bi$f(index));
      },
      withIndices_l1lu5s$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_l1lu5s$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_l1lu5s$f(index));
      },
      withIndices_964n92$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_964n92$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_o451x3$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_964n92$f(index));
      },
      withIndices_355nu0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_355nu0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_xryfpz$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_355nu0$f(index));
      },
      withIndices_bvy38t$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_bvy38t$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_bvy38t$f(index));
      },
      withIndices_rjqrz0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_rjqrz0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_rjqrz0$f(index));
      },
      withIndices_tmsbgp$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_tmsbgp$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_tmsbgp$f(index));
      },
      withIndices_se6h4y$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_se6h4y$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_ru2r$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_se6h4y$f(index));
      },
      withIndices_i2lc78$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_i2lc78$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_wion7n$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_i2lc78$f(index));
      },
      withIndices_h3panj$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_h3panj$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_h3panj$f(index));
      },
      withIndices_pdnvbz$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_pdnvbz$: function ($receiver) {
        var index = {v: 0};
        return new _.kotlin.TransformingStream($receiver, _.kotlin.withIndices_pdnvbz$f(index));
      },
      withIndices_pdl1w0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_pdl1w0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_caazm9$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_pdl1w0$f(index));
      },
      distinct_2hx8bi$: function ($receiver) {
        return _.kotlin.toMutableSet_2hx8bi$($receiver);
      },
      distinct_l1lu5s$: function ($receiver) {
        return _.kotlin.toMutableSet_l1lu5s$($receiver);
      },
      distinct_964n92$: function ($receiver) {
        return _.kotlin.toMutableSet_964n92$($receiver);
      },
      distinct_355nu0$: function ($receiver) {
        return _.kotlin.toMutableSet_355nu0$($receiver);
      },
      distinct_bvy38t$: function ($receiver) {
        return _.kotlin.toMutableSet_bvy38t$($receiver);
      },
      distinct_rjqrz0$: function ($receiver) {
        return _.kotlin.toMutableSet_rjqrz0$($receiver);
      },
      distinct_tmsbgp$: function ($receiver) {
        return _.kotlin.toMutableSet_tmsbgp$($receiver);
      },
      distinct_se6h4y$: function ($receiver) {
        return _.kotlin.toMutableSet_se6h4y$($receiver);
      },
      distinct_i2lc78$: function ($receiver) {
        return _.kotlin.toMutableSet_i2lc78$($receiver);
      },
      distinct_h3panj$: function ($receiver) {
        return _.kotlin.toMutableSet_h3panj$($receiver);
      },
      intersect_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      subtract_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      toMutableSet_2hx8bi$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_l1lu5s$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_964n92$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_355nu0$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_bvy38t$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_rjqrz0$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_tmsbgp$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_se6h4y$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_i2lc78$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_h3panj$: function ($receiver) {
        var tmp$0;
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          tmp$0 = _.java.util.LinkedHashSet_xeylzf$($receiver);
        else
          tmp$0 = _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedHashSet());
        return tmp$0;
      },
      union_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      f: function (this$toGenerator, nextValue) {
        return function (result) {
          nextValue.v = this$toGenerator(result);
          return result;
        };
      },
      toGenerator_n1mtj3$f: function (nextValue, this$toGenerator) {
        return function () {
          var tmp$0;
          return (tmp$0 = nextValue.v) != null ? _.kotlin.let_j58jph$(tmp$0, _.kotlin.f(this$toGenerator, nextValue)) : null;
        };
      },
      toGenerator_n1mtj3$: function ($receiver, initialValue) {
        var nextValue = {v: initialValue};
        return _.kotlin.toGenerator_n1mtj3$f(nextValue, $receiver);
      },
      to_l1ob02$: function ($receiver, that) {
        return new _.kotlin.Pair($receiver, that);
      },
      run_n8bj3p$: function (f) {
        return f();
      },
      with_rc1ekn$: function (receiver, f) {
        return f.call(receiver);
      },
      let_j58jph$: function ($receiver, f) {
        return f($receiver);
      },
      downTo_9q324c$: function ($receiver, to) {
        return new _.kotlin.ByteProgression($receiver, to, -1);
      },
      downTo_9q3c22$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver.toChar(), to, -1);
      },
      downTo_hl85u0$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_y20kcl$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_9q98fk$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_he5dns$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_tylosb$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_sd8xje$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver, to.toChar(), -1);
      },
      downTo_sd97h4$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver, to, -1);
      },
      downTo_radrzu$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver.toShort(), to, -1);
      },
      downTo_v5vllf$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver.toInt(), to, -1);
      },
      downTo_sdf3um$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_r3aztm$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_df7tnx$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_9r634a$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_9r5t6k$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to.toShort(), -1);
      },
      downTo_i0qws2$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_rt69vj$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_9qzwt2$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_i7toya$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_2lzxtr$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_2jcion$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_2jc8qx$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to.toInt(), -1);
      },
      downTo_7dmh8l$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_rksjo2$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_2j6cdf$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_7kp9et$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_mmqya6$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_jzdo0$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_jznlq$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_hgibo4$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_mw85q1$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_k5jz8$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to, -(1).toLong());
      },
      downTo_h9fjhw$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_y0unuv$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_kquaae$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_kquk84$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_433x66$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_jyaijj$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_kr0glm$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_3w14zy$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_mdktgh$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_stl18b$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_stkral$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_u6e7j3$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_aiyy8i$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_steux3$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_tzbfcv$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_541hxq$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      merge_91t4nf$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_zb2wxp$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_au6o65$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_resd0r$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_6lndoa$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_g5oapj$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_f32dm2$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_oi38kv$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_pn4jvt$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_tl80ny$: function ($receiver, array, transform) {
        var first = $receiver.iterator();
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_29xg59$: function ($receiver, array, transform) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_7bg1pg$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_vzyamu$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_r76i9w$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_d5bgvi$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_d6i5gz$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_y6emce$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_k6l5td$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_ksuah4$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_eqb4ua$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_hqmbqh$: function ($receiver, other, transform) {
        var first = $receiver.iterator();
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_q03f9y$: function ($receiver, other, transform) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_28jw99$: function ($receiver, stream, transform) {
        return new _.kotlin.MergingStream($receiver, stream, transform);
      },
      partition_de9h66$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_50zxbw$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_x245au$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_h5ed0c$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_24jijj$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_im8pe8$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_1xntkt$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_3cuuyy$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_p67zio$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_vqr6wr$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_9fpnal$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_t73kuc$: function ($receiver, predicate) {
        var first = new Kotlin.StringBuilder();
        var second = new Kotlin.StringBuilder();
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.append(element);
            }
             else {
              second.append(element);
            }
          }
        }
        return new _.kotlin.Pair(first.toString(), second.toString());
      },
      plus_bctcxa$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_w5fksc$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_qsh4fe$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_uy8ycc$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_kvfz4v$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_tev20g$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_wgl9xf$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_v0fo6u$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_wshjbk$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_fnn263$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_qxrbi5$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_34aosx$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_dto1g5$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_ldb6x3$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_5ya7ho$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_t349z9$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_3cdrzs$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_cc6qan$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_w98n8l$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_975xw0$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_1lsq3i$: function ($receiver, collection) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, _.kotlin.stream_h3panj$(collection)]));
      },
      plus_fdw1a9$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_bsmqrv$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_hgt5d7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_q79yhh$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_96a6a3$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_thi4tv$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_tb5gmf$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_ssilt7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_x27eb7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_eq3phq$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_9ipe0w$: function ($receiver, element) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, _.kotlin.streamOf_mzrxf8$([element])]));
      },
      plus_y4w53o$: function ($receiver, stream) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, stream]));
      },
      zip_bctcxa$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_bctcxa$: function ($receiver, array) {
        return _.kotlin.merge_91t4nf$($receiver, array, _.kotlin.zip_bctcxa$f);
      },
      zip_w5fksc$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_w5fksc$: function ($receiver, array) {
        return _.kotlin.merge_zb2wxp$($receiver, array, _.kotlin.zip_w5fksc$f);
      },
      zip_qsh4fe$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_qsh4fe$: function ($receiver, array) {
        return _.kotlin.merge_au6o65$($receiver, array, _.kotlin.zip_qsh4fe$f);
      },
      zip_uy8ycc$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_uy8ycc$: function ($receiver, array) {
        return _.kotlin.merge_resd0r$($receiver, array, _.kotlin.zip_uy8ycc$f);
      },
      zip_kvfz4v$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_kvfz4v$: function ($receiver, array) {
        return _.kotlin.merge_6lndoa$($receiver, array, _.kotlin.zip_kvfz4v$f);
      },
      zip_tev20g$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_tev20g$: function ($receiver, array) {
        return _.kotlin.merge_g5oapj$($receiver, array, _.kotlin.zip_tev20g$f);
      },
      zip_wgl9xf$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_wgl9xf$: function ($receiver, array) {
        return _.kotlin.merge_f32dm2$($receiver, array, _.kotlin.zip_wgl9xf$f);
      },
      zip_v0fo6u$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_v0fo6u$: function ($receiver, array) {
        return _.kotlin.merge_oi38kv$($receiver, array, _.kotlin.zip_v0fo6u$f);
      },
      zip_wshjbk$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_wshjbk$: function ($receiver, array) {
        return _.kotlin.merge_pn4jvt$($receiver, array, _.kotlin.zip_wshjbk$f);
      },
      zip_fnn263$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_fnn263$: function ($receiver, array) {
        return _.kotlin.merge_tl80ny$($receiver, array, _.kotlin.zip_fnn263$f);
      },
      zip_ny9o$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_ny9o$: function ($receiver, array) {
        return _.kotlin.merge_29xg59$($receiver, array, _.kotlin.zip_ny9o$f);
      },
      zip_qxrbi5$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_qxrbi5$: function ($receiver, other) {
        return _.kotlin.merge_7bg1pg$($receiver, other, _.kotlin.zip_qxrbi5$f);
      },
      zip_34aosx$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_34aosx$: function ($receiver, other) {
        return _.kotlin.merge_vzyamu$($receiver, other, _.kotlin.zip_34aosx$f);
      },
      zip_dto1g5$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_dto1g5$: function ($receiver, other) {
        return _.kotlin.merge_r76i9w$($receiver, other, _.kotlin.zip_dto1g5$f);
      },
      zip_ldb6x3$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_ldb6x3$: function ($receiver, other) {
        return _.kotlin.merge_d5bgvi$($receiver, other, _.kotlin.zip_ldb6x3$f);
      },
      zip_5ya7ho$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_5ya7ho$: function ($receiver, other) {
        return _.kotlin.merge_d6i5gz$($receiver, other, _.kotlin.zip_5ya7ho$f);
      },
      zip_t349z9$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_t349z9$: function ($receiver, other) {
        return _.kotlin.merge_y6emce$($receiver, other, _.kotlin.zip_t349z9$f);
      },
      zip_3cdrzs$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_3cdrzs$: function ($receiver, other) {
        return _.kotlin.merge_k6l5td$($receiver, other, _.kotlin.zip_3cdrzs$f);
      },
      zip_cc6qan$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_cc6qan$: function ($receiver, other) {
        return _.kotlin.merge_ksuah4$($receiver, other, _.kotlin.zip_cc6qan$f);
      },
      zip_w98n8l$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_w98n8l$: function ($receiver, other) {
        return _.kotlin.merge_eqb4ua$($receiver, other, _.kotlin.zip_w98n8l$f);
      },
      zip_975xw0$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_975xw0$: function ($receiver, other) {
        return _.kotlin.merge_hqmbqh$($receiver, other, _.kotlin.zip_975xw0$f);
      },
      zip_n9t38v$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_n9t38v$: function ($receiver, other) {
        return _.kotlin.merge_q03f9y$($receiver, other, _.kotlin.zip_n9t38v$f);
      },
      zip_94jgcu$: function ($receiver, other) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = _.kotlin.iterator_gw00vq$(other);
        var list = new Kotlin.ArrayList();
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(_.kotlin.to_l1ob02$(first.next(), second.next()));
        }
        return list;
      },
      zip_y4w53o$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_y4w53o$: function ($receiver, stream) {
        return new _.kotlin.MergingStream($receiver, stream, _.kotlin.zip_y4w53o$f);
      },
      contains_fdw1a9$: function ($receiver, element) {
        return _.kotlin.indexOf_fdw1a9$($receiver, element) >= 0;
      },
      contains_bsmqrv$: function ($receiver, element) {
        return _.kotlin.indexOf_bsmqrv$($receiver, element) >= 0;
      },
      contains_hgt5d7$: function ($receiver, element) {
        return _.kotlin.indexOf_hgt5d7$($receiver, element) >= 0;
      },
      contains_q79yhh$: function ($receiver, element) {
        return _.kotlin.indexOf_q79yhh$($receiver, element) >= 0;
      },
      contains_96a6a3$: function ($receiver, element) {
        return _.kotlin.indexOf_96a6a3$($receiver, element) >= 0;
      },
      contains_thi4tv$: function ($receiver, element) {
        return _.kotlin.indexOf_thi4tv$($receiver, element) >= 0;
      },
      contains_tb5gmf$: function ($receiver, element) {
        return _.kotlin.indexOf_tb5gmf$($receiver, element) >= 0;
      },
      contains_ssilt7$: function ($receiver, element) {
        return _.kotlin.indexOf_ssilt7$($receiver, element) >= 0;
      },
      contains_x27eb7$: function ($receiver, element) {
        return _.kotlin.indexOf_x27eb7$($receiver, element) >= 0;
      },
      contains_eq3phq$: function ($receiver, element) {
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          return $receiver.contains_za3rmp$(element);
        return _.kotlin.indexOf_eq3phq$($receiver, element) >= 0;
      },
      contains_9ipe0w$: function ($receiver, element) {
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          return $receiver.contains_za3rmp$(element);
        return _.kotlin.indexOf_9ipe0w$($receiver, element) >= 0;
      },
      elementAt_fdw77o$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_rz0vgy$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_ucmip8$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_cwi0e2$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_3qx2rv$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_2e964m$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_tb5gmf$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_x09c4g$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_7naycm$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_eq3vf5$: function ($receiver, index) {
        if (Kotlin.isType($receiver, _.kotlin.List))
          return $receiver.get_za3lpa$(index);
        var iterator = $receiver.iterator();
        var count = 0;
        while (iterator.hasNext()) {
          var element = iterator.next();
          if (index === count++)
            return element;
        }
        throw new RangeError("Collection doesn't contain element at index");
      },
      elementAt_ureun9$: function ($receiver, index) {
        return $receiver.get_za3lpa$(index);
      },
      elementAt_9ip83h$: function ($receiver, index) {
        var iterator = $receiver.iterator();
        var count = 0;
        while (iterator.hasNext()) {
          var element = iterator.next();
          if (index === count++)
            return element;
        }
        throw new RangeError("Collection doesn't contain element at index");
      },
      elementAt_n7iutu$: function ($receiver, index) {
        return $receiver.charAt(index);
      },
      first_2hx8bi$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_l1lu5s$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_964n92$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_355nu0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_bvy38t$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_rjqrz0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_tmsbgp$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_se6h4y$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_i2lc78$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            return iterator.next();
          }
        }
      },
      first_mtvwn1$: function ($receiver) {
        if (_.kotlin.get_size_1($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.get_za3lpa$(0);
      },
      first_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            return iterator.next();
          }
        }
      },
      first_pdl1w0$: function ($receiver) {
        if (_.kotlin.get_size_0($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.charAt(0);
      },
      first_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      firstOrNull_2hx8bi$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_l1lu5s$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_964n92$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_355nu0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_bvy38t$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_rjqrz0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_tmsbgp$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_se6h4y$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_i2lc78$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              return null;
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            return iterator.next();
          }
        }
      },
      firstOrNull_mtvwn1$: function ($receiver) {
        return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(0) : null;
      },
      firstOrNull_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              return null;
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            return iterator.next();
          }
        }
      },
      firstOrNull_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver) > 0 ? $receiver.charAt(0) : null;
      },
      firstOrNull_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      indexOf_fdw1a9$: function ($receiver, element) {
        if (element == null) {
          var tmp$0, tmp$1, tmp$2, tmp$3;
          {
            tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
            for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
              if ($receiver[index] == null) {
                return index;
              }
            }
          }
        }
         else {
          var tmp$4, tmp$5, tmp$6, tmp$7;
          {
            tmp$4 = Kotlin.arrayIndices($receiver), tmp$5 = tmp$4.start, tmp$6 = tmp$4.end, tmp$7 = tmp$4.increment;
            for (var index_0 = tmp$5; index_0 <= tmp$6; index_0 += tmp$7) {
              if (Kotlin.equals(element, $receiver[index_0])) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      indexOf_bsmqrv$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (Kotlin.equals(element, $receiver[index])) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_hgt5d7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_q79yhh$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_96a6a3$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_thi4tv$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_tb5gmf$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_ssilt7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_x27eb7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_eq3phq$: function ($receiver, element) {
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              return index;
            index++;
          }
        }
        return -1;
      },
      indexOf_9ipe0w$: function ($receiver, element) {
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              return index;
            index++;
          }
        }
        return -1;
      },
      last_2hx8bi$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_l1lu5s$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_964n92$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_355nu0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_bvy38t$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_rjqrz0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_tmsbgp$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_se6h4y$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_i2lc78$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      last_mtvwn1$: function ($receiver) {
        if (_.kotlin.get_size_1($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
      },
      last_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      last_pdl1w0$: function ($receiver) {
        if (_.kotlin.get_size_0($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.charAt(_.kotlin.get_size_0($receiver) - 1);
      },
      last_de9h66$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_50zxbw$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_x245au$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_h5ed0c$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_24jijj$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_im8pe8$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_1xntkt$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_3cuuyy$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_p67zio$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_vqr6wr$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_9fpnal$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_t73kuc$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      lastIndexOf_fdw1a9$: function ($receiver, element) {
        if (element == null) {
          {
            var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
            while (tmp$0.hasNext()) {
              var index = tmp$0.next();
              if ($receiver[index] == null) {
                return index;
              }
            }
          }
        }
         else {
          {
            var tmp$1 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
            while (tmp$1.hasNext()) {
              var index_0 = tmp$1.next();
              if (Kotlin.equals(element, $receiver[index_0])) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      lastIndexOf_bsmqrv$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (Kotlin.equals(element, $receiver[index])) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_hgt5d7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_q79yhh$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_96a6a3$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_thi4tv$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_tb5gmf$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_ssilt7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_x27eb7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_eq3phq$: function ($receiver, element) {
        var lastIndex = -1;
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              lastIndex = index;
            index++;
          }
        }
        return lastIndex;
      },
      lastIndexOf_ureopu$: function ($receiver, element) {
        if (element == null) {
          {
            var tmp$0 = _.kotlin.reverse_h3panj$(_.kotlin.get_indices($receiver)).iterator();
            while (tmp$0.hasNext()) {
              var index = tmp$0.next();
              if ($receiver.get_za3lpa$(index) == null) {
                return index;
              }
            }
          }
        }
         else {
          {
            var tmp$1 = _.kotlin.reverse_h3panj$(_.kotlin.get_indices($receiver)).iterator();
            while (tmp$1.hasNext()) {
              var index_0 = tmp$1.next();
              if (Kotlin.equals(element, $receiver.get_za3lpa$(index_0))) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      lastIndexOf_9ipe0w$: function ($receiver, element) {
        var lastIndex = -1;
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              lastIndex = index;
            index++;
          }
        }
        return lastIndex;
      },
      lastOrNull_2hx8bi$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_l1lu5s$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_964n92$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_355nu0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_bvy38t$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_rjqrz0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_tmsbgp$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_se6h4y$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_i2lc78$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      lastOrNull_mtvwn1$: function ($receiver) {
        return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
      },
      lastOrNull_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      lastOrNull_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver) > 0 ? $receiver.charAt(_.kotlin.get_size_0($receiver) - 1) : null;
      },
      lastOrNull_de9h66$: function ($receiver, predicate) {
        var last = null;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_50zxbw$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_x245au$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_h5ed0c$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_24jijj$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_im8pe8$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_1xntkt$: function ($receiver, predicate) {
        var last = null;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_3cuuyy$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_p67zio$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_vqr6wr$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_9fpnal$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_t73kuc$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      single_2hx8bi$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_l1lu5s$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_964n92$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_355nu0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_bvy38t$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_rjqrz0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_tmsbgp$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_se6h4y$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_i2lc78$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_h3panj$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      single_mtvwn1$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_pdnvbz$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      single_pdl1w0$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_0($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.charAt(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_de9h66$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_50zxbw$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_x245au$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_h5ed0c$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_24jijj$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_im8pe8$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_1xntkt$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_3cuuyy$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_p67zio$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_vqr6wr$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_9fpnal$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_t73kuc$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      singleOrNull_2hx8bi$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_l1lu5s$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_964n92$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_355nu0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_bvy38t$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_rjqrz0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_tmsbgp$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_se6h4y$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_i2lc78$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_h3panj$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          tmp$1 = null;
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      singleOrNull_mtvwn1$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_pdnvbz$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          tmp$1 = null;
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      singleOrNull_pdl1w0$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_0($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.charAt(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_de9h66$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_50zxbw$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_x245au$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_h5ed0c$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_24jijj$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_im8pe8$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_1xntkt$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_3cuuyy$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_p67zio$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_vqr6wr$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_9fpnal$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_t73kuc$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      times_97ovpz$: function ($receiver, body) {
        var count = $receiver;
        while (count > 0) {
          body();
          count--;
        }
      },
      require_eltq40$: function (value, message) {
        if (message === void 0)
          message = 'Failed requirement';
        if (!value) {
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      require_zgzqbg$: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      requireNotNull_wn2jw4$: function (value, message) {
        if (message === void 0)
          message = 'Required value was null';
        if (value == null) {
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
         else {
          return value;
        }
      },
      check_eltq40$: function (value, message) {
        if (message === void 0)
          message = 'Check failed';
        if (!value) {
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      check_zgzqbg$: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      checkNotNull_hwpqgh$: function (value, message) {
        if (message === void 0)
          message = 'Required value was null';
        if (value == null) {
          throw new Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      },
      error_61zpoe$: function (message) {
        throw new Kotlin.RuntimeException(message);
      },
      toArrayList_2hx8bi$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_l1lu5s$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_964n92$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_355nu0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_bvy38t$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_rjqrz0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_tmsbgp$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_se6h4y$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_i2lc78$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      toArrayList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ArrayList());
      },
      toArrayList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.ArrayList());
      },
      toCollection_xpmo5j$: function ($receiver, collection) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_aaeveh$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_d1lgh$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_ba3pld$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_enu0mi$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_gk003p$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_mglpxq$: function ($receiver, collection) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_vus1ud$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_5k8uqj$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_4jj70a$: function ($receiver, collection) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_791eew$: function ($receiver, collection) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_j1020p$: function ($receiver, collection) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toHashSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toLinkedList_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.LinkedList());
      },
      toList_s8ckw1$: function ($receiver) {
        var result = new Kotlin.ArrayList(_.kotlin.get_size($receiver));
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add_za3rmp$(item);
          }
        }
        return result;
      },
      toList_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.ArrayList());
      },
      toList_l1lu5s$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_964n92$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_355nu0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_bvy38t$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_rjqrz0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_tmsbgp$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_se6h4y$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_i2lc78$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      toList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ArrayList());
      },
      toList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.ArrayList());
      },
      toSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.TreeSet());
      },
      appendString_vt6b28$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_vt6b28$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_v2fgr2$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_v2fgr2$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_ds6lso$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_ds6lso$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_2b34ga$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_2b34ga$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_kjxfqn$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_kjxfqn$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_bt92bi$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_bt92bi$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_xc3j4b$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_xc3j4b$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_2bqqsc$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_2bqqsc$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_ex638e$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_ex638e$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_4ybsr7$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_4ybsr7$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_tsa3bz$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_tsa3bz$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      joinTo_vt6b28$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_v2fgr2$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_ds6lso$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_2b34ga$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_kjxfqn$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_bt92bi$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_xc3j4b$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_2bqqsc$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_ex638e$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_4ybsr7$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_tsa3bz$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinToString_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_vt6b28$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_cmivou$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_v2fgr2$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_7gqm6g$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_ds6lso$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_5g9kba$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_2b34ga$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_fwx41b$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_kjxfqn$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_sfhf6m$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_bt92bi$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_6b4cej$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_xc3j4b$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_s6c98k$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_2bqqsc$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_pukide$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_ex638e$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_4ybsr7$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_tsa3bz$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      makeString_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7s66u8$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_cmivou$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_cmivou$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_7gqm6g$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7gqm6g$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_5g9kba$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_5g9kba$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_fwx41b$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_fwx41b$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_sfhf6m$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_sfhf6m$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_6b4cej$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_6b4cej$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_s6c98k$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_s6c98k$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_pukide$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_pukide$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_mc2pv1$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_tpghi9$($receiver, separator, prefix, postfix, limit, truncated);
      },
      trim_94jgcu$: function ($receiver, text) {
        return _.kotlin.trimTrailing_94jgcu$(_.kotlin.trimLeading_94jgcu$($receiver, text), text);
      },
      trim_ex0kps$: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing_94jgcu$(_.kotlin.trimLeading_94jgcu$($receiver, prefix), postfix);
      },
      trimLeading_94jgcu$: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      },
      trimTrailing_94jgcu$: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      },
      isNotEmpty_pdl1w0$: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      },
      iterator_gw00vq$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.CharIterator];
        }, function $fun() {
          $fun.baseInitializer.call(this);
          this.index_xuly00$ = 0;
        }, {
          nextChar: function () {
            return $receiver.get_za3lpa$(this.index_xuly00$++);
          },
          hasNext: function () {
            return this.index_xuly00$ < $receiver.length;
          }
        });
      },
      orEmpty_pdl1w0$: function ($receiver) {
        return $receiver != null ? $receiver : '';
      },
      get_size_2: {value: function ($receiver) {
        return $receiver.length;
      }},
      get_size_0: {value: function ($receiver) {
        return $receiver.length;
      }},
      get_indices_1: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver.length - 1);
      }},
      slice_bchp91$: function ($receiver, indices) {
        var sb = new Kotlin.StringBuilder();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var i = tmp$0.next();
            sb.append($receiver.get_za3lpa$(i));
          }
        }
        return sb.toString();
      },
      substring_cumll7$: function ($receiver, range) {
        return $receiver.substring(range.start, range.end + 1);
      },
      join_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_mc2pv1$($receiver, separator, prefix, postfix, limit, truncated);
      },
      join_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7s66u8$($receiver, separator, prefix, postfix, limit, truncated);
      },
      join_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_tpghi9$($receiver, separator, prefix, postfix, limit, truncated);
      },
      substringBefore_960177$: function ($receiver, delimiter) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringBefore_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringAfter_960177$: function ($receiver, delimiter) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? '' : $receiver.substring(index + 1, $receiver.length);
      },
      substringAfter_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? '' : $receiver.substring(index + delimiter.length, $receiver.length);
      },
      substringBeforeLast_960177$: function ($receiver, delimiter) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringBeforeLast_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringAfterLast_960177$: function ($receiver, delimiter) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? '' : $receiver.substring(index + 1, $receiver.length);
      },
      substringAfterLast_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? '' : $receiver.substring(index + delimiter.length, $receiver.length);
      },
      replaceRange_d9884y$: function ($receiver, firstIndex, lastIndex, replacement) {
        if (lastIndex < firstIndex)
          throw new RangeError('Last index (' + lastIndex + ') is less than first index (' + firstIndex + ')');
        var sb = new Kotlin.StringBuilder();
        sb.append($receiver, 0, firstIndex);
        sb.append(replacement);
        sb.append($receiver, lastIndex, $receiver.length);
        return sb.toString();
      },
      replaceRange_rxpzkz$: function ($receiver, range, replacement) {
        if (range.end < range.start)
          throw new RangeError('Last index (' + range.start + ') is less than first index (' + range.end + ')');
        var sb = new Kotlin.StringBuilder();
        sb.append($receiver, 0, range.start);
        sb.append(replacement);
        sb.append($receiver, range.end, $receiver.length);
        return sb.toString();
      },
      replaceBefore_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceBefore_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceAfter_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + 1, $receiver.length, replacement);
      },
      replaceAfter_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + delimiter.length, $receiver.length, replacement);
      },
      replaceAfterLast_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + delimiter.length, $receiver.length, replacement);
      },
      replaceAfterLast_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + 1, $receiver.length, replacement);
      },
      replaceBeforeLast_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceBeforeLast_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      StringBuilder_lxq41y$: function (body) {
        var sb = new Kotlin.StringBuilder();
        body.call(sb);
        return sb;
      },
      append_d4iu1a$: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      append_ya45mk$: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      append_ya45mk$_0: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      sum_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_0: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_1: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_2: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_tmsbgp$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_0: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_se6h4y$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_1: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_964n92$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_2: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_i2lc78$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_3: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_bvy38t$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_4: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_rjqrz0$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      reverse_2hx8bi$: function ($receiver) {
        var list = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_l1lu5s$: function ($receiver) {
        var list = _.kotlin.toArrayList_l1lu5s$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_964n92$: function ($receiver) {
        var list = _.kotlin.toArrayList_964n92$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_355nu0$: function ($receiver) {
        var list = _.kotlin.toArrayList_355nu0$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_bvy38t$: function ($receiver) {
        var list = _.kotlin.toArrayList_bvy38t$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_rjqrz0$: function ($receiver) {
        var list = _.kotlin.toArrayList_rjqrz0$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_tmsbgp$: function ($receiver) {
        var list = _.kotlin.toArrayList_tmsbgp$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_se6h4y$: function ($receiver) {
        var list = _.kotlin.toArrayList_se6h4y$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_i2lc78$: function ($receiver) {
        var list = _.kotlin.toArrayList_i2lc78$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_h3panj$: function ($receiver) {
        var list = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_pdl1w0$: function ($receiver) {
        return (new Kotlin.StringBuilder()).append($receiver).reverse().toString();
      },
      sort_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      sortBy_lykrt4$: function ($receiver, comparator) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.collectionsSort(sortedList, comparator);
        return sortedList;
      },
      sortBy_yknd17$: function ($receiver, comparator) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList, comparator);
        return sortedList;
      },
      sortBy_de9h66$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescending_h3panj$f: function (x, y) {
        return -x.compareTo_za3rmp$(y);
      },
      sortDescending_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescending_h3panj$f);
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescendingBy_de9h66$f: function (order) {
        return function (x, y) {
          return -order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortDescendingBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescendingBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescendingBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return -order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortDescendingBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescendingBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedList_2hx8bi$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_l1lu5s$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_l1lu5s$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_964n92$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_964n92$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_355nu0$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_355nu0$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_bvy38t$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_bvy38t$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_rjqrz0$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_rjqrz0$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_tmsbgp$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_tmsbgp$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_se6h4y$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_se6h4y$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_i2lc78$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_i2lc78$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_pdnvbz$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_pdnvbz$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedListBy_de9h66$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_50zxbw$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_50zxbw$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_l1lu5s$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_50zxbw$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_x245au$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_x245au$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_964n92$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_x245au$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_h5ed0c$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_h5ed0c$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_355nu0$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_h5ed0c$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_24jijj$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_24jijj$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_bvy38t$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_24jijj$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_im8pe8$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_im8pe8$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_rjqrz0$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_im8pe8$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_1xntkt$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_1xntkt$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_tmsbgp$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_1xntkt$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_3cuuyy$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_3cuuyy$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_se6h4y$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_3cuuyy$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_p67zio$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_p67zio$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_i2lc78$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_p67zio$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_9fpnal$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_9fpnal$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_pdnvbz$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_9fpnal$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      isEmpty_2hx8bi$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_l1lu5s$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_964n92$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_355nu0$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_bvy38t$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_rjqrz0$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_tmsbgp$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_se6h4y$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_i2lc78$: function ($receiver) {
        return $receiver.length === 0;
      },
      isNotEmpty_2hx8bi$: function ($receiver) {
        return !_.kotlin.isEmpty_2hx8bi$($receiver);
      },
      isNotEmpty_l1lu5s$: function ($receiver) {
        return !_.kotlin.isEmpty_l1lu5s$($receiver);
      },
      isNotEmpty_964n92$: function ($receiver) {
        return !_.kotlin.isEmpty_964n92$($receiver);
      },
      isNotEmpty_355nu0$: function ($receiver) {
        return !_.kotlin.isEmpty_355nu0$($receiver);
      },
      isNotEmpty_bvy38t$: function ($receiver) {
        return !_.kotlin.isEmpty_bvy38t$($receiver);
      },
      isNotEmpty_rjqrz0$: function ($receiver) {
        return !_.kotlin.isEmpty_rjqrz0$($receiver);
      },
      isNotEmpty_tmsbgp$: function ($receiver) {
        return !_.kotlin.isEmpty_tmsbgp$($receiver);
      },
      isNotEmpty_se6h4y$: function ($receiver) {
        return !_.kotlin.isEmpty_se6h4y$($receiver);
      },
      isNotEmpty_i2lc78$: function ($receiver) {
        return !_.kotlin.isEmpty_i2lc78$($receiver);
      },
      all_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return true;
          }
        }
        return false;
      },
      any_l1lu5s$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_964n92$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_355nu0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_bvy38t$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_rjqrz0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_tmsbgp$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return true;
          }
        }
        return false;
      },
      any_se6h4y$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_i2lc78$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_s8ckw1$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_pdnvbz$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_pdl1w0$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_2hx8bi$: function ($receiver) {
        return $receiver.length;
      },
      count_l1lu5s$: function ($receiver) {
        return $receiver.length;
      },
      count_964n92$: function ($receiver) {
        return $receiver.length;
      },
      count_355nu0$: function ($receiver) {
        return $receiver.length;
      },
      count_bvy38t$: function ($receiver) {
        return $receiver.length;
      },
      count_rjqrz0$: function ($receiver) {
        return $receiver.length;
      },
      count_tmsbgp$: function ($receiver) {
        return $receiver.length;
      },
      count_se6h4y$: function ($receiver) {
        return $receiver.length;
      },
      count_i2lc78$: function ($receiver) {
        return $receiver.length;
      },
      count_tkvw3h$: function ($receiver) {
        return _.kotlin.get_size_1($receiver);
      },
      count_h3panj$: function ($receiver) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            count++;
          }
        }
        return count;
      },
      count_s8ckw1$: function ($receiver) {
        return _.kotlin.get_size($receiver);
      },
      count_pdnvbz$: function ($receiver) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            count++;
          }
        }
        return count;
      },
      count_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver);
      },
      count_de9h66$: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_50zxbw$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_x245au$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_h5ed0c$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_24jijj$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_im8pe8$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_1xntkt$: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_3cuuyy$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_p67zio$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_vqr6wr$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_gld13f$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_9fpnal$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_t73kuc$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      fold_8stajs$: function ($receiver, initial, operation) {
        var accumulator = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_v8qmra$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_4lvz2o$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_gtjzry$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_pn2g5j$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_tj8q8m$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_s4q4mb$: function ($receiver, initial, operation) {
        var accumulator = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_g9t0ho$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_8hjqyy$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_gu2wyd$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_9hsf09$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_xn4ira$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      foldRight_8stajs$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_v8qmra$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_4lvz2o$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_gtjzry$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_pn2g5j$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_tj8q8m$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_s4q4mb$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_g9t0ho$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_8hjqyy$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_qwc90p$: function ($receiver, initial, operation) {
        var index = _.kotlin.get_size_1($receiver) - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver.get_za3lpa$(index--), accumulator);
        }
        return accumulator;
      },
      foldRight_xn4ira$: function ($receiver, initial, operation) {
        var index = _.kotlin.get_size_0($receiver) - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver.charAt(index--), accumulator);
        }
        return accumulator;
      },
      forEach_de9h66$: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      forEach_50zxbw$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_x245au$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_h5ed0c$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_24jijj$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_im8pe8$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_1xntkt$: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      forEach_3cuuyy$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_p67zio$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_vqr6wr$: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_gld13f$: function ($receiver, operation) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_9fpnal$: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_t73kuc$: function ($receiver, operation) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      max_2hx8bi$: function ($receiver) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_964n92$: function ($receiver) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_355nu0$: function ($receiver) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_bvy38t$: function ($receiver) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_rjqrz0$: function ($receiver) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_tmsbgp$: function ($receiver) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_se6h4y$: function ($receiver) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_i2lc78$: function ($receiver) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      max_pdnvbz$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      max_pdl1w0$: function ($receiver) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      maxBy_de9h66$: function ($receiver, f) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_50zxbw$: function ($receiver, f) {
        if (_.kotlin.isEmpty_l1lu5s$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_x245au$: function ($receiver, f) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_h5ed0c$: function ($receiver, f) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_24jijj$: function ($receiver, f) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_im8pe8$: function ($receiver, f) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_1xntkt$: function ($receiver, f) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_3cuuyy$: function ($receiver, f) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_p67zio$: function ($receiver, f) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_vqr6wr$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_9fpnal$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_t73kuc$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_gld13f$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_s8ckw1$($receiver);
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      min_2hx8bi$: function ($receiver) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_964n92$: function ($receiver) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_355nu0$: function ($receiver) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_bvy38t$: function ($receiver) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_rjqrz0$: function ($receiver) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_tmsbgp$: function ($receiver) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_se6h4y$: function ($receiver) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_i2lc78$: function ($receiver) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      min_pdnvbz$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      min_pdl1w0$: function ($receiver) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      minBy_de9h66$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_50zxbw$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_x245au$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_h5ed0c$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_24jijj$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_im8pe8$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_1xntkt$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_3cuuyy$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_p67zio$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_vqr6wr$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_9fpnal$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_t73kuc$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_gld13f$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_s8ckw1$($receiver);
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      none_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return false;
          }
        }
        return true;
      },
      none_l1lu5s$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_964n92$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_355nu0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_bvy38t$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_rjqrz0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_tmsbgp$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return false;
          }
        }
        return true;
      },
      none_se6h4y$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_i2lc78$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_s8ckw1$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_pdnvbz$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_pdl1w0$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      reduce_de9h67$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_50zxbx$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_x245av$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_h5ed0b$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_24jijk$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_im8pe7$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_1xntks$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_3cuuyz$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_p67zip$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_vqr6ws$: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_9fpnam$: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_t73kub$: function ($receiver, operation) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduceRight_de9h67$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_50zxbx$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_x245av$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_h5ed0b$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_24jijk$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_im8pe7$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_1xntks$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_3cuuyz$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_p67zip$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_7bxqi8$: function ($receiver, operation) {
        var index = _.kotlin.get_size_1($receiver) - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver.get_za3lpa$(index--);
        while (index >= 0) {
          accumulator = operation($receiver.get_za3lpa$(index--), accumulator);
        }
        return accumulator;
      },
      reduceRight_t73kub$: function ($receiver, operation) {
        var index = _.kotlin.get_size_0($receiver) - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver.charAt(index--);
        while (index >= 0) {
          accumulator = operation($receiver.charAt(index--), accumulator);
        }
        return accumulator;
      },
      support: Kotlin.definePackage(function () {
        this.State = Kotlin.createObject(null, function () {
          this.Ready = 0;
          this.NotReady = 1;
          this.Done = 2;
          this.Failed = 3;
        });
      }, /** @lends _.kotlin.support */ {
        AbstractIterator: Kotlin.createClass(function () {
          return [Kotlin.Iterator];
        }, function () {
          this.state_xrvatb$ = _.kotlin.support.State.NotReady;
          this.nextValue_u0jzfw$ = null;
        }, /** @lends _.kotlin.support.AbstractIterator.prototype */ {
          hasNext: function () {
            _.kotlin.require_eltq40$(this.state_xrvatb$ !== _.kotlin.support.State.Failed);
            var tmp$0 = this.state_xrvatb$, tmp$1;
            if (tmp$0 === _.kotlin.support.State.Done)
              tmp$1 = false;
            else if (tmp$0 === _.kotlin.support.State.Ready)
              tmp$1 = true;
            else
              tmp$1 = this.tryToComputeNext();
            return tmp$1;
          },
          next: function () {
            if (!this.hasNext())
              throw new Kotlin.NoSuchElementException();
            this.state_xrvatb$ = _.kotlin.support.State.NotReady;
            return this.nextValue_u0jzfw$;
          },
          peek: function () {
            if (!this.hasNext())
              throw new Kotlin.NoSuchElementException();
            return this.nextValue_u0jzfw$;
          },
          tryToComputeNext: function () {
            this.state_xrvatb$ = _.kotlin.support.State.Failed;
            this.computeNext();
            return this.state_xrvatb$ === _.kotlin.support.State.Ready;
          },
          setNext_za3rmp$: function (value) {
            this.nextValue_u0jzfw$ = value;
            this.state_xrvatb$ = _.kotlin.support.State.Ready;
          },
          done: function () {
            this.state_xrvatb$ = _.kotlin.support.State.Done;
          }
        })
      })
    })
  });
  Kotlin.defineModule('kevoree', _);
}

module.exports = Kotlin.modules['kevoree'].org.kevoree;
module.exports.org = {
  kevoree: Kotlin.modules['kevoree'].org.kevoree
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"kevoree-kotlin":110}],110:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./lib/kotlin":111,"dup":102}],111:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"dup":103}],112:[function(require,module,exports){
/*
	Class - JavaScript inheritance

	Construction:
		Setup and construction should happen in the construct() method.
		The construct() method is automatically chained, so all construct() methods defined by superclass methods will be called first.

	Initialization:
		Initialziation that needs to happen after all construct() methods have been called should be done in the init() method.
		The init() method is not automatically chained, so you must call this._super() if you intend to call the superclass' init method.
		init() is not passed any arguments

	Destruction:
		Teardown and destruction should happen in the destruct() method. The destruct() method is also chained.

	Mixins:
		An array of mixins can be provided with the mixins[] property. An object or the prototype of a class should be provided, not a constructor.
		Mixins can be added at any time by calling this.mixin(properties)

	Usage:
		var MyClass = Class(properties);
		var MyClass = new Class(properties);
		var MyClass = Class.extend(properties);

	Credits:
		Inspired by Simple JavaScript Inheritance by John Resig http://ejohn.org/

	Usage differences:
		construct() is used to setup instances and is chained so superclass construct() methods run automatically
		destruct() is used to tear down instances. destruct() is also chained
		init(), if defined, is called after construction is complete and is not chained
		toString() can be defined as a string or a function
		mixin() is provided to mix properties into an instance
		properties.mixins as an array results in each of the provided objects being mixed in (last object wins)
		this._super() is supported in mixins
		properties, if defined, should be a hash of property descriptors as accepted by Object.defineProperties
*/
(function(global) {
	// Extend the current context by the passed objects
	function extendThis() {
		var i, ni, objects, object, prop;
		objects = arguments;
		for (i = 0, ni = objects.length; i < ni; i++) {
			object = objects[i];
			for (prop in object) {
				this[prop] = object[prop];
			}
		}

		return this;
	}

	// Return a function that calls the specified method, passing arguments
	function makeApplier(method) {
		return function() {
			return this[method].apply(this, arguments);
		};
	}

	// Merge and define properties
	function defineAndInheritProperties(Component, properties) {
		var constructor,
			descriptor,
			property,
			propertyDescriptors,
			propertyDescriptorHash,
			propertyDescriptorQueue;

		// Set properties
		Component.properties = properties;

		// Traverse the chain of constructors and gather all property descriptors
		// Build a queue of property descriptors for combination
		propertyDescriptorHash = {};
		constructor = Component;
		do {
			if (constructor.properties) {
				for (property in constructor.properties) {
					propertyDescriptorQueue = propertyDescriptorHash[property] || (propertyDescriptorHash[property] = []);
					propertyDescriptorQueue.unshift(constructor.properties[property]);
				}
			}
			constructor = constructor.superConstructor;
		}
		while (constructor);

		// Combine property descriptors, allowing overriding of individual properties
		propertyDescriptors = {};
		for (property in propertyDescriptorHash) {
			descriptor = propertyDescriptors[property] = extendThis.apply({}, propertyDescriptorHash[property]);

			// Allow setters to be strings
			// An additional wrapping function is used to allow monkey-patching
			// apply is used to handle cases where the setter is called directly
			if (typeof descriptor.set === 'string') {
				descriptor.set = makeApplier(descriptor.set);
			}
			if (typeof descriptor.get === 'string') {
				descriptor.get = makeApplier(descriptor.get);
			}
		}

		// Store option descriptors on the constructor
		Component.properties = propertyDescriptors;
	}

	// Used for default initialization methods
	var noop = function() {};

	// Given a function, the superTest RE will match if _super is used in the function
	// The function will be serialized, then the serialized string will be searched for _super
	// If the environment isn't capable of function serialization, make it so superTest.test always returns true
	var superTest = /xyz/.test(function(){return 'xyz';}) ? /\._super\b/ : { test: function() { return true; } };

	// Bind an overriding method such that it gets the overridden method as its first argument
	var superifyDynamic = function(name, func, superPrototype) {
		return function PseudoClass_setStaticSuper() {
			// Store the old super
			var previousSuper = this._super;

			// Use the method from the superclass' prototype
			// This strategy allows monkey patching (modification of superclass prototypes)
			this._super = superPrototype[name];

			// Call the actual function
			var ret = func.apply(this, arguments);

			// Restore the previous value of super
			// This is required so that calls to methods that use _super within methods that use _super work
			this._super = previousSuper;

			return ret;
		};
	};

	var superifyStatic = function(name, func, object) {
		// Store a reference to the overridden function
		var _super = object[name];

		return function PseudoClass_setDynamicSuper() {
			// Use the method stored at declaration time
			this._super = _super;

			// Call the actual function
			return func.apply(this, arguments);
		};
	};

	// Mix the provided properties into the current context with the ability to call overridden methods with _super()
	var mixin = function(properties, superPrototype) {
		// Use this instance's prototype if no prototype provided
		superPrototype = superPrototype || this.constructor && this.constructor.prototype;
		
		// Copy the properties onto the new prototype
		for (var name in properties) {
			var value = properties[name];

			// Never mix construct or destruct
			if (name === 'construct' || name === 'destruct')
				continue;

			// Check if the property if a method that makes use of _super:
			// 1. The value should be a function
			// 2. The super prototype should have a function by the same name
			// 3. The function should use this._super somewhere
			var usesSuper = superPrototype && typeof value === 'function' && typeof superPrototype[name] === 'function' && superTest.test(value);

			if (usesSuper) {
				// Wrap the function such that this._super will be available
				if (this.hasOwnProperty(name)) {
					// Properties that exist directly on the object should be superified statically
					this[name] = superifyStatic(name, value, this);
				}
				else {
					// Properties that are part of the superPrototype should be superified dynamically
					this[name] = superifyDynamic(name, value, superPrototype);
				}
			}
			else {
				// Directly assign the property
				this[name] = value;
			}
		}
	};

	// The base Class implementation acts as extend alias, with the exception that it can take properties.extend as the Class to extend
	var Class = function(properties) {
		// If a class-like object is passed as properties.extend, just call extend on it
		if (properties && properties.extend)
			return properties.extend.extend(properties);

		// Otherwise, just create a new class with the passed properties
		return Class.extend(properties);
	};
	
	// Add the mixin method to all classes created with Class
	Class.prototype.mixin = mixin;
	
	// Creates a new Class that inherits from this class
	// Give the function a name so it can refer to itself without arguments.callee
	Class.extend = function extend(properties) {
		// The constructor handles creating an instance of the class, applying mixins, and calling construct() and init() methods
		function Class() {
			// Optimization: Requiring the new keyword and avoiding usage of Object.create() increases performance by 5x
			if (this instanceof Class === false) {
				throw new Error('Cannot create instance without new operator');
			}

			// Set properties
			var propertyDescriptors = Class.properties;
			if (propertyDescriptors) {
				Object.defineProperties(this, propertyDescriptors);
			}

			// Optimization: Avoiding conditionals in constructor increases performance of instantiation by 2x
			this.construct.apply(this, arguments);

			this.init();
		}

		var superConstructor = this;
		var superPrototype = this.prototype;

		// Store the superConstructor
		// It will be accessible on an instance as follows:
		//	instance.constructor.superConstructor
		Class.superConstructor = superConstructor;

		// Add extend() as a static method on the constructor
		Class.extend = extend;

		// Create an object with the prototype of the superclass
		// Store the extended class' prototype as the prototype of the constructor
		var prototype = Class.prototype = Object.create(superPrototype);

		// Assign prototype.constructor to the constructor itself
		// This allows instances to refer to this.constructor.prototype
		// This also allows creation of new instances using instance.constructor()
		prototype.constructor = Class;

		// Store the superPrototype
		// It will be accessible on an instance as follows:
		//	instance.superPrototype
		//	instance.constructor.prototype.superPrototype
		prototype.superPrototype = superPrototype;

		if (properties) {
			// Set property descriptors aside
			// We'll first inherit methods, then we'll apply these
			var propertyDescriptors = properties.properties;
			delete properties.properties;

			// Mix the new properties into the class prototype
			// This does not copy construct and destruct
			mixin.call(prototype, properties, superPrototype);

			// Mix in all the mixins
			// This also does not copy construct and destruct
			if (Array.isArray(properties.mixins)) {
				for (var i = 0, ni = properties.mixins.length; i < ni; i++) {
					// Mixins should be _super enabled, with the methods defined in the prototype as the superclass methods
					mixin.call(prototype, properties.mixins[i], prototype);
				}
			}

			// Define properties from this class and its parent classes
			defineAndInheritProperties(Class, propertyDescriptors);

			// Chain the construct() method (supermost executes first) if necessary
			if (properties.construct) {
				var construct = properties.construct;
				if (superPrototype.construct) {
					prototype.construct = function() {
						superPrototype.construct.apply(this, arguments);
						construct.apply(this, arguments);
					};
				}
				else {
					prototype.construct = construct;
				}
			}
			
			// Chain the destruct() method in reverse order (supermost executes last) if necessary
			if (properties.destruct) {
				var destruct = properties.destruct;
				if (superPrototype.destruct) {
					prototype.destruct = function() {
						destruct.apply(this, arguments);
						superPrototype.destruct.apply(this, arguments);
					};
				}
				else {
					prototype.destruct = destruct;
				}
			}

			// Allow definition of toString as a string (turn it into a function)
			if (typeof properties.toString === 'string') {
				var className = properties.toString;
				prototype.toString = function() { return className; };
			}
		}

		// Define construct and init as noops if undefined
		// This serves to avoid conditionals inside of the constructor
		if (typeof prototype.construct !== 'function')
			prototype.construct = noop;
		if (typeof prototype.init !== 'function')
			prototype.init = noop;

		return Class;
	};
	
	if (typeof module !== 'undefined' && module.exports) {
		// Node.js Support
		module.exports = Class;
	}
	else if (typeof global.define === 'function') {
		(function(define) {
			// AMD Support
			define(function() { return Class; });
		}(global.define));
	}
	else {
		// Browser support
		global.Class = global.PseudoClass = Class;
	}
}(this));

},{}],"kevoree-comp-consoleprinter":[function(require,module,exports){
var AbstractComponent = require('kevoree-entities').AbstractComponent;

/**
 * Kevoree component
 * @type {ConsolePrinter}
 */
var ConsolePrinter = AbstractComponent.extend({
    toString: 'ConsolePrinter',

    construct: function () {
        this.lines = [];
    },

    in_input: function (msg) {
        var line = this.getName() + '>' + msg;
        this.lines.push(line);
        console.log(line);
    },

    uiController: function () {
        var that = this;
        return ['$scope', '$interval', function ($scope, $interval) {
            $scope.name = that.getName();
            $scope.lines = that.lines;

            $interval(function () {
                $scope.lines = that.lines;
            }, 1000);
        }];
    }
});

module.exports = ConsolePrinter;

},{"kevoree-entities":35}]},{},[]);
